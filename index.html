<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestão de Ponto - Justificativas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 16px;
        }

        /* Header Card */
        .header-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 24px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-card h1 {
            font-size: 30px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-card p {
            color: #94a3b8;
            margin-top: 4px;
        }

        .date-input {
            padding: 8px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
        }
        
        .date-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            padding: 24px;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border-color: rgba(148, 163, 184, 0.2);
        }

        .stat-card .label {
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-card .value {
            font-size: 30px;
            font-weight: bold;
            color: #e2e8f0;
        }

        /* Controls */
        .controls-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-left {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .btn-filter {
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border: 2px solid rgba(148, 163, 184, 0.2);
        }

        .btn-filter:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }

        .btn-filter.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border: 2px solid transparent;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .btn-filter.active:hover {
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .btn-clear {
            background: rgba(239, 68, 68, 0.15);
            color: #fca5a5;
            border: 2px solid rgba(239, 68, 68, 0.3);
        }

        .btn-clear:hover {
            background: rgba(239, 68, 68, 0.25);
            border-color: rgba(239, 68, 68, 0.5);
            transform: translateY(-2px);
        }

        .btn-generate {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-generate:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .checkbox-signature {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #faf5ff;
            border: 2px solid #d8b4fe;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-signature:hover {
            background: #f3e8ff;
        }

        .checkbox-signature input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-signature span {
            font-weight: 500;
            color: #7c3aed;
        }

        /* Table */
        .table-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
        }

        /* Scrollbar horizontal sticky */
        .table-card::-webkit-scrollbar {
            height: 14px;
        }

        .table-card::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 8px;
        }

        .table-card::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 8px;
            border: 2px solid #f1f5f9;
            cursor: grab;
        }

        .table-card::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #2563eb, #1e40af);
        }

        .table-card::-webkit-scrollbar-thumb:active {
            cursor: grabbing;
            background: #1e40af;
        }

        table {
            width: 100%;
            min-width: 2120px;
            border-collapse: collapse;
        }

        thead {
            background: linear-gradient(135deg, #1e40af, #3b82f6);
            color: white;
        }

        th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
        }

        th.center {
            text-align: center;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            color: #1f2937;
        }

        td.center {
            text-align: center;
        }

        tbody tr {
            transition: all 0.3s ease;
        }

        tbody tr:hover {
            background: #f9fafb;
            transform: translateX(4px);
        }

        tbody tr.inconsistency {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
        }

        tbody tr.selected {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
        }

        .punch-time {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .punch-time.present {
            color: #22c55e;
        }

        .punch-time.missing {
            color: #ef4444;
        }

        .punch-time.optional {
            color: #9ca3af;
        }

        /* ERRO: Horário fora de ordem cronológica */
        .punch-time.error-time {
            color: #ffffff !important;
            background: #b91c1c !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            font-weight: 700 !important;
            animation: pulseError 2s infinite;
        }

        @keyframes pulseError {
            0%, 100% {
                background: #b91c1c;
                box-shadow: 0 0 0 0 rgba(185, 28, 28, 0.7);
            }
            50% {
                background: #dc2626;
                box-shadow: 0 0 0 6px rgba(185, 28, 28, 0);
            }
        }

        /* APROVADO: Horário aprovado pelo RH */
        .punch-time.approved {
            color: #ffffff !important;
            background: #10b981 !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            font-weight: 700 !important;
        }

        .approved-badge {
            position: absolute;
            bottom: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: #10b981;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            line-height: 16px;
            text-align: center;
            font-weight: bold;
            z-index: 10;
        }

        .approve-icon {
            position: absolute;
            top: 2px;
            left: 2px;
            cursor: pointer;
            font-size: 16px;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 10;
        }

        .approve-icon:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .swap-icon {
            display: inline-block;
            cursor: pointer;
            font-size: 16px;
            margin-right: 6px;
            opacity: 0.7;
            transition: all 0.2s;
            vertical-align: middle;
            color: #3b82f6;
        }

        .swap-icon:hover {
            opacity: 1;
            transform: scale(1.2) rotate(180deg);
        }

        /* Edição Inline - Estilo Excel - REMOVIDO */

        .question-icon {
            position: absolute;
            top: 2px;
            right: 2px;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.6;
            transition: all 0.2s;
            z-index: 10;
        }

        .question-icon:hover {
            opacity: 1;
            transform: scale(1.15);
        }

        .has-question {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 14px;
            color: #f59e0b;
            filter: drop-shadow(0 0 2px rgba(245, 158, 11, 0.5));
            animation: pulse-question 2s ease-in-out infinite;
        }
        
        @keyframes pulse-question {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .editable-cell.editing {
            padding: 0 !important;
            background: rgba(15, 23, 42, 1) !important;
            box-shadow: inset 0 0 0 2px #3b82f6 !important;
        }

        .inline-input {
            width: 100%;
            height: 100%;
            border: none;
            background: rgba(15, 23, 42, 0.8);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 13px;
            text-align: center;
            padding: 8px 12px;
            color: #22c55e;
            outline: none;
        }

        .inline-input:focus {
            background: rgba(15, 23, 42, 1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .saving-cell {
            background: rgba(59, 130, 246, 0.2) !important;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-badge.ok {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.error {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Info Box */
        .info-box {
            margin-top: 24px;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            gap: 12px;
        }

        .info-box svg {
            flex-shrink: 0;
            margin-top: 4px;
            color: #60a5fa;
        }

        .info-box p {
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 4px;
        }

        .info-box ol {
            color: #cbd5e1;
            font-size: 14px;
            padding-left: 20px;
        }

        .info-box li {
            margin: 4px 0;
        }

        /* PDF Preview */
        .pdf-preview {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0f172a;
            z-index: 1000;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 32px;
            display: none;
        }

        .pdf-preview.active {
            display: block;
        }

        @media screen {
            .pdf-preview {
                overflow-y: auto;
                overflow-x: hidden;
            }
        }

        .pdf-controls {
            max-width: 210mm;
            margin: 0 auto 24px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pdf-controls h2 {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .pdf-controls p {
            color: #94a3b8;
        }

        .pdf-controls-buttons {
            display: flex;
            gap: 12px;
        }

        .btn-print {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-print:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-close {
            background: rgba(75, 85, 99, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: white;
        }

        .btn-close:hover {
            background: rgba(55, 65, 81, 1);
        }

        /* Form Page A4 Landscape */
        .form-page {
            width: 297mm;
            height: 210mm;
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin: 0 auto 32px;
            padding: 10mm;
            overflow: hidden;
        }

        @media screen {
            .form-page {
                max-width: calc(100vw - 64px);
                width: auto;
                aspect-ratio: 297/210;
            }
        }

        @media print {
            body { 
                margin: 0 !important; 
                padding: 0 !important;
                background: white !important;
                overflow: hidden !important;
            }
            
            html {
                overflow: hidden !important;
            }
            
            @page { 
                size: A4 landscape; 
                margin: 0mm;
            }
            
            .pdf-preview {
                position: static !important;
                padding: 0 !important;
                background: white !important;
                overflow: visible !important;
            }
            
            .pdf-controls { 
                display: none !important; 
            }
            
            .form-page {
                page-break-after: always;
                page-break-inside: avoid;
                margin: 0 !important;
                padding: 10mm !important;
                box-shadow: none !important;
                width: 297mm !important;
                height: 210mm !important;
                max-width: none !important;
                overflow: visible !important;
            }
            
            .form-page:last-child {
                page-break-after: auto;
            }
            
            #pdfPages {
                margin: 0 !important;
                padding: 0 !important;
            }
        }

        .form-border {
            border: 4px solid black;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .form-header {
            background: #d1d5db;
            border-bottom: 2px solid black;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-circle {
            width: 48px;
            height: 48px;
            background: #4b5563;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .logo-text {
            font-weight: bold;
            font-size: 20px;
        }

        .form-title {
            flex: 1;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            color: #1f2937;
        }

        .form-orientation {
            font-size: 12px;
            padding: 8px 16px;
            background: #f3f4f6;
            border-bottom: 2px solid #9ca3af;
            color: #1f2937;
        }

        .form-employee-data {
            padding: 12px 16px;
            border-bottom: 2px solid #9ca3af;
            font-size: 16px;
            color: #1f2937;
        }

        .form-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 16px;
            margin-bottom: 8px;
        }

        .form-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        .form-field {
            display: flex;
            gap: 8px;
        }

        .form-field-label {
            font-weight: 600;
            color: #374151;
        }

        .form-field-value {
            font-weight: bold;
            color: #1f2937;
        }

        .section-header {
            background: #374151;
            color: white;
            text-align: center;
            padding: 8px;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid black;
        }

        .form-times {
            flex: 1;
            padding: 24px;
            background: #f9fafb;
            border-bottom: 2px solid #9ca3af;
        }

        .times-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 32px;
            align-items: center;
            height: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .time-slot {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .time-value {
            font-size: 24px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .time-value.present {
            color: black;
        }

        .time-value.missing {
            color: #000;
            background: transparent;
            padding: 0;
            border: none;
            font-size: 28px;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            letter-spacing: 8px;
        }

        .time-status {
            font-size: 12px;
            font-weight: bold;
            padding: 2px 12px;
            border-radius: 4px;
        }

        .time-status.batido {
            background: #dcfce7;
            color: #166534;
        }

        .time-status.justificar {
            background: #fee2e2;
            color: #991b1b;
        }

        .form-justification {
            padding: 12px 16px;
            background: #f9fafb;
            border-bottom: 2px solid #9ca3af;
        }

        .justification-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            font-size: 14px;
            margin-bottom: 8px;
            color: #1f2937;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #1f2937;
        }

        .checkbox-item input {
            width: 16px;
            height: 16px;
        }

        .obs-field {
            margin-top: 8px;
            font-size: 12px;
            color: #1f2937;
        }

        .obs-field .obs-label {
            font-weight: 600;
        }

        .obs-line {
            border-bottom: 2px solid #9ca3af;
            margin-top: 4px;
            padding-bottom: 8px;
        }

        .form-signatures {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 16px;
            margin-top: auto;
        }

        .signature-box {
            text-align: center;
            color: #1f2937;
        }

        .signature-box.left {
            padding-right: 32px;
            border-right: 2px solid #9ca3af;
        }

        .signature-box.right {
            padding-left: 32px;
        }

        .signature-space {
            height: 64px;
        }

        .signature-line {
            border-top: 2px solid black;
            padding-top: 8px;
        }

        .signature-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 4px;
            color: #1f2937;
        }

        .signature-label {
            font-size: 12px;
            color: #4b5563;
        }

        /* Estilo para células de horário com setas de navegação */
        .punch-cell {
            position: relative;
        }

        .selected-cell {
            background: #dbeafe !important;
            outline: 2px solid #3b82f6 !important;
        }

        .swap-arrow {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #3b82f6;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            transition: all 0.15s;
        }

        .swap-arrow:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .digital-signature {
            font-weight: bold;
            font-style: italic;
            font-size: 36px;
            font-family: 'Brush Script MT', cursive;
            color: #1e40af;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .form-footer {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
            margin-top: 8px;
        }

        .hidden {
            display: none;
        }

        #pdfPages {
            margin: 0;
            padding: 0;
        }

        /* Upload de Anexo */
        .upload-btn {
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .upload-btn:hover {
            background: #2563eb;
        }

        .attached-file {
            background: #dcfce7;
            color: #166534;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .remove-file {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 10px;
        }

        .motivo-field {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
        }

        /* Botão API */
        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .api-status.connected {
            background: #f1f5f9;
            color: #0f172a;
            border: 2px solid #10b981;
        }

        .api-status.disconnected {
            background: #f1f5f9;
            color: #64748b;
            border: 2px solid #cbd5e1;
        }

        .btn-api {
            background: #6b7280;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-api:hover {
            background: #047857;
        }

        .btn-config {
            background: #6b7280;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-config:hover {
            background: #4b5563;
        }

        .btn-company {
            padding: 8px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .btn-company:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(148, 163, 184, 0.5);
            transform: translateY(-2px);
        }

        .btn-company.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white !important;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-company.loading {
            opacity: 0.6;
            cursor: wait;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            padding: 32px 48px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(148, 163, 184, 0.2);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: #e2e8f0;
            margin: 0;
        }

        /* Custom Alert Popup */
        .custom-alert {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            backdrop-filter: blur(10px);
        }

        .custom-alert.active {
            display: flex;
        }

        .alert-content {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            padding: 0;
            border-radius: 16px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.1);
            animation: slideUp 0.3s ease-out;
            overflow: hidden;
        }

        .alert-header {
            padding: 24px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .alert-header.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .alert-header.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .alert-header.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .alert-header.info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .alert-title {
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .alert-body {
            padding: 24px;
            color: #e2e8f0;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .alert-footer {
            padding: 16px 24px;
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .alert-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            font-size: 14px;
            transition: all 0.2s;
        }

        .alert-btn.primary {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
        }

        .alert-btn.primary:hover {
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .alert-btn.secondary {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .alert-btn.secondary:hover {
            background: rgba(51, 65, 85, 1);
            border-color: rgba(148, 163, 184, 0.3);
        }
    </style>
    
    <!-- Google Cloud Vision API (substitui Tesseract) -->
</head>
<body>
    <!-- ==========================================
         AUTENTICAÇÃO - Verificar login Secullum
         ========================================== -->
    <script>
        // Verificar autenticação ANTES de carregar a página
        (function() {
            const token = localStorage.getItem('secullum_token');
            const expiry = localStorage.getItem('secullum_token_expiry');
            const userName = localStorage.getItem('user_name') || localStorage.getItem('secullum_username') || 'Usuário';
            
            // Se não tem token OU token expirou, redirecionar para login
            if (!token || !expiry || Date.now() >= parseInt(expiry)) {
                console.log('⚠️ Token inválido ou expirado, redirecionando para login...');
                localStorage.clear(); // Limpar tudo
                window.location.href = '/login.html';
                return;
            }
            
            console.log('✅ Usuário autenticado:', userName);
            window.CURRENT_USER = userName;
            
            // Atualizar nome do usuário no header quando carregar
            document.addEventListener('DOMContentLoaded', () => {
                const userNameElement = document.getElementById('userName');
                if (userNameElement) {
                    userNameElement.textContent = userName;
                }
                
                // Conectar API automaticamente ao carregar a página
                setTimeout(() => {
                    connectToAPI();
                }, 500);
            });
        })();
    </script>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p class="loading-text" id="loadingText">Carregando...</p>
        </div>
    </div>

    <!-- Custom Alert -->
    <div class="custom-alert" id="customAlert">
        <div class="alert-content">
            <div class="alert-header" id="alertHeader">
                <div class="alert-title" id="alertTitle"></div>
            </div>
            <div class="alert-body" id="alertBody"></div>
            <div class="alert-footer">
                <button class="alert-btn primary" id="alertOkBtn">OK</button>
            </div>
        </div>
    </div>

    <!-- Modal de Pergunta -->
    <div class="custom-alert" id="questionModal">
        <div class="alert-content" style="min-width: 500px;">
            <div class="alert-header warning">
                <div class="alert-title">❓ Pergunta ao Colaborador</div>
            </div>
            <div class="alert-body">
                <p id="questionContext" style="margin-bottom: 16px; font-weight: 600;"></p>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #e2e8f0;">Digite a pergunta:</label>
                <textarea id="questionInput" 
                          rows="4" 
                          style="width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; font-family: inherit; resize: vertical;"
                          placeholder="Ex: Por que bateu o ponto às 10:00 se não estava trabalhando?"></textarea>
            </div>
            <div class="alert-footer">
                <button class="alert-btn secondary" id="questionCancelBtn">Cancelar</button>
                <button class="alert-btn primary" id="questionOkBtn">Adicionar Pergunta</button>
            </div>
        </div>
    </div>

    <!-- Modal Monitor de Máquinas -->
    <div class="custom-alert" id="machineMonitorModal">
        <div class="alert-content" style="min-width: 900px; max-width: 95vw;">
            <div class="alert-header" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
                <div class="alert-title">🖥️ Monitor de Relógios de Ponto</div>
            </div>
            <div class="alert-body" style="max-height: 70vh; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 16px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 8px;">
                    <div>
                        <div style="font-size: 12px; color: #94a3b8; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Última Atualização</div>
                        <div id="monitorLastUpdate" style="font-size: 18px; font-weight: 700; color: #e2e8f0; margin-top: 4px;">--:--:--</div>
                    </div>
                    <button class="btn" onclick="refreshMachineMonitor()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 10px 20px;">
                        <span>🔄</span>
                        <span>Atualizar</span>
                    </button>
                </div>
                <div id="machineMonitorContent">
                    <!-- Será preenchido pelo JavaScript -->
                </div>
            </div>
            <div class="alert-footer">
                <button class="alert-btn secondary" onclick="closeMachineMonitor()">Fechar</button>
                <button class="alert-btn primary" onclick="exportMachineMonitor()">📸 Exportar Print</button>
            </div>
        </div>
    </div>

    <!-- Main Interface -->
    <div id="mainInterface" class="container">
        <!-- Header -->
        <div class="header-card" style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1>Gestão de Ponto - Justificativas</h1>
                <p>Sistema de geração automática de formulários</p>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <!-- BOTÃO DE TESTE - ANEXO OCR -->
                <button id="btnTesteAnexo" style="margin: 0; font-size: 14px; padding: 10px 20px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                    🧪 TESTE ANEXO
                </button>
                <input type="file" id="inputTesteAnexo" accept="image/*" style="display: none;">
                
                <div id="userInfo" style="margin-right: 16px; text-align: right; color: #94a3b8;">
                    <small style="display: block; font-size: 12px;">Logado como:</small>
                    <strong style="display: block; color: #e2e8f0;" id="userName">Admin</strong>
                </div>
                <button class="btn" id="btnMachineMonitor" onclick="openMachineMonitor()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
                    <span>🖥️</span>
                    <span>MONITOR</span>
                </button>
                <button class="btn" onclick="openPresencePanel()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                    <span>✅</span>
                    <span>PRESENÇA</span>
                </button>
                <button class="btn btn-generate" id="btnGenerateTopRight" style="margin: 0; font-size: 16px; padding: 12px 24px;">
                    <span>📄</span>
                    <span>GERAR PDF</span>
                </button>
                <button class="btn" onclick="logout()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: #ef4444;">
                    <span>🚪</span>
                    <span>SAIR</span>
                </button>
            </div>
        </div>

        <!-- Empresas e Status API -->
        <div class="header-card" style="margin-top: 20px;">
            <div style="display: flex; gap: 20px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                <!-- Empresas -->
                <div style="flex: 1; min-width: 300px;">
                    <label style="display: block; font-size: 13px; font-weight: 600; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">🏢 Empresas</label>
                    <div id="companyButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn-company active" data-company="all" onclick="selectCompany('all', this)" style="background: linear-gradient(135deg, #3b82f6, #8b5cf6); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                            📊 TODAS
                        </button>
                        <!-- Botões das empresas serão adicionados aqui pelo JavaScript -->
                    </div>
                </div>
                
                <!-- Status API -->
                <div style="display: flex; gap: 12px; align-items: center; padding: 12px 16px; background: rgba(15, 23, 42, 0.6); border-radius: 10px; border: 2px solid rgba(148, 163, 184, 0.2);">
                    <span class="api-status disconnected" id="apiStatus" style="background: rgba(15, 23, 42, 0.8); color: #94a3b8; border: 2px solid rgba(148, 163, 184, 0.2); padding: 8px 16px; border-radius: 8px; font-weight: 600; font-size: 13px; display: flex; align-items: center; gap: 8px;">
                        <span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span>
                        Conectando API...
                    </span>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls-card">
            <div class="controls-left" style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; flex: 1;">
                <!-- Filtros de Data -->
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">Data Início</label>
                    <input type="date" class="date-input" id="dateStart" style="font-size: 13px; padding: 8px 10px; height: 38px;">
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">Data Fim</label>
                    <input type="date" class="date-input" id="dateEnd" style="font-size: 13px; padding: 8px 10px; height: 38px;">
                </div>
                <button class="btn-primary" id="btnSearchDates" style="padding: 9px 16px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; height: 38px;">
                    🔍 Buscar Período
                </button>
                
                <!-- Filtro por Nome -->
                <div style="flex: 1; min-width: 200px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">🔍 Filtrar por Nome</label>
                    <input type="text" class="date-input" id="searchName" placeholder="Digite o nome..." style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <!-- Filtro por Líder -->
                <div style="min-width: 180px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">👤 Líder</label>
                    <input type="text" class="date-input" id="searchLider" placeholder="Nome do líder..." style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <!-- Filtro por Projeto -->
                <div style="min-width: 150px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">📋 Projeto</label>
                    <input type="text" class="date-input" id="searchProject" placeholder="Ex: 400" style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <button class="btn-primary" id="btnClearFilter" style="padding: 9px 14px; background: rgba(239, 68, 68, 0.15); color: #fca5a5; border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; height: 38px;">
                    ✖ Limpar
                </button>
                
                <!-- Botão de filtro -->
                <button class="btn btn-filter" id="btnFilter" style="height: 38px;">
                    <span>⚡</span>
                    <span id="filterText">Mostrar Só Inconsistências</span>
                </button>
            </div>
        </div>

        <!-- Table -->
        <div class="table-card">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40px;">
                            <input type="checkbox" id="selectAll" style="width: 18px; height: 18px; cursor: pointer;">
                        </th>
                        <th style="width: 50px;">ID</th>
                        <th style="width: 80px;">REG</th>
                        <th style="min-width: 150px; max-width: 180px;">LÍDER</th>
                        <th style="min-width: 100px; max-width: 120px;">PROJ (BDO)</th>
                        <th style="min-width: 120px; max-width: 140px;">DEPTO (SEC)</th>
                        <th style="min-width: 180px; max-width: 220px;">NOME</th>
                        <th style="width: 140px;">CPF</th>
                        <th style="min-width: 140px;">EMPRESA</th>
                        <th style="width: 100px;">DATA</th>
                        <th style="width: 80px;" class="center">ENT. 1</th>
                        <th style="width: 80px;" class="center">SAÍ. 1</th>
                        <th style="width: 80px;" class="center">ENT. 2</th>
                        <th style="width: 80px;" class="center">SAÍ. 2</th>
                        <th style="width: 80px;" class="center">ENT. 3</th>
                        <th style="width: 80px;" class="center">SAÍ. 3</th>
                        <th style="width: 80px;" class="center">ENT. 4</th>
                        <th style="width: 80px;" class="center">SAÍ. 4</th>
                        <th style="width: 80px;" class="center">ENT. 5</th>
                        <th style="width: 80px;" class="center">SAÍ. 5</th>
                        <th style="width: 70px;" class="center" title="ID de Impressão">ID IMP</th>
                        <th style="min-width: 150px; max-width: 200px;">MOTIVO</th>
                        <th style="width: 100px;">ANEXOS</th>
                        <th style="width: 90px;" class="center">STATUS</th>
                    </tr>
                </thead>
                <tbody id="employeeTable">
                    <!-- Será preenchido pelo JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- Modal de Edição de Batidas -->
        <div id="editModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 12px; padding: 32px; max-width: 600px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-size: 24px; font-weight: bold; background: linear-gradient(135deg, #60a5fa, #a78bfa); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0;">✏️ Editar Batidas</h2>
                    <button onclick="closeEditModal()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #94a3b8; padding: 0; width: 32px; height: 32px; line-height: 1;">×</button>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 16px; border-radius: 8px; margin-bottom: 24px; border: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="font-weight: 600; color: #e2e8f0;" id="editEmployeeName">NOME DO FUNCIONÁRIO</div>
                    <div style="font-size: 14px; color: #94a3b8; margin-top: 4px;">
                        REG: <span id="editEmployeeReg">000</span> | Data: <span id="editEmployeeDate">00/00/0000</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px;">
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 1</label>
                        <input type="time" id="editEnt1" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 1</label>
                        <input type="time" id="editSai1" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 2</label>
                        <input type="time" id="editEnt2" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 2</label>
                        <input type="time" id="editSai2" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 3</label>
                        <input type="time" id="editEnt3" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 3</label>
                        <input type="time" id="editSai3" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 4</label>
                        <input type="time" id="editEnt4" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 4</label>
                        <input type="time" id="editSai4" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 5</label>
                        <input type="time" id="editEnt5" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 5</label>
                        <input type="time" id="editSai5" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="closeEditModal()" style="padding: 12px 24px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(51, 65, 85, 0.8); color: #e2e8f0; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 16px;">
                        Cancelar
                    </button>
                    <button onclick="confirmSaveEdit()" style="padding: 12px 24px; border: none; background: linear-gradient(135deg, #10b981, #059669); color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                        ✓ Confirmar e Enviar
                    </button>
                </div>
            </div>
        </div>

        <!-- Info -->
    </div>

    <!-- PDF Preview -->
    <div id="pdfPreview" class="pdf-preview">
        <div class="pdf-controls">
            <div>
                <h2>Pré-visualização - Formato Paisagem</h2>
                <p id="pdfCount">0 formulário(s) • 1 por página A4 Paisagem</p>
            </div>
            <div class="pdf-controls-buttons">
                <button class="btn btn-print" onclick="window.print()">
                    <span>🖨️</span>
                    <span>Imprimir Todas</span>
                </button>
                <button class="btn btn-close" id="btnClosePDF">
                    <span>✖️</span>
                    <span>Fechar</span>
                </button>
            </div>
        </div>
        <div id="pdfPages">
            <!-- Será preenchido pelo JavaScript -->
        </div>
    </div>

    <script>
        // ==========================================
        // SISTEMA DE LOADING E POPUPS
        // ==========================================
        function showLoading(text = 'Carregando...') {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.classList.add('active');
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
        }

        function showAlert(title, message, type = 'info') {
            const alert = document.getElementById('customAlert');
            const header = document.getElementById('alertHeader');
            const titleEl = document.getElementById('alertTitle');
            const body = document.getElementById('alertBody');
            
            // Ícones baseados no tipo
            const icons = {
                success: '✅',
                error: '❌',
                warning: '⚠️',
                info: 'ℹ️'
            };
            
            titleEl.innerHTML = `${icons[type] || icons.info} ${title}`;
            body.textContent = message;
            header.className = `alert-header ${type}`;
            alert.classList.add('active');
        }

        function hideAlert() {
            document.getElementById('customAlert').classList.remove('active');
        }

        // Alias para compatibilidade
        function showNotification(message, type = 'info') {
            const titles = {
                success: 'Sucesso',
                error: 'Erro',
                warning: 'Atenção',
                info: 'Informação'
            };
            showAlert(titles[type] || titles.info, message, type);
        }

        // Fechar alert ao clicar no botão OK
        document.getElementById('alertOkBtn').addEventListener('click', () => {
            document.getElementById('customAlert').classList.remove('active');
        });

        // Fechar alert ao clicar fora
        document.getElementById('customAlert').addEventListener('click', (e) => {
            if (e.target.id === 'customAlert') {
                document.getElementById('customAlert').classList.remove('active');
            }
        });

        // ==========================================
        // JUSTIFICATIVAS PADRONIZADAS
        // ==========================================
        const JUSTIFICATIVAS_PADRAO = [
            'Esqueceu de registrar o Ponto',
            'Falha no App',
            'Falta',
            'Folga',
            'Hora Parada',
            'Maquina Ponto com defeito',
            'Registro em duplicidade',
            'Registro indevido'
        ];

        // Mapeamento OCR → Justificativa Padronizada
        const MAPEAMENTO_JUSTIFICATIVAS = {
            'esqueceu de registrar o ponto': 'Esqueceu de registrar o Ponto',
            'esqueceu': 'Esqueceu de registrar o Ponto',
            'esquecimento': 'Esqueceu de registrar o Ponto',
            'falha no app': 'Falha no App',
            'falha app': 'Falha no App',
            'falta': 'Falta',
            'folga': 'Folga',
            'hora parada': 'Hora Parada',
            'maquina ponto com defeito': 'Maquina Ponto com defeito',
            'maquina defeito': 'Maquina Ponto com defeito',
            'defeito': 'Maquina Ponto com defeito',
            'registro em duplicidade': 'Registro em duplicidade',
            'duplicidade': 'Registro em duplicidade',
            'registro indevido': 'Registro indevido',
            'indevido': 'Registro indevido'
        };

        // ==========================================
        // CONFIGURAÇÃO DA API SECULLUM
        // ==========================================
        const API_CONFIG = {
            authURL: 'https://autenticador.secullum.com.br/Token',
            baseURL: 'https://pontowebintegracaoexterna.secullum.com.br',
            token: '',
            credentials: {
                grant_type: 'password',
                username: 'ferreira.eduardo@larsil.com.br',
                password: 'larsil123@',
                client_id: '3'
            },
            companies: [], // Será preenchido dinamicamente pela API
            selectedCompanies: ['all'], // 'all' ou array de IDs
            endpoints: {
                auth: '/Token',
                batidas: '/Batidas',
                funcionarios: '/Funcionarios',
                justificativas: '/Justificativas',
                cartaoPontoManual: '/CartaoPonto/Manual',
                cartaoPontoJustificativa: '/CartaoPonto/Justificativa',
                calcular: '/Calcular',
                pendencias: '/Pendencias'
            }
        };

        // ==========================================
        // HELPER: Adicionar token de autenticação em todas as requisições
        // ==========================================
        function getAuthHeaders(additionalHeaders = {}) {
            const token = localStorage.getItem('token') || sessionStorage.getItem('token');
            
            if (!token) {
                console.warn('⚠️ Token não encontrado - algumas funcionalidades podem não funcionar');
                return {
                    'Content-Type': 'application/json',
                    ...additionalHeaders
                };
            }
            
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                ...additionalHeaders
            };
        }

        // Helper para fetch com autenticação (retorna null se não autenticado)
        async function authenticatedFetch(url, options = {}) {
            const headers = getAuthHeaders(options.headers || {});
            if (!headers) {
                console.warn('⚠️ Requisição ignorada - sem autenticação:', url);
                return null;
            }
            return fetch(url, { ...options, headers });
        }

        // ==========================================
        // CONFIGURAÇÃO GLOBAL DA API
        // ==========================================
        const API_BASE_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : 'https://justificativas.up.railway.app';

        // ==========================================
        // CONFIGURAÇÃO SQL AZURE (Node.js API)
        // ==========================================
        const SQL_API = {
            baseURL: `${API_BASE_URL}/api`,
            endpoints: {
                colaboradores: '/colaboradores',
                colaboradorByCPF: '/colaboradores/cpf',
                colaboradoresBatchCPF: '/colaboradores/batch-cpf'
            }
        };

        // Cache de dados do SQL Azure
        let sqlColaboradoresCache = {};

        // Função para buscar colaborador por CPF no SQL Azure
        async function getColaboradorByCPF(cpf) {
            try {
                // Verificar se já está no cache
                const cpfLimpo = cpf.replace(/[^\d]/g, '');
                if (sqlColaboradoresCache[cpfLimpo]) {
                    return sqlColaboradoresCache[cpfLimpo];
                }

                const response = await fetch(`${SQL_API.baseURL}${SQL_API.endpoints.colaboradorByCPF}/${cpfLimpo}`);
                
                if (response.ok) {
                    const data = await response.json();
                    sqlColaboradoresCache[cpfLimpo] = data;
                    return data;
                }
                
                return null;
            } catch (error) {
                console.warn(`⚠️ Erro ao buscar colaborador CPF ${cpf}:`, error.message);
                return null;
            }
        }

        // Função para buscar múltiplos colaboradores por CPFs (batch - mais rápido)
        async function getColaboradoresBatchCPF(cpfs) {
            try {
                const response = await fetch(`${SQL_API.baseURL}${SQL_API.endpoints.colaboradoresBatchCPF}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ cpfs })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Adicionar ao cache
                    data.forEach(colab => {
                        const cpfLimpo = colab.CPF.replace(/[^\d]/g, '');
                        sqlColaboradoresCache[cpfLimpo] = colab;
                    });
                    
                    console.log(`✅ ${data.length} colaboradores carregados do SQL Azure`);
                    return data;
                }
                
                return [];
            } catch (error) {
                console.warn('⚠️ Erro ao buscar colaboradores em batch:', error.message);
                return [];
            }
        }

        // Função para autenticar na API Secullum
        async function authenticateAPI() {
            try {
                const body = new URLSearchParams({
                    grant_type: API_CONFIG.credentials.grant_type,
                    username: API_CONFIG.credentials.username,
                    password: API_CONFIG.credentials.password,
                    client_id: API_CONFIG.credentials.client_id
                });

                const response = await fetch(API_CONFIG.authURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: body.toString()
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Falha na autenticação: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                API_CONFIG.token = data.access_token;
                console.log('✅ Autenticado com sucesso!');
                console.log('🔑 Token:', API_CONFIG.token.substring(0, 50) + '...');
                
                // Buscar empresas disponíveis após autenticação
                await loadCompanies();
                
                return true;
            } catch (error) {
                console.error('❌ Erro na autenticação:', error);
                alert(`Erro ao conectar com a API Secullum:\n\n${error.message}\n\nVerifique as credenciais.`);
                return false;
            }
        }

        // Função para buscar empresas (bancos) disponíveis
        async function loadCompanies() {
            try {
                
                const response = await fetch('https://autenticador.secullum.com.br/ContasSecullumExterno/ListarBancos', {
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao buscar empresas: ${response.status}`);
                }

                const bancos = await response.json();
                console.log(`✅ ${bancos.length} empresas encontradas`);
                
                // Cores para os botões
                const cores = ['#7c3aed', '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#ec4899', '#8b5cf6', '#14b8a6'];
                
                API_CONFIG.companies = bancos.map((banco, index) => ({
                    id: banco.id.toString(),
                    name: banco.nome || banco.razaoSocial || `Empresa ${banco.id}`,
                    color: cores[index % cores.length],
                    documento: banco.documento
                }));
                
                // Atualizar botões de empresas
                initCompanyButtons();
                
                
                
            } catch (error) {
                console.error('❌ Erro ao buscar empresas:', error);
                // Fallback para empresas padrão
                API_CONFIG.companies = [
                    { id: '3', name: 'LARSIL SERVICOS FLORESTAIS LTDA', color: '#7c3aed' }
                ];
                initCompanyButtons();
            }
        }

        // Função para enriquecer batidas com nomes dos funcionários
        async function enrichWithEmployeeNames(batidas, companies) {
            console.log('👥 Buscando nomes dos funcionários...');
            
            const funcionariosCache = new Map();
            const funcionariosAtivosSet = new Set(); // ✅ REGISTRAR APENAS FUNCIONÁRIOS ATIVOS
            
            for (const company of companies) {
                try {
                    const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Funcionarios`;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${API_CONFIG.token}`,
                            'secullumidbancoselecionado': company.id,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const funcionarios = await response.json();
                        
                        // FILTRAR: Apenas funcionários ATIVOS (sem data de demissão)
                        const funcionariosAtivos = funcionarios.filter(func => {
                            // ✅ CAMPO CORRETO: "Demissao" (conforme documentação Secullum)
                            const dataDemissao = func.Demissao || null;
                            
                            // Se tem data de demissão preenchida, EXCLUIR (não mostrar)
                            if (dataDemissao && dataDemissao !== '0001-01-01T00:00:00' && dataDemissao !== null) {
                                return false; // Demitido - não mostrar
                            }
                            
                            // Se não tem demissão, é ATIVO
                            return true;
                        });
                        
                        console.log(`✅ ${company.name}: ${funcionariosAtivos.length} funcionários ativos (total: ${funcionarios.length})`);
                        
                        funcionariosAtivos.forEach(func => {
                            const reg = func.NumeroIdentificador || func.NumeroFolha;
                            const key = `${company.id}_${reg}`;
                            
                            // Debug removido para performance
                            
                            // ✅ EXTRAIR DEPARTAMENTO (pode ser string ou objeto)
                            let departamento = null;
                            if (func.Departamento) {
                                if (typeof func.Departamento === 'string') {
                                    departamento = func.Departamento;
                                } else if (typeof func.Departamento === 'object') {
                                    // Se for objeto, tentar pegar Nome, Descricao, Codigo ou Id
                                    departamento = func.Departamento.Nome || 
                                                  func.Departamento.Descricao || 
                                                  func.Departamento.Codigo || 
                                                  func.Departamento.Id || 
                                                  null;
                                }
                            }
                            
                            funcionariosCache.set(key, {
                                nome: func.Nome || func.NomeCompleto || 'Nome não informado',
                                cpf: func.Cpf || func.CPF || '',
                                pis: func.NumeroPis || func.PIS || '',
                                // ✅ DEPARTAMENTO DA API SECULLUM
                                projetoSecullum: departamento
                            });
                            
                            // ✅ MARCAR como ATIVO
                            funcionariosAtivosSet.add(key);
                        });
                    }
                } catch (error) {
                    console.warn(`⚠️ Erro ao buscar funcionários de ${company.name}`);
                }
            }
            
            // ✅ FILTRAR batidas: mostrar APENAS funcionários ATIVOS (silencioso)
            const batidasFiltradas = batidas.filter(batida => {
                const reg = batida.Funcionario?.NumeroIdentificador || batida.Funcionario?.NumeroFolha;
                const key = `${batida._empresaId}_${reg}`;
                
                // Se NÃO está no Set de ativos, NÃO mostrar (demitido/inativo)
                if (!funcionariosAtivosSet.has(key)) {
                    return false;
                }
                
                // Enriquecer com nome se estiver no cache
                const funcInfo = funcionariosCache.get(key);
                if (funcInfo) {
                    batida._funcionarioNome = funcInfo.nome;
                    batida._funcionarioCpf = funcInfo.cpf;
                    batida._projetoSecullum = funcInfo.projetoSecullum; // ✅ PROJETO DA API SECULLUM
                }
                
                return true;
            });
            
            console.log(`✅ Nomes carregados! ${batidasFiltradas.length} registros (apenas funcionários ativos)`);
            
            // ✅ SUBSTITUIR array original
            batidas.length = 0;
            batidas.push(...batidasFiltradas);
        }

        // Função auxiliar para aguardar (delay)
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Função para buscar batidas de todas as empresas selecionadas
        async function fetchEmployeesFromAPI(dateStart, dateEnd) {
            try {
                // API Secullum espera formato ISO: YYYY-MM-DD (não converter para dd/MM/yyyy)
                console.log(`📅 Buscando batidas de ${dateStart} até ${dateEnd}...`);

                let allBatidas = [];
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));

                // Buscar dados de cada empresa
                for (let i = 0; i < companies.length; i++) {
                    const company = companies[i];
                    
                    
                    // Usar formato ISO diretamente (YYYY-MM-DD)
                    const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Batidas?dataInicio=${dateStart}&dataFim=${dateEnd}`;

                    let attempts = 0;
                    let success = false;
                    
                    while (attempts < 3 && !success) {
                        try {
                            const response = await fetch(url, {
                                method: 'GET',
                                headers: {
                                    'Authorization': `Bearer ${API_CONFIG.token}`,
                                    'secullumidbancoselecionado': company.id,
                                    'Content-Type': 'application/json'
                                }
                            });

                            if (!response.ok) {
                                const errorText = await response.text();
                                console.warn(`⚠️ Erro ao buscar ${company.name}: ${response.status} - ${errorText}`);
                                attempts++;
                                if (attempts < 3) {
                                    console.log(`🔄 Tentando novamente em 500ms... (tentativa ${attempts+1}/3)`);
                                    await sleep(500);
                                }
                                continue;
                            }

                            const result = await response.json();
                            
                            
                            
                            // Log detalhado para investigar "FALTA"
                            const batidaComFalta = result.find(b => 
                                b.Entrada1 === 'FALTA' || b.Saida1 === 'FALTA' ||
                                b.Entrada2 === 'FALTA' || b.Saida2 === 'FALTA' ||
                                b.Entrada3 === 'FALTA' || b.Saida3 === 'FALTA' ||
                                b.Entrada4 === 'FALTA' || b.Saida4 === 'FALTA' ||
                                b.Entrada5 === 'FALTA' || b.Saida5 === 'FALTA'
                            );
                            
                            if (batidaComFalta) {
                                console.log(`🚨 FALTA detectada: ${batidaComFalta.NomeEmpregado} (${batidaComFalta.Data})`);
                            }
                            
                            // A API retorna um ARRAY direto, não um objeto {Sucesso, Dados}
                            if (Array.isArray(result) && result.length > 0) {
                                console.log(`✅ ${company.name}: ${result.length} registros`);
                                
                                // Debug removido para performance
                                // Adicionar informação da empresa em cada batida
                                result.forEach(batida => {
                                    batida._empresa = company.name;
                                    batida._empresaId = company.id;
                                });
                                allBatidas = allBatidas.concat(result);
                            } else {
                                console.warn(`⚠️ ${company.name}: Nenhum registro encontrado`);
                            }
                            
                            success = true;
                        } catch (fetchError) {
                            attempts++;
                            console.error(`❌ Erro na requisição para ${company.name}:`, fetchError);
                            if (attempts < 3) {
                                console.log(`🔄 Tentando novamente em 500ms... (tentativa ${attempts+1}/3)`);
                                await sleep(500);
                            } else {
                                console.error(`❌ Falha após 3 tentativas para ${company.name}`);
                            }
                        }
                    }
                }

                console.log(`📊 Total de ${allBatidas.length} registros de ${companies.length} empresa(s)`);

                if (allBatidas.length === 0) {
                    alert('Nenhum registro encontrado no período selecionado.');
                    return [];
                }

                // Buscar nomes dos funcionários
                await enrichWithEmployeeNames(allBatidas, companies);

                return parseSecullumData(allBatidas, dateStart);
            } catch (error) {
                console.error('❌ Erro ao buscar colaboradores:', error);
                alert(`Erro ao buscar dados da API:\n\n${error.message}`);
                return [];
            }
        }

        // Função para converter dados da Secullum para formato interno
        function parseSecullumData(batidas, dataRef) {
            // Agrupar batidas por funcionário + data
            const funcionariosMap = new Map();

            batidas.forEach(batida => {
                // Pegar informações do funcionário
                const reg = batida.Funcionario?.NumeroIdentificador || batida.Funcionario?.NumeroFolha || batida.FuncionarioId || 'N/A';
                const pis = batida.Funcionario?.NumeroPis || '';
                const dataFormatada = batida.Data || dataRef;
                const key = `${reg}_${dataFormatada}`;
                
                if (!funcionariosMap.has(key)) {
                    funcionariosMap.set(key, {
                        reg: reg,
                        pis: pis,
                        cpf: batida._funcionarioCpf || '',
                        name: batida._funcionarioNome || `Funcionário ${reg}`,
                        city: batida._empresa || 'N/A',
                        project: 'N/A',
                        projetoSecullum: batida._projetoSecullum || null, // ✅ PROJETO DA API SECULLUM
                        date: formatDateBR(dataFormatada),
                        day: getDayOfWeek(dataFormatada),
                        punches: {
                            ent1: '',
                            sai1: '',
                            ent2: '',
                            sai2: '',
                            ent3: '',
                            sai3: '',
                            ent4: '',
                            sai4: '',
                            ent5: '',
                            sai5: ''
                        },
                        motivo: batida.Observacoes || '',
                        attachments: [],
                        hasInconsistency: false,
                        empresa: batida._empresa || 'N/A',
                        empresaId: batida._empresaId || '',
                        rawData: batida
                    });
                }

                const func = funcionariosMap.get(key);
                
                // DEBUG: Log para investigar afastamentos
                if (batida.Entrada1 === 'A. INSS' || batida.Entrada1 === 'AFASTAMENTO INSS') {
                    console.log('🔍 AFASTAMENTO DETECTADO:', {
                        nome: batida._funcionarioNome,
                        reg: reg,
                        data: dataFormatada,
                        entrada1: batida.Entrada1,
                        saida1: batida.Saida1,
                        entrada2: batida.Entrada2,
                        saida2: batida.Saida2,
                        entrada3: batida.Entrada3,
                        saida3: batida.Saida3,
                        entrada4: batida.Entrada4,
                        saida4: batida.Saida4,
                        entrada5: batida.Entrada5,
                        saida5: batida.Saida5,
                        observacoes: batida.Observacoes,
                        dadosCompletos: batida
                    });
                }
                
                // Pegar horários das entradas/saídas
                // Função auxiliar para verificar se é horário válido (HH:MM)
                const isValidTime = (val) => {
                    if (!val) return false;
                    // Verifica se é formato de horário (ex: 08:00, 12:30)
                    return /^\d{1,2}:\d{2}$/.test(val);
                };
                
                // Lista de status especiais (motivos, não horários)
                const statusEspeciais = ['FALTA', 'FERIAS', 'A. INSS', 'AFASTAMENTO INSS', 'A.INSS', 'L.MATER', 'L. MATER', 'LIC.MATERNIDADE'];
                
                // Pegar horários OU deixar vazio se for status especial
                func.punches.ent1 = isValidTime(batida.Entrada1) ? batida.Entrada1 : '';
                func.punches.sai1 = isValidTime(batida.Saida1) ? batida.Saida1 : '';
                func.punches.ent2 = isValidTime(batida.Entrada2) ? batida.Entrada2 : '';
                func.punches.sai2 = isValidTime(batida.Saida2) ? batida.Saida2 : '';
                func.punches.ent3 = isValidTime(batida.Entrada3) ? batida.Entrada3 : '';
                func.punches.sai3 = isValidTime(batida.Saida3) ? batida.Saida3 : '';
                func.punches.ent4 = isValidTime(batida.Entrada4) ? batida.Entrada4 : '';
                func.punches.sai4 = isValidTime(batida.Saida4) ? batida.Saida4 : '';
                func.punches.ent5 = isValidTime(batida.Entrada5) ? batida.Entrada5 : '';
                func.punches.sai5 = isValidTime(batida.Saida5) ? batida.Saida5 : '';
                
                // Detectar motivos especiais em qualquer entrada
                const todasEntradas = [
                    batida.Entrada1, batida.Saida1, batida.Entrada2, batida.Saida2,
                    batida.Entrada3, batida.Saida3, batida.Entrada4, batida.Saida4,
                    batida.Entrada5, batida.Saida5
                ];
                
                // Procurar por status especial
                for (const entrada of todasEntradas) {
                    if (entrada && statusEspeciais.includes(entrada)) {
                        if (entrada === 'FALTA') {
                            func.motivo = 'FALTA';
                        } else if (entrada === 'FERIAS') {
                            func.motivo = 'FÉRIAS';
                        } else if (entrada === 'A. INSS' || entrada === 'AFASTAMENTO INSS' || entrada === 'A.INSS') {
                            func.motivo = 'AFASTAMENTO INSS';
                        } else if (entrada === 'L.MATER' || entrada === 'L. MATER' || entrada === 'LIC.MATERNIDADE') {
                            func.motivo = 'LICENÇA MATERNIDADE';
                        }
                        break; // Já encontrou o motivo, não precisa continuar
                    }
                }

                // Verificar inconsistências
                // PADRÃO: Exatamente 4 batidas (2 entradas + 2 saídas)
                const batidas = [
                    func.punches.ent1, func.punches.sai1,
                    func.punches.ent2, func.punches.sai2,
                    func.punches.ent3, func.punches.sai3,
                    func.punches.ent4, func.punches.sai4,
                    func.punches.ent5, func.punches.sai5
                ].filter(h => h && h !== '--:--');
                
                const totalBatidas = batidas.length;
                
                // Se tem motivo especial (férias, afastamento, falta justificada, etc), NÃO é inconsistência
                const motivosEspeciais = ['FALTA', 'FÉRIAS', 'AFASTAMENTO INSS', 'LICENÇA MATERNIDADE'];
                const temMotivoEspecial = motivosEspeciais.includes(func.motivo);
                
                // Função para converter HH:MM em minutos
                const timeToMinutes = (time) => {
                    if (!time) return 0;
                    const [h, m] = time.split(':').map(Number);
                    return h * 60 + m;
                };
                
                // VALIDAR ORDEM DOS HORÁRIOS
                let ordemIncorreta = false;
                const horariosOrdenados = [
                    { nome: 'Entrada 1', hora: func.punches.ent1 },
                    { nome: 'Saída 1', hora: func.punches.sai1 },
                    { nome: 'Entrada 2', hora: func.punches.ent2 },
                    { nome: 'Saída 2', hora: func.punches.sai2 },
                    { nome: 'Entrada 3', hora: func.punches.ent3 },
                    { nome: 'Saída 3', hora: func.punches.sai3 },
                    { nome: 'Entrada 4', hora: func.punches.ent4 },
                    { nome: 'Saída 4', hora: func.punches.sai4 },
                    { nome: 'Entrada 5', hora: func.punches.ent5 },
                    { nome: 'Saída 5', hora: func.punches.sai5 }
                ].filter(h => h.hora && h.hora !== '--:--');
                
                for (let i = 1; i < horariosOrdenados.length; i++) {
                    const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                    const atual = timeToMinutes(horariosOrdenados[i].hora);
                    
                    if (atual <= anterior) {
                        ordemIncorreta = true;
                        console.log(`⚠️ Ordem incorreta: ${func.name} - ${horariosOrdenados[i - 1].nome} (${horariosOrdenados[i - 1].hora}) >= ${horariosOrdenados[i].nome} (${horariosOrdenados[i].hora})`);
                        break;
                    }
                }
                
                // Marca inconsistência se:
                // 1. NÃO tem exatamente 4 batidas (menos OU mais que 4)
                // 2. OU horários em ordem incorreta
                // 3. E NÃO tem motivo especial
                const batidaIncorreta = totalBatidas !== 4 || ordemIncorreta;
                
                if (batidaIncorreta && !temMotivoEspecial) {
                    func.hasInconsistency = true;
                }
            });

            return Array.from(funcionariosMap.values());
        }

        // Funções auxiliares
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('pt-BR');
        }

        function getDayOfWeek(dateString) {
            const days = ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado'];
            
            let date;
            
            // Formato estranho: 27T00:00:00/10/2025
            const strangeMatch = dateString.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
            if (strangeMatch) {
                const [_, dia, mes, ano] = strangeMatch;
                date = new Date(ano, parseInt(mes) - 1, parseInt(dia));
            }
            // Se está no formato dd/mm/yyyy
            else if (dateString.includes('/') && !dateString.includes('T')) {
                const parts = dateString.split('/');
                date = new Date(parts[2], parts[1] - 1, parts[0]);
            } 
            // Se está no formato ISO (YYYY-MM-DD)
            else if (dateString.includes('-')) {
                date = new Date(dateString.split('T')[0] + 'T00:00:00');
            } 
            // Outro formato
            else {
                date = new Date(dateString);
            }
            
            return days[date.getDay()];
        }

        function formatDateBR(dateString) {
            if (!dateString) return '';
            
            // Formato estranho: 27T00:00:00/10/2025 ou similar
            // Precisamos extrair: dia, mês, ano
            
            // Tentar extrair padrão: DDT00:00:00/MM/YYYY
            const strangeMatch = dateString.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
            if (strangeMatch) {
                const [_, dia, mes, ano] = strangeMatch;
                return `${dia.padStart(2, '0')}/${mes.padStart(2, '0')}/${ano}`;
            }
            
            // Se já está em formato brasileiro (DD/MM/YYYY)
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
                const parts = dateString.split('/');
                return `${parts[0].padStart(2, '0')}/${parts[1].padStart(2, '0')}/${parts[2]}`;
            }
            
            // Se está em formato ISO (YYYY-MM-DD)
            if (/^\d{4}-\d{1,2}-\d{1,2}/.test(dateString)) {
                const [year, month, day] = dateString.split('-').map(p => p.split('T')[0]);
                return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
            }
            
            // Retornar original se não conseguir formatar
            return dateString;
        }

        // ==========================================
        // DADOS REAIS DA API
        // ==========================================
        let allEmployees = [];

        let showOnlyInconsistencies = false;
        let selectedEmployees = [];
        let useDigitalSignature = false;
        let isAPIConnected = false;
        
        // 🔴 CORREÇÃO: Flags de controle para evitar race conditions
        let renderingTable = false;
        let loadingAnexos = false;

        // 🔴 CORREÇÃO: Event delegation - executar apenas UMA VEZ
        (function initEventListeners() {
            const tableBody = document.getElementById('employeeTable');
            
            // Checkboxes
            tableBody.addEventListener('change', (e) => {
                if (!e.target.classList.contains('employee-checkbox')) return;
                handleCheckboxChange(e);
            });
            
            // Edição inline (duplo clique)
            tableBody.addEventListener('dblclick', (e) => {
                const cell = e.target.closest('td[data-punch]');
                if (cell && !cell.classList.contains('editing')) {
                    startInlineEdit(cell);
                }
            });
            
            console.log('✅ Event listeners inicializados (event delegation)');
        })();

        function handleCheckboxChange(e) {
            e.stopPropagation();
            const uniqueId = e.target.dataset.id;
            
            if (e.target.checked) {
                if (!selectedEmployees.includes(uniqueId)) {
                    selectedEmployees.push(uniqueId);
                }
            } else {
                selectedEmployees = selectedEmployees.filter(id => id !== uniqueId);
            }
            
            const row = e.target.closest('tr');
            if (row) row.classList.toggle('selected', e.target.checked);
        }

        // Conectar à API (apenas autenticação)
        async function connectToAPI() {
            const apiStatus = document.getElementById('apiStatus');
            
            apiStatus.innerHTML = '⏳ Autenticando...';
            
            const authenticated = await authenticateAPI();
            
            if (authenticated) {
                isAPIConnected = true;
                
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; display: inline-block;"></span> API Conectada';
                
                console.log(`✅ API conectada com ${API_CONFIG.companies.length} empresa(s)`);
                
                return true;
            } else {
                apiStatus.className = 'api-status disconnected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span> Erro na conexão';
                return false;
            }
        }

        // Buscar dados do período
        async function searchPeriod() {
            const dateStart = document.getElementById('dateStart').value;
            const dateEnd = document.getElementById('dateEnd').value;
            const apiStatus = document.getElementById('apiStatus');
            
            if (!dateStart || !dateEnd) {
                showAlert('Atenção', 'Por favor, selecione as datas de início e fim!', 'warning');
                return;
            }
            
            // Calcular dias do período
            const start = new Date(dateStart);
            const end = new Date(dateEnd);
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            // Avisar se o período for muito longo
            if (diffDays > 365) {
                showAlert(
                    'Período Muito Longo!',
                    `Você está buscando ${diffDays} dias de dados!\n\nIsso pode:\n• Demorar muito tempo (vários minutos)\n• Sobrecarregar a API\n• Causar erros de timeout\n\n💡 Sugestão: Busque períodos menores (1 mês por vez)`,
                    'warning'
                );
                return;
            } else if (diffDays > 90) {
                console.warn(`⚠️ Período longo: ${diffDays} dias. Pode demorar...`);
            }
            
            showLoading(`Buscando ${diffDays} dias de dados...`);
            apiStatus.innerHTML = `⏳ Buscando ${diffDays} dias de dados...`;
            const startTime = performance.now();
            
            const apiData = await fetchEmployeesFromAPI(dateStart, dateEnd);
            
            const endTime = performance.now();
            const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
            
            if (apiData && apiData.length > 0) {
                allEmployees.length = 0;
                allEmployees.push(...apiData);
                
                // Ordenar alfabeticamente ao carregar
                allEmployees.sort((a, b) => a.name.localeCompare(b.name));
                
                // FAZER MATCH COM SQL AZURE (buscar LÍDER e PROJETO)
                const cpfs = [...new Set(allEmployees.map(emp => emp.cpf).filter(cpf => cpf))];
                const sqlData = await getColaboradoresBatchCPF(cpfs);
                
                // Fazer match por CPF
                allEmployees.forEach(emp => {
                    if (emp.cpf) {
                        const cpfLimpo = emp.cpf.replace(/[^\d]/g, '');
                        const sqlColab = sqlColaboradoresCache[cpfLimpo];
                        if (sqlColab) {
                            emp.nomeLider = sqlColab.NOME_LIDER || sqlColab.Lider || null;
                            emp.projeto = sqlColab.PROJETO || sqlColab.Projeto || null;
                        } else {
                            emp.nomeLider = null;
                            emp.projeto = null;
                        }
                    }
                });
                
                // CARREGAR ANEXOS E IDS EM PARALELO
                await carregarAnexos().catch(err => console.error('❌ Erro ao carregar anexos:', err));
                await carregarIDs().catch(err => console.error('❌ Erro ao carregar IDs:', err));
                
                hideLoading();
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = `🟢 ${apiData.length} registros (${timeElapsed}s)`;
                
                renderTable();
                
                showAlert(
                    'Dados Carregados!',
                    `${apiData.length} registros carregados em ${timeElapsed}s`,
                    'success'
                );
            } else {
                hideLoading();
                showAlert('Sem Dados', 'Nenhum registro encontrado neste período!', 'warning');
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #f59e0b; border-radius: 50%; display: inline-block;"></span> API Conectada';
            }
        }
        
        // 🔴 CARREGAR ANEXOS DIRETO DO AZURE SQL (TABELA ANEXOS)
        async function carregarAnexos() {
            loadingAnexos = true;
            
            try {
                const dataInicio = document.getElementById('dateStart').value;
                const dataFim = document.getElementById('dateEnd').value;
                
                // Buscar empresas selecionadas corretamente
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                const empresasSelecionadas = companies.map(c => c.id);
                
                for (let empresaId of empresasSelecionadas) {
                    // Buscar anexos de cada dia do período
                    const inicio = new Date(dataInicio);
                    const fim = new Date(dataFim);
                    
                    for (let d = new Date(inicio); d <= fim; d.setDate(d.getDate() + 1)) {
                        const dataStr = d.toISOString().split('T')[0];
                        
                        try {
                            const response = await fetch(`${API_BASE_URL}/api/anexos/${dataStr}/${empresaId}`);
                            
                            if (!response.ok) {
                                continue; // Nenhum anexo nesta data
                            }
                            
                            const anexos = await response.json();
                            
                            if (Array.isArray(anexos) && anexos.length > 0) {
                                
                                
                                // ✅ FAZER MATCH COM FUNCIONÁRIOS USANDO CPF + DATA (identificador único)
                                anexos.forEach(anexo => {
                                    
                                    
                                    // Normalizar data do anexo (pode vir como 2025-10-24T00:00:00.000Z ou 2025-10-24)
                                    const dataAnexo = anexo.data.split('T')[0];
                                    
                                    // ✅ BUSCAR FUNCIONÁRIO POR CPF + DATA (exato, não parcial!)
                                    const emp = allEmployees.find(e => {
                                        // Match CPF exato (remover pontos e traços para comparar apenas números)
                                        const cpfEmp = String(e.cpf || '').replace(/[.\-]/g, '').trim();
                                        const cpfAnexo = String(anexo.cpf || '').replace(/[.\-]/g, '').trim();
                                        
                                        if (cpfEmp !== cpfAnexo || !cpfEmp) return false;
                                        
                                        // Normalizar data do funcionário
                                        let dataEmp = '';
                                        if (e.rawData?.Data) {
                                            // Tentar formato estranho da API: 27T00:00:00/10/2025 -> 2025-10-27
                                            const partsStrange = e.rawData.Data.match(/(\d+)T\d{2}:\d{2}:\d{2}\/(\d+)\/(\d{4})/);
                                            if (partsStrange) {
                                                const dia = partsStrange[1].padStart(2, '0');
                                                const mes = partsStrange[2].padStart(2, '0');
                                                const ano = partsStrange[3];
                                                dataEmp = `${ano}-${mes}-${dia}`;
                                            } else {
                                                // Formato ISO normal: 2025-10-24T00:00:00
                                                dataEmp = e.rawData.Data.split('T')[0];
                                            }
                                        } else if (e.date) {
                                            dataEmp = e.date.split('T')[0];
                                        }
                                        
                                        // Match DATA exata
                                        const match = dataEmp === dataAnexo;
                                        
                                        if (match) {
                                            
                                        }
                                        
                                        return match;
                                    });
                                    
                                    if (emp) {
                                        emp.anexoId = anexo.id; // 🆔 ID da tabela ANEXOS
                                        emp.anexoUrl = anexo.blob_url;
                                        emp.anexoDate = dataAnexo; // 🔑 Guardar data do anexo
                                        emp.motivo = anexo.motivo_detectado || emp.motivo;
                                        emp.attachments = [anexo.blob_filename];
                                        
                                        
                                        
                                        // 📋 CARREGAR PERGUNTAS E APROVAÇÕES DO RH DO BANCO DE DADOS
                                        if (anexo.perguntas_rh && anexo.perguntas_rh !== '{}') {
                                            try {
                                                const allData = JSON.parse(anexo.perguntas_rh);
                                                
                                                // Separar perguntas de aprovações
                                                emp.questions = {};
                                                emp.approved = {};
                                                
                                                for (const [key, value] of Object.entries(allData)) {
                                                    if (key.endsWith('_approved')) {
                                                        // É uma aprovação (ex: "ent1_approved")
                                                        const punchType = key.replace('_approved', '');
                                                        emp.approved[punchType] = value;
                                                    } else {
                                                        // É uma pergunta normal
                                                        emp.questions[key] = value;
                                                    }
                                                }
                                                
                                                const numPerguntas = Object.keys(emp.questions).length;
                                                const numAprovacoes = Object.keys(emp.approved).length;
                                                
                                                if (numPerguntas > 0) {
                                                    
                                                }
                                                if (numAprovacoes > 0) {
                                                    
                                                }
                                            } catch (err) {
                                                console.warn(`⚠️ Erro ao parsear perguntas_rh para ${emp.name}:`, err);
                                                emp.questions = {};
                                                emp.approved = {};
                                            }
                                        } else {
                                            emp.questions = {};
                                            emp.approved = {};
                                        }
                                        
                                        // ❌ NÃO PREENCHER BATIDAS DO SQL!
                                        // A tabela deve mostrar APENAS dados da Secullum
                                        // Os horários salvos no anexo são apenas backup/histórico
                                        
                                        
                                    } else {
                                        console.warn(`⚠️ Anexo não vinculado: REG ${anexo.reg} - ${dataAnexo} (funcionário não encontrado)`);
                                    }
                                });
                            }
                        } catch (err) {
                            console.warn(`⚠️ Erro ao buscar anexos de ${dataStr}:`, err.message);
                        }
                    }
                }
                
                console.log('✅ Carregamento de anexos concluído!');
                
            } catch (err) {
                console.error('❌ Erro ao carregar anexos:', err);
            } finally {
                loadingAnexos = false;
            }
        }

        // Carregar perguntas e aprovações de TODOS os funcionários (mesmo sem anexo)
        async function carregarPerguntasEAprovacoes() {
            try {
                const dataInicio = document.getElementById('dateStart').value;
                const dataFim = document.getElementById('dateEnd').value;
                
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                const empresasSelecionadas = companies.map(c => c.id);
                
                // ✅ ADICIONAR empresa_id = 0 (registros sem empresa específica)
                if (!empresasSelecionadas.includes('0')) {
                    empresasSelecionadas.push('0');
                }
                
                console.log('🏢 Empresas a consultar (incluindo 0):', empresasSelecionadas);
                
                for (let empresaId of empresasSelecionadas) {
                    const inicio = new Date(dataInicio);
                    const fim = new Date(dataFim);
                    
                    for (let d = new Date(inicio); d <= fim; d.setDate(d.getDate() + 1)) {
                        const dataStr = d.toISOString().split('T')[0];
                        
                        try {
                            const response = await fetch(`${API_BASE_URL}/api/anexos/${dataStr}/${empresaId}`, {
                                headers: getAuthHeaders()
                            });
                            
                            if (!response.ok) continue;
                            
                            const anexos = await response.json();
                            
                            if (Array.isArray(anexos) && anexos.length > 0) {
                                
                                anexos.forEach(anexo => {
                                    if (!anexo.perguntas_rh) return;
                                    
                                    // ✅ IGNORAR se perguntas_rh for "{}" vazio
                                    if (anexo.perguntas_rh === '{}') return;
                                    
                                    // ✅ MATCH APENAS POR CPF + DATA (não filtrar por empresa)
                                    // Comentários são do CPF, não da empresa!
                                    
                                    // Buscar funcionário por CPF e DATA
                                    const cpfAnexo = (anexo.cpf || '').replace(/\D/g, '');
                                    const dataAnexo = dataStr;
                                    
                                    // DEBUG: Log de busca
                                    if (anexo.perguntas_rh && anexo.perguntas_rh !== '{}') {
                                    
                                        
                                    }
                                    
                                    const emp = allEmployees.find(e => {
                                        const cpfEmp = (e.cpf || '').replace(/\D/g, '');
                                        if (cpfEmp !== cpfAnexo || !cpfEmp) return false;
                                        
                                        let dataEmp = null;
                                        if (e.rawData?.Data) {
                                            const partsStrange = e.rawData.Data.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
                                            if (partsStrange) {
                                                const dia = partsStrange[1].padStart(2, '0');
                                                const mes = partsStrange[2].padStart(2, '0');
                                                const ano = partsStrange[3];
                                                dataEmp = `${ano}-${mes}-${dia}`;
                                            } else {
                                                dataEmp = e.rawData.Data.split('T')[0];
                                            }
                                        } else if (e.date) {
                                            // Converter formato brasileiro DD/MM/YYYY para ISO YYYY-MM-DD
                                            const partsBR = e.date.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
                                            if (partsBR) {
                                                dataEmp = `${partsBR[3]}-${partsBR[2]}-${partsBR[1]}`;
                                            } else {
                                                dataEmp = e.date.split('T')[0];
                                            }
                                        }
                                        
                                        return dataEmp === dataAnexo;
                                    });
                                    
                                    if (emp) {
                                        try {
                                            const allData = JSON.parse(anexo.perguntas_rh);
                                            
                                            emp.questions = emp.questions || {};
                                            emp.approved = emp.approved || {};
                                            
                                            for (const [key, value] of Object.entries(allData)) {
                                                if (key.endsWith('_approved')) {
                                                    const punchType = key.replace('_approved', '');
                                                    emp.approved[punchType] = value;
                                                } else {
                                                    emp.questions[key] = value;
                                                }
                                            }
                                            
                                        } catch (err) {
                                            console.warn(`⚠️ Erro ao parsear perguntas_rh:`, err);
                                        }
                                    } else {
                                        // DEBUG: Funcionário não encontrado
                                        console.warn(`⚠️ Anexo não vinculado: CPF=${cpfAnexo}, Data=${dataAnexo}, Perguntas:`, anexo.perguntas_rh);
                                    }
                                });
                            }
                        } catch (err) {
                            // Silenciar erros de dias sem dados
                        }
                    }
                }
                
                console.log('✅ Perguntas e aprovações carregadas!');
            } catch (err) {
                console.error('❌ Erro ao carregar perguntas/aprovações:', err);
            }
        }

        // 🆔 Carregar IDs de impressão (alias para carregarIdsImpressao)
        async function carregarIDs() {
            return await carregarIdsImpressao();
        }
        
        // 🆔 Carregar IDs de impressão de TODOS os funcionários
        async function carregarIdsImpressao() {
            try {
                console.log('🆔 Carregando IDs do banco de dados...');
                
                // Montar array com todos os registros (REG + DATA + EMPRESA_ID)
                const registros = allEmployees.map(emp => ({
                    reg: emp.reg,
                    data: emp.date,
                    empresa_id: emp.empresaId || emp.companyId || 0
                }));
                
                if (registros.length === 0) return;
                
                const response = await fetch(`${API_BASE_URL}/api/justificativa/buscar-ids`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ registros })
                });
                
                if (!response.ok) {
                    console.warn('⚠️ Erro ao buscar IDs do banco');
                    return;
                }
                
                const { ids } = await response.json();
                
                // Atribuir IDs aos funcionários
                allEmployees.forEach(emp => {
                    // Normalizar data
                    let dataNormalizada = emp.date;
                    if (emp.date.includes('/')) {
                        const [dia, mes, ano] = emp.date.split('/');
                        dataNormalizada = `${ano}-${mes}-${dia}`;
                    } else if (emp.date.includes('T')) {
                        dataNormalizada = emp.date.split('T')[0];
                    }
                    
                    const empresaId = emp.empresaId || emp.companyId || 0;
                    const key = `${emp.reg}_${dataNormalizada}_${empresaId}`;
                    if (ids[key]) {
                        emp.id = ids[key];
                    }
                });
                
                console.log(`✅ IDs carregados! ${Object.keys(ids).length} encontrado(s)`);
                
            } catch (err) {
                console.error('❌ Erro ao carregar IDs do banco:', err);
            }
        }

        // Desconectar da API
        function disconnectFromAPI() {
            allEmployees.length = 0;
            isAPIConnected = false;
            
            const apiStatus = document.getElementById('apiStatus');
            
            apiStatus.className = 'api-status disconnected';
            apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span> API Desconectada';
            
            renderTable();
        }

        // Configurar credenciais
        function configureAPI() {
            const currentBaseURL = API_CONFIG.baseURL || '';
            
            const message = '🔧 CONFIGURAÇÃO DA URL BASE DA API\n\n' +
                '📋 Digite a URL base do SmartPoint:\n\n' +
                '💡 Exemplos comuns:\n' +
                '1️⃣  https://api.secullum.com.br/SmartPoint\n' +
                '2️⃣  https://prd.secullum.com.br/SmartPoint\n' +
                '3️⃣  https://sistema.secullum.com.br/SmartPoint\n' +
                '4️⃣  https://app.secullum.com.br/SmartPoint\n' +
                '5️⃣  https://cliente.secullum.com.br/SmartPoint\n\n' +
                `📍 URL Atual: ${currentBaseURL || '(não configurada)'}\n\n` +
                '⚠️ IMPORTANTE: NÃO inclua "/IntegracaoExterna"\n' +
                '⚠️ Entre em contato com o suporte Secullum se não souber a URL';
            
            const newBaseURL = prompt(message, currentBaseURL || 'https://');
            
            if (newBaseURL && newBaseURL.trim() && newBaseURL !== 'https://') {
                API_CONFIG.baseURL = newBaseURL.trim().replace(/\/$/, ''); // Remove barra final
                alert(`✅ URL Base configurada com sucesso!\n\n📍 ${API_CONFIG.baseURL}\n\n🔌 Agora clique em "Conectar API Secullum" para testar.`);
            } else if (newBaseURL === '' || newBaseURL === 'https://') {
                alert('❌ Por favor, digite uma URL válida!\n\n💡 Dica: Entre em contato com o suporte da Secullum para obter a URL correta da sua instalação.');
            }
        }

        // ==========================================
        // FUNÇÕES DE SELEÇÃO DE EMPRESA
        // ==========================================
        function selectCompany(companyId, button) {
            if (companyId === 'all') {
                API_CONFIG.selectedCompanies = ['all'];
                document.querySelectorAll('.btn-company').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            } else {
                // Remove 'all' se existir
                if (API_CONFIG.selectedCompanies.includes('all')) {
                    API_CONFIG.selectedCompanies = [];
                    document.querySelector('.btn-company[data-company="all"]').classList.remove('active');
                }

                // Toggle empresa específica
                const index = API_CONFIG.selectedCompanies.indexOf(companyId);
                if (index > -1) {
                    API_CONFIG.selectedCompanies.splice(index, 1);
                    button.classList.remove('active');
                } else {
                    API_CONFIG.selectedCompanies.push(companyId);
                    button.classList.add('active');
                }

                // Se nenhuma empresa selecionada, volta para 'all'
                if (API_CONFIG.selectedCompanies.length === 0) {
                    API_CONFIG.selectedCompanies = ['all'];
                    document.querySelector('.btn-company[data-company="all"]').classList.add('active');
                }
            }

            
        }

        function initCompanyButtons() {
            const container = document.getElementById('companyButtons');
            
            // Limpar botões existentes (exceto o botão "TODAS")
            const allButton = container.querySelector('[data-company="all"]');
            container.innerHTML = '';
            if (allButton) {
                container.appendChild(allButton);
            }
            
            // Adicionar botões das empresas
            API_CONFIG.companies.forEach(company => {
                const btn = document.createElement('button');
                btn.className = 'btn-company';
                btn.setAttribute('data-company', company.id);
                btn.onclick = () => selectCompany(company.id, btn);
                btn.innerHTML = `🏢 ${company.name}`;
                btn.style.borderColor = company.color;
                btn.style.color = company.color;
                container.appendChild(btn);
            });
        }

        // Recarregar dados com as empresas selecionadas
        async function reloadData() {
            const dateStart = document.getElementById('dateStart').value;
            const dateEnd = document.getElementById('dateEnd').value;
            
            if (!dateStart || !dateEnd) {
                alert('⚠️ Por favor, selecione as datas de início e fim!');
                return;
            }
            
            document.getElementById('apiStatus').innerHTML = '⏳ Carregando...';
            const startTime = performance.now();
            
            const apiData = await fetchEmployeesFromAPI(dateStart, dateEnd);
            
            const endTime = performance.now();
            const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
            
            if (apiData && apiData.length > 0) {
                allEmployees.length = 0;
                allEmployees.push(...apiData);
                
                // Ordenar alfabeticamente ao carregar
                allEmployees.sort((a, b) => a.name.localeCompare(b.name));
                
                // FAZER MATCH COM SQL AZURE (buscar LÍDER e PROJETO)
                console.log('🔄 Buscando dados complementares do SQL Azure...');
                const cpfs = [...new Set(allEmployees.map(emp => emp.cpf).filter(cpf => cpf))];
                const sqlData = await getColaboradoresBatchCPF(cpfs);
                
                // Fazer match por CPF
                allEmployees.forEach(emp => {
                    if (emp.cpf) {
                        const cpfLimpo = emp.cpf.replace(/[^\d]/g, '');
                        const sqlColab = sqlColaboradoresCache[cpfLimpo];
                        if (sqlColab) {
                            emp.nomeLider = sqlColab.NOME_LIDER || sqlColab.Lider || null;
                            emp.projeto = sqlColab.PROJETO || sqlColab.Projeto || null;
                        } else {
                            emp.nomeLider = null;
                            emp.projeto = null;
                        }
                    }
                });
                
                // 🔥 CARREGAR ANEXOS E PERGUNTAS
                try {
                    await carregarAnexos();
                } catch (err) {
                    console.error('❌ Erro ao carregar anexos:', err);
                }
                
                // 🆔 CARREGAR IDs DE IMPRESSÃO
                try {
                    await carregarIdsImpressao();
                } catch (err) {
                    console.error('❌ Erro ao carregar IDs de impressão:', err);
                }
                
                renderTable();
                alert(`✅ ${apiData.length} registros carregados!\n⏱️ Tempo de busca: ${timeElapsed}s`);
            } else {
                alert('⚠️ Nenhum registro encontrado neste período!');
            }
            
            document.getElementById('apiStatus').innerHTML = `<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; display: inline-block;"></span> API Conectada (${timeElapsed}s)`;
        }

        // ==========================================
        // RENDERIZAÇÃO DA TABELA
        // ==========================================
        // Renderizar tabela
        function renderTable() {
            // 🔴 CORREÇÃO: Evitar renderizações simultâneas
            if (renderingTable) {
                console.warn('⏳ Já está renderizando, ignorando chamada duplicada');
                return;
            }
            renderingTable = true;
            
            try {
                const tbody = document.getElementById('employeeTable');
                const searchName = document.getElementById('searchName')?.value.toLowerCase().trim() || '';
                const searchLider = document.getElementById('searchLider')?.value.toLowerCase().trim() || '';
                const searchProject = document.getElementById('searchProject')?.value.trim() || '';
                
                // Filtrar por inconsistências
                let displayedEmployees = showOnlyInconsistencies 
                    ? allEmployees.filter(emp => emp.hasInconsistency)
                    : allEmployees;
                
                // Filtrar por nome (se houver busca)
                if (searchName) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.name.toLowerCase().includes(searchName)
                    );
                }
                
                // Filtrar por líder (se houver busca)
                if (searchLider) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.nomeLider && emp.nomeLider.toLowerCase().includes(searchLider)
                    );
                }
                
                // Filtrar por projeto (se houver busca)
                if (searchProject) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.projeto && String(emp.projeto).includes(searchProject)
                    );
                }
                
                // ORDENAR ALFABETICAMENTE POR NOME
                displayedEmployees.sort((a, b) => a.name.localeCompare(b.name));

            tbody.innerHTML = displayedEmployees.map((emp, index) => {
                // ✅ COMPARAR PROJETOS: Extrair 3 primeiros números
                const extrairNumeros = (str) => {
                    if (!str) return '';
                    const numeros = String(str).match(/\d+/);
                    if (numeros && numeros[0]) {
                        return numeros[0].substring(0, 3);
                    }
                    return '';
                };
                
                const projetoBDO = extrairNumeros(emp.projeto);
                const projetoSEC = extrairNumeros(emp.projetoSecullum);
                
                // Se ambos existem e são diferentes, destacar em amarelo
                const projetoDiferente = projetoBDO && projetoSEC && projetoBDO !== projetoSEC;
                const corDestaque = projetoDiferente ? 'background: #fef3c7; font-weight: 700;' : '';
                
                // VALIDAR ORDEM CRONOLÓGICA PARA DESTACAR CÉLULAS ERRADAS
                const timeToMinutes = (time) => {
                    if (!time || time === '--:--') return -1;
                    const [h, m] = time.split(':').map(Number);
                    return h * 60 + m;
                };
                
                const horariosOrdenados = [
                    { col: 'ent1', hora: emp.punches.ent1 },
                    { col: 'sai1', hora: emp.punches.sai1 },
                    { col: 'ent2', hora: emp.punches.ent2 },
                    { col: 'sai2', hora: emp.punches.sai2 },
                    { col: 'ent3', hora: emp.punches.ent3 },
                    { col: 'sai3', hora: emp.punches.sai3 },
                    { col: 'ent4', hora: emp.punches.ent4 },
                    { col: 'sai4', hora: emp.punches.sai4 },
                    { col: 'ent5', hora: emp.punches.ent5 },
                    { col: 'sai5', hora: emp.punches.sai5 }
                ].filter(h => h.hora && h.hora !== '--:--');
                
                // Marcar quais colunas estão fora de ordem
                const colunasErradas = new Set();
                
                for (let i = 1; i < horariosOrdenados.length; i++) {
                    const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                    const atual = timeToMinutes(horariosOrdenados[i].hora);
                    
                    if (atual <= anterior) {
                        colunasErradas.add(horariosOrdenados[i].col);
                        colunasErradas.add(horariosOrdenados[i - 1].col);
                    }
                }
                
                // Função para retornar classe correta
                const getTimeClass = (punchType, value) => {
                    if (colunasErradas.has(punchType)) {
                        return 'error-time'; // VERMELHO ESCURO
                    } else if (value) {
                        return 'present'; // VERDE
                    } else if (punchType === 'ent1' || punchType === 'sai1' || punchType === 'ent2' || punchType === 'sai2') {
                        return 'missing'; // VERMELHO CLARO (obrigatório)
                    } else {
                        return 'optional'; // CINZA (opcional)
                    }
                };
                
                // ✅ ID ÚNICO: REG + DATA (para selecionar dia específico, não todos os dias do colaborador)
                const uniqueId = `${emp.reg}_${emp.date}`;
                
                return `
                <tr class="${emp.hasInconsistency ? 'inconsistency' : ''} ${selectedEmployees.includes(uniqueId) ? 'selected' : ''}">
                    <td style="width: 40px;">
                        <input type="checkbox" 
                               class="employee-checkbox" 
                               data-reg="${emp.reg}"
                               data-date="${emp.date}"
                               data-id="${uniqueId}"
                               ${selectedEmployees.includes(uniqueId) ? 'checked' : ''}
                               style="width: 18px; height: 18px; cursor: pointer;">
                    </td>
                    <td class="center" style="font-weight: bold; color: #6b7280; width: 50px;">
                        ${emp.id ? `#${emp.id}` : '-'}
                    </td>
                    <td style="font-family: 'Courier New', monospace; font-weight: 600; font-size: 12px; width: 80px;">${emp.reg}</td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 150px; max-width: 180px; color: #7c3aed;">${emp.nomeLider || '-'}</td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 100px; max-width: 120px; color: #000; ${corDestaque}">${emp.projeto || '-'}</td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 120px; max-width: 140px; color: #000; ${corDestaque}">${emp.projetoSecullum || '-'}</td>
                    <td style="font-weight: 600; font-size: 12px; min-width: 180px; max-width: 220px;">${emp.name}</td>
                    <td style="font-family: 'Courier New', monospace; font-size: 12px; width: 140px;">${emp.cpf ? emp.cpf.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4') : 'N/A'}</td>
                    <td style="font-weight: 600; font-size: 12px; min-width: 140px;">${emp.city}</td>
                    <td class="center" style="font-size: 12px; width: 100px;">${emp.date}</td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" 
                        data-reg="${emp.reg}" 
                        data-date="${emp.date}" 
                        data-punch="ent1"
                        data-name="${emp.name}"
                        onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('ent1') && !emp.approved?.ent1 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent1\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.ent1 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent1\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.ent1 ? 'approved' : getTimeClass('ent1', emp.punches.ent1)}" style="font-size: 13px; font-family: 'Courier New', monospace;">
                            ${emp.punches.ent1 || '--:--'}
                        </span>
                        ${emp.questions?.ent1 ? '<span class="has-question" title="' + emp.questions.ent1 + '">💬</span>' : ''}
                        ${emp.approved?.ent1 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent1 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai1" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('sai1') && !emp.approved?.sai1 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai1\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.sai1 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai1\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.sai1 ? 'approved' : getTimeClass('sai1', emp.punches.sai1)}">${emp.punches.sai1 || '--:--'}</span>
                        ${emp.questions?.sai1 ? '<span class="has-question" title="' + emp.questions.sai1 + '">💬</span>' : ''}
                        ${emp.approved?.sai1 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai1 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent2" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('ent2') && !emp.approved?.ent2 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent2\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.ent2 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent2\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.ent2 ? 'approved' : getTimeClass('ent2', emp.punches.ent2)}">${emp.punches.ent2 || '--:--'}</span>
                        ${emp.questions?.ent2 ? '<span class="has-question" title="' + emp.questions.ent2 + '">💬</span>' : ''}
                        ${emp.approved?.ent2 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent2 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai2" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('sai2') && !emp.approved?.sai2 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai2\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.sai2 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai2\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.sai2 ? 'approved' : getTimeClass('sai2', emp.punches.sai2)}">${emp.punches.sai2 || '--:--'}</span>
                        ${emp.questions?.sai2 ? '<span class="has-question" title="' + emp.questions.sai2 + '">💬</span>' : ''}
                        ${emp.approved?.sai2 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai2 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent3" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('ent3') && !emp.approved?.ent3 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent3\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.ent3 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent3\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.ent3 ? 'approved' : getTimeClass('ent3', emp.punches.ent3)}">${emp.punches.ent3 || '--:--'}</span>
                        ${emp.questions?.ent3 ? '<span class="has-question" title="' + emp.questions.ent3 + '">💬</span>' : ''}
                        ${emp.approved?.ent3 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent3 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai3" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('sai3') && !emp.approved?.sai3 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai3\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.sai3 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai3\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.sai3 ? 'approved' : getTimeClass('sai3', emp.punches.sai3)}">${emp.punches.sai3 || '--:--'}</span>
                        ${emp.questions?.sai3 ? '<span class="has-question" title="' + emp.questions.sai3 + '">💬</span>' : ''}
                        ${emp.approved?.sai3 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai3 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent4" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('ent4') && !emp.approved?.ent4 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent4\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.ent4 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent4\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.ent4 ? 'approved' : getTimeClass('ent4', emp.punches.ent4)}">${emp.punches.ent4 || '--:--'}</span>
                        ${emp.questions?.ent4 ? '<span class="has-question" title="' + emp.questions.ent4 + '">💬</span>' : ''}
                        ${emp.approved?.ent4 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent4 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai4" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('sai4') && !emp.approved?.sai4 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai4\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.sai4 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai4\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.sai4 ? 'approved' : getTimeClass('sai4', emp.punches.sai4)}">${emp.punches.sai4 || '--:--'}</span>
                        ${emp.questions?.sai4 ? '<span class="has-question" title="' + emp.questions.sai4 + '">💬</span>' : ''}
                        ${emp.approved?.sai4 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai4 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent5" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('ent5') && !emp.approved?.ent5 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent5\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.ent5 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent5\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.ent5 ? 'approved' : getTimeClass('ent5', emp.punches.ent5)}">${emp.punches.ent5 || '--:--'}</span>
                        ${emp.questions?.ent5 ? '<span class="has-question" title="' + emp.questions.ent5 + '">💬</span>' : ''}
                        ${emp.approved?.ent5 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent5 + '">✓</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative; cursor: pointer;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai5" data-name="${emp.name}" onclick="showSwapMenu(event, this)">
                        ${colunasErradas.has('sai5') && !emp.approved?.sai5 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai5\', \'' + emp.name + '\')" title="Aprovar horário trocado">✅</span>' : ''}
                        ${emp.punches.sai5 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai5\', \'' + emp.name + '\')" title="Adicionar pergunta">❓</span>' : ''}
                        <span class="punch-time ${emp.approved?.sai5 ? 'approved' : getTimeClass('sai5', emp.punches.sai5)}">${emp.punches.sai5 || '--:--'}</span>
                        ${emp.questions?.sai5 ? '<span class="has-question" title="' + emp.questions.sai5 + '">💬</span>' : ''}
                        ${emp.approved?.sai5 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai5 + '">✓</span>' : ''}
                    </td>
                    <td class="center" style="width: 70px; font-weight: bold; color: #7c3aed; font-size: 14px;">
                        ${emp.anexoId ? `#${emp.anexoId}` : '-'}
                    </td>
                    <td style="font-size: 12px; min-width: 150px; max-width: 200px;">
                        ${emp.motivo || '-'}
                    </td>
                    <td class="center" style="width: 100px;">
                        ${emp.anexoUrl ? `
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <a href="${emp.anexoUrl}" target="_blank" style="font-size: 11px; color: #3b82f6; text-decoration: none; font-weight: 600;">
                                    📎 Ver imagem
                                </a>
                                <button class="upload-btn" style="font-size: 10px; padding: 2px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;" onclick="handleFileUpload(event, '${emp.reg}', '${emp.date}')">
                                    🔄 Substituir
                                </button>
                            </div>
                        ` : `
                            <button class="upload-btn" style="font-size: 11px; padding: 5px 10px;" onclick="handleFileUpload(event, '${emp.reg}', '${emp.date}')">
                                📎 Anexar
                            </button>
                        `}
                    </td>
                    <td class="center" style="width: 90px;">
                        <span class="status-badge ${emp.hasInconsistency ? 'error' : 'ok'}" style="font-size: 11px; padding: 5px 10px;">
                            ${emp.hasInconsistency ? 'INCONS.' : 'OK'}
                        </span>
                    </td>
                </tr>
                `;
            }).join('');

            // 🔴 CORREÇÃO: Restaurar checkboxes selecionados
            displayedEmployees.forEach(emp => {
                const uniqueId = `${emp.reg}_${emp.date}`;
                if (selectedEmployees.includes(uniqueId)) {
                    const checkbox = tbody.querySelector(`.employee-checkbox[data-id="${uniqueId}"]`);
                    const row = checkbox?.closest('tr');
                    if (checkbox) checkbox.checked = true;
                    if (row) row.classList.add('selected');
                }
            });
            
            } finally {
                renderingTable = false;
            }
        }

        // Simular OCR - Extrair horários e justificativa da imagem
        function simulateOCR(fileName) {
            // Simulação de extração de dados
            const possibleTimes = ['07:30', '11:30', '12:30', '17:30', '18:00', '19:00'];
            const possibleReasons = [
                'Esquecimento do cartão',
                'Máquina do ponto quebrada',
                'Atendimento emergencial',
                'Reunião externa',
                'Visita ao cliente',
                'Problema no sistema'
            ];
            
            // Simula que extraiu um horário aleatório e uma justificativa
            const extractedTime = possibleTimes[Math.floor(Math.random() * possibleTimes.length)];
            const extractedReason = possibleReasons[Math.floor(Math.random() * possibleReasons.length)];
            
            return {
                time: extractedTime,
                reason: extractedReason
            };
        }

        // Upload de arquivo
        // ==========================================
        // SISTEMA DE ANEXOS (CTRL+V + OCR + Azure Blob)
        // ==========================================
        
        let currentAnexoEmployee = null;
        let currentAnexoImage = null;
        let currentOCRData = null;
        
        // Abrir modal de anexo
        function handleFileUpload(event, reg, date) {
            
            
            // Normalizar data para comparação (pode vir 2025-10-25 ou 25/10/2025)
            let dataComparacao = date;
            if (date.includes('/')) {
                // Converter DD/MM/YYYY → YYYY-MM-DD
                const [dia, mes, ano] = date.split('/');
                dataComparacao = `${ano}-${mes}-${dia}`;
            }
            
            // Buscar funcionário por REG E DATA
            const employee = allEmployees.find(emp => {
                // Normalizar data do employee também
                let empData = emp.date;
                if (emp.rawData?.Data) {
                    empData = emp.rawData.Data.split('T')[0]; // 2025-10-25T00:00:00 → 2025-10-25
                }
                
                const match = emp.reg === reg && empData === dataComparacao;
                if (match) {
                    
                }
                return match;
            });
            
            if (!employee) {
                console.error(`❌ Funcionário não encontrado: REG=${reg}, Data=${dataComparacao}`);
                alert('Erro: Funcionário não encontrado!');
                return;
            }
            
            abrirModalAnexo(employee);
        }
        
        async function abrirModalAnexo(employee) {
            currentAnexoEmployee = employee;
            currentAnexoImage = null;
            currentOCRData = null;
            
            
            
            document.getElementById('modalAnexoInfo').textContent = `REG: ${employee.reg} | ${employee.name} | Data: ${employee.date}`;
            document.getElementById('previewArea').style.display = 'none';
            document.getElementById('ocrStatus').style.display = 'none';
            document.getElementById('ocrResult').style.display = 'none';
            document.getElementById('btnConfirmarAnexo').style.display = 'none';
            
            // VERIFICAR SE JÁ EXISTE ANEXO (só para avisar usuário)
            let anexoExistenteId = null;
            try {
                const dataFormatada = employee.rawData?.Data?.split('T')[0] || employee.date;
                const empresaId = employee.empresaId || employee.companyId;
                
                const response = await fetch(`${API_BASE_URL}/api/anexos/${dataFormatada}/${employee.reg}`, {
                    headers: getAuthHeaders()
                });
                
                // Se retornou 404, não existe anexo (normal)
                if (response.status === 404) {
                    
                } else if (response.ok) {
                    const anexo = await response.json();
                    
                    if (anexo && anexo.blob_url) {
                        // JÁ EXISTE ANEXO - Perguntar o que fazer
                        const confirmacao = confirm(
                            `⚠️ JÁ EXISTE UM ANEXO PARA ESTE FUNCIONÁRIO NESTA DATA!\n\n` +
                            `📎 REG: ${employee.reg}\n` +
                            `👤 Nome: ${employee.name}\n` +
                            `📅 Data: ${dataFormatada}\n` +
                            `📝 Motivo salvo: ${anexo.motivo_detectado || '(não informado)'}\n\n` +
                            `Deseja SUBSTITUIR o anexo existente?\n\n` +
                            `✅ OK = Substituir anexo\n` +
                            `❌ Cancelar = Ver anexo atual`
                        );
                        
                        if (!confirmacao) {
                            // Usuário quer VER o anexo atual
                            window.open(anexo.blob_url, '_blank');
                            return;
                        }
                        
                        
                    }
                } else {
                    console.warn(`⚠️ Erro ao verificar anexo existente: ${response.status}`);
                }
            } catch (err) {
                console.warn('⚠️ Erro ao verificar anexo:', err.message);
            }
            
            document.getElementById('modalAnexo').style.display = 'flex';
            
            // Ativar área de drop
            setupDropZone();
        }
        
        function fecharModalAnexo() {
            document.getElementById('modalAnexo').style.display = 'none';
            currentAnexoEmployee = null;
            currentAnexoImage = null;
            currentOCRData = null;
        }
        
        function setupDropZone() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            
            // Click para selecionar arquivo
            dropZone.onclick = () => fileInput.click();
            
            // Arquivo selecionado
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) processarImagem(file);
            };
            
            // CTRL+V (Colar)
            document.addEventListener('paste', handlePaste);
            
            // Drag & Drop
            dropZone.ondragover = (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            };
            
            dropZone.ondragleave = () => {
                dropZone.classList.remove('dragover');
            };
            
            dropZone.ondrop = (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    processarImagem(file);
                }
            };
        }
        
        // CTRL+V - Colar imagem
        function handlePaste(e) {
            // Só processar se modal estiver aberto
            if (document.getElementById('modalAnexo').style.display !== 'flex') return;
            
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    processarImagem(blob);
                    break;
                }
            }
        }
        
        // PRÉ-PROCESSAMENTO DE IMAGEM para melhorar OCR (VERSÃO OTIMIZADA)
        async function preprocessarImagem(file) {
            return new Promise((resolve) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Escala 4x para melhor resolução
                        const scale = 4;
                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;
                        
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // Conversão para escala de cinza + contraste extremo
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                            const contrast = 4.0; // Aumentado de 3.5 para 4.0
                            let adjusted = ((gray - 128) * contrast) + 128;
                            adjusted = Math.max(0, Math.min(255, adjusted));
                            
                            // Binarização com threshold 140 (reduzido para pegar manuscrito)
                            const binary = adjusted > 140 ? 255 : 0;
                            data[i] = data[i + 1] = data[i + 2] = binary;
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        console.log(`📐 Pré-processamento: escala ${scale}x, contraste 4.0, threshold 140`);
                        
                        canvas.toBlob((blob) => resolve(blob), 'image/png');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // ==========================================
        // AZURE COMPUTER VISION API - OCR Manuscrito
        // ==========================================
        
        // Cache da chave Azure Vision
        let azureVisionConfig = null;
        
        async function getAzureVisionConfig() {
            if (azureVisionConfig) return azureVisionConfig;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/azure-vision-config`);
                if (response.ok) {
                    azureVisionConfig = await response.json();
                    return azureVisionConfig;
                }
            } catch (err) {
                console.warn('⚠️ Não foi possível obter config Azure Vision do servidor');
            }
            
            // Fallback: valores vazios (vai falhar mas não expõe credenciais)
            return { apiKey: '', endpoint: 'https://testedeocr123.cognitiveservices.azure.com/' };
        }
        
        async function extrairDadosComGoogleVision(imageBase64) {
            const config = await getAzureVisionConfig();
            const API_KEY = config.apiKey;
            const ENDPOINT = config.endpoint;
            
            if (!API_KEY) {
                throw new Error('Chave Azure Vision não configurada no servidor');
            }
            
            
            
            try {
                // 📏 REDIMENSIONAR imagem se muito grande
                let base64Content = imageBase64.split(',')[1];
                
                // Verificar tamanho
                const tamanhoMB = (base64Content.length * 3 / 4) / (1024 * 1024);
                
                if (tamanhoMB > 4) {
                    console.log('⚠️ Imagem muito grande, redimensionando...');
                    
                    const img = await new Promise((resolve, reject) => {
                        const image = new Image();
                        image.onload = () => resolve(image);
                        image.onerror = reject;
                        image.src = imageBase64;
                    });
                    
                    const maxSize = 1500;
                    let newWidth = img.width;
                    let newHeight = img.height;
                    
                    if (img.width > maxSize || img.height > maxSize) {
                        if (img.width > img.height) {
                            newWidth = maxSize;
                            newHeight = (img.height * maxSize) / img.width;
                        } else {
                            newHeight = maxSize;
                            newWidth = (img.width * maxSize) / img.height;
                        }
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, newWidth, newHeight);
                    
                    imageBase64 = canvas.toDataURL('image/jpeg', 0.85);
                    base64Content = imageBase64.split(',')[1];
                    
                    const novoTamanho = (base64Content.length * 3 / 4) / (1024 * 1024);
                    console.log(`✅ Imagem redimensionada: ${novoTamanho.toFixed(2)} MB (${newWidth}x${newHeight})`);
                }
                
                // Converter base64 para blob binário
                const byteCharacters = atob(base64Content);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/octet-stream' });
                
                // Azure Computer Vision - Read API (OCR para manuscrito)
                const analyzeUrl = `${ENDPOINT}vision/v3.2/read/analyze?language=pt`;
                
                
                
                const response = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: {
                        'Ocp-Apim-Subscription-Key': API_KEY,
                        'Content-Type': 'application/octet-stream'
                    },
                    body: blob
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('❌ Resposta da API:', errorText);
                    throw new Error(`Azure Vision API error: ${response.status} - ${errorText}`);
                }
                
                // Azure retorna URL para buscar o resultado
                const operationLocation = response.headers.get('Operation-Location');
                
                
                // Poll até resultado estar pronto
                let result;
                let attempts = 0;
                const maxAttempts = 10;
                
                while (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo
                    
                    const resultResponse = await fetch(operationLocation, {
                        headers: {
                            'Ocp-Apim-Subscription-Key': API_KEY
                        }
                    });
                    
                    result = await resultResponse.json();
                    
                    
                    
                    if (result.status === 'succeeded') {
                        console.log('✅ OCR concluído pelo Azure Computer Vision!');
                        break;
                    } else if (result.status === 'failed') {
                        console.error('❌ Azure OCR falhou:', result);
                        throw new Error('Azure OCR falhou');
                    }
                    
                    attempts++;
                }
                
                if (result.status !== 'succeeded') {
                    throw new Error('Timeout ao processar OCR');
                }
                
                // Extrair texto de todas as linhas
                const analyzeResult = result.analyzeResult;
                let fullText = '';
                
                if (analyzeResult && analyzeResult.readResults) {
                    console.log(`📄 Azure retornou ${analyzeResult.readResults.length} página(s)`);
                    for (const page of analyzeResult.readResults) {
                        
                        for (const line of page.lines) {
                            fullText += line.text + '\n';
                        }
                    }
                } else {
                    console.warn('⚠️ analyzeResult está vazio ou não tem readResults');
                }
                
                console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log('📄 TEXTO COMPLETO DETECTADO PELO AZURE:');
                console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log(fullText);
                console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                console.log(`📊 Total de caracteres: ${fullText.length}`);
                
                // ✅ DETECTAR CHECKBOX MARCADO PELO TEXTO DO AZURE (antes da análise de pixels)
                let motivoDetectado = 'Esqueceu de registrar o Ponto'; // Default
                let motivoDetectadoPorTexto = false;
                
                
                
                const motivosPossiveis = [
                    'Esqueceu de registrar o Ponto',
                    'Falha no App',
                    'Falta',
                    'Folga',
                    'Hora Parada',
                    'Maquina Ponto com defeito',
                    'Registro em duplicidade',
                    'Registro indevido'
                ];
                
                // 🎯 NOVA ESTRATÉGIA: Bolinha marcada é a que NÃO tem "O" antes do texto
                // Azure lê "O Motivo" para bolinhas vazias, e apenas "Motivo" para marcada
                const linhasTexto = fullText.split('\n');
                const motivosSemBolinha = [];
                
                for (const motivo of motivosPossiveis) {
                    // Procurar se existe linha com "O Motivo" (bolinha vazia)
                    const temBolinhaVazia = linhasTexto.some(linha => {
                        const linhaNormalizada = linha.trim().toLowerCase();
                        const motivoNormalizado = motivo.toLowerCase();
                        // Verifica se linha é exatamente "O Motivo" ou "o Motivo"
                        return linhaNormalizada === `o ${motivoNormalizado}` || 
                               linhaNormalizada.startsWith(`o ${motivoNormalizado}`);
                    });
                    
                    if (!temBolinhaVazia) {
                        // Este motivo NÃO tem "O" antes = bolinha está MARCADA
                        const existeTexto = linhasTexto.some(linha => {
                            const linhaNormalizada = linha.trim().toLowerCase();
                            const motivoNormalizado = motivo.toLowerCase();
                            return linhaNormalizada === motivoNormalizado || 
                                   linhaNormalizada.includes(motivoNormalizado);
                        });
                        
                        if (existeTexto) {
                            motivosSemBolinha.push(motivo);
                            
                        }
                    } else {
                        console.log(`   ○ "${motivo}" tem "O" antes → vazio`);
                    }
                }
                
                if (motivosSemBolinha.length === 1) {
                    motivoDetectado = motivosSemBolinha[0];
                    motivoDetectadoPorTexto = true;
                    console.log(`   🎯 DETECTADO: ${motivoDetectado}`);
                } else if (motivosSemBolinha.length > 1) {
                    console.log(`   ⚠️ Múltiplos motivos sem "O": ${motivosSemBolinha.join(', ')}`);
                    motivoDetectado = motivosSemBolinha[0]; // Pega o primeiro
                    motivoDetectadoPorTexto = true;
                } else {
                    console.log('   ⚠️ Nenhum motivo sem "O" detectado, usando análise visual...');
                }
                
                // 🎯 ESTRATÉGIA FINAL: DETECTAR HORÁRIOS APÓS "BATIDO"
                // Layout do formulário:
                // - Horários preenchidos aparecem primeiro (07:05, 12:40, 07:05)
                // - Depois aparecem as palavras "BATIDO BATIDO BATIDO"
                // - Depois aparecem horários manuscritos (17:25)
                // - Depois aparece "ANULAR BATIDA ANULAR BATIDA"
                
                const horarios = [];
                const linhas = fullText.split('\n');
                let dentroSecaoHorarios = false;
                let encontrouBatido = false; // Nova flag
                
                
                
                // ✅ PRIMEIRA PASSADA: Contar quantos "BATIDO" existem
                let contadorBatido = 0;
                let dentroSecaoTemp = false;
                for (let i = 0; i < linhas.length; i++) {
                    const linha = linhas[i].trim();
                    if (linha.includes('HORÁRIOS') || linha.includes('preencher somente')) {
                        dentroSecaoTemp = true;
                    }
                    if (linha.includes('JUSTIFICATIVA')) {
                        dentroSecaoTemp = false;
                        break;
                    }
                    if (dentroSecaoTemp && linha === 'BATIDO') {
                        contadorBatido++;
                    }
                }
                
                
                // ✅ SEGUNDA PASSADA: Ler horários e pular os primeiros N (que são batidos)
                let horariosEncontrados = [];
                
                for (let i = 0; i < linhas.length; i++) {
                    const linha = linhas[i].trim();
                    
                    // Detectar início da seção de horários
                    if (linha.includes('HORÁRIOS') || linha.includes('preencher somente')) {
                        dentroSecaoHorarios = true;
                        console.log(`   ✅ Linha ${i}: Início da seção de horários`);
                        continue;
                    }
                    
                    // Detectar fim da seção (JUSTIFICATIVA ou Assinatura)
                    if (linha.includes('JUSTIFICATIVA') || linha.includes('Assinatura')) {
                        if (dentroSecaoHorarios) {
                            console.log(`   🛑 Linha ${i}: Fim da seção (${linha.substring(0, 30)}...)`);
                            break;
                        }
                    }
                    
                    // Se estamos na seção de horários
                    if (dentroSecaoHorarios) {
                        // Ignorar linhas com palavras-chave de layout
                        if (linha === 'HORÁRIO' || linha === 'BATIDO' || linha.includes('ANULAR')) {
                            console.log(`   ⏭️ Linha ${i}: Ignorado (palavra-chave): ${linha}`);
                            continue;
                        }
                        
                        // ✅ NORMALIZAR horário: aceitar "07: 50", "11,20", "12:30"
                        const linhaNormalizada = linha.replace(/\s+/g, '').replace(',', ':');
                        const matchHorario = linhaNormalizada.match(/^(\d{1,2}):(\d{2})$/);
                        
                        if (matchHorario) {
                            const h = parseInt(matchHorario[1]);
                            const m = parseInt(matchHorario[2]);
                            
                            // Validar se é horário válido
                            if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
                                const horario = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                                horariosEncontrados.push({ horario, linhaOriginal: linha, indice: i });
                            }
                        }
                    }
                }
                
                // ✅ REGRA: Os primeiros N horários são BATIDOS, os demais são MANUSCRITOS
                horariosEncontrados.forEach((item, idx) => {
                    if (idx < contadorBatido) {
                        console.log(`   ❌ Linha ${item.indice}: Horário IGNORADO (já batido): ${item.horario}`);
                    } else {
                        if (!horarios.includes(item.horario)) {
                            horarios.push(item.horario);
                            console.log(`   ✍️ Linha ${item.indice}: Horário MANUSCRITO: ${item.horario} (original: "${item.linhaOriginal}")`);
                        }
                    }
                });
                
                
                
                // EXTRAIR MOTIVO COM DETECÇÃO VISUAL DO CHECKBOX MARCADO
                // ⚠️ Se não foi detectado pelo texto, usar análise de pixels
                
                try {
                    // Só fazer análise visual se não detectou pelo texto
                    if (!motivoDetectadoPorTexto) {
                        console.log(`🎯 Criando canvas para análise de checkbox...`);
                    
                        // Criar canvas da imagem para análise de pixels
                        const canvas = document.createElement('canvas');
                        const img = new Image();
                        img.src = imageBase64; // ✅ USAR O PARÂMETRO DA FUNÇÃO
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                
                                resolve();
                            };
                            img.onerror = (err) => {
                                console.error(`❌ Erro ao carregar imagem:`, err);
                                reject(err);
                            };
                        });
                        
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        
                        
                        // Detectar checkbox marcado visualmente (X preto)
                        const motivo = detectarCheckboxMarcado(canvas);
                        if (motivo) {
                            motivoDetectado = motivo;
                            console.log(`☑️ Motivo detectado VISUALMENTE: ${motivoDetectado}`);
                        } else {
                            console.log(`☑️ Motivo (padrão, nenhum X detectado): ${motivoDetectado}`);
                        }
                    } else {
                        console.log(`☑️ Motivo detectado pelo TEXTO do Azure: ${motivoDetectado}`);
                    }
                } catch (err) {
                    console.warn(`⚠️ Erro ao detectar checkbox visual, usando padrão:`, err);
                    console.log(`☑️ Motivo (padrão): ${motivoDetectado}`);
                }
                
                // EXTRAIR ID
                let idDetectado = null;
                const idMatch = fullText.match(/ID\s*IMP\s*:\s*(\d{1,3})/i);
                if (idMatch) {
                    idDetectado = idMatch[1];
                    console.log(`🆔 ID detectado: #${idDetectado}`);
                }
                
                // ✍️ DETECTAR ASSINATURAS (FUNCIONÁRIO E LÍDER)
                let assinaturaFuncionarioDetectada = false;
                let assinaturaLiderDetectada = false;
                try {
                    const canvas = document.createElement('canvas');
                    const img = new Image();
                    img.src = imageBase64;
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => resolve();
                        img.onerror = reject;
                    });
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Detectar ambas as assinaturas e mostrar debug
                    const resultados = detectarAssinaturas(canvas);
                    assinaturaFuncionarioDetectada = resultados.funcionario;
                    assinaturaLiderDetectada = resultados.lider;
                    
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('✍️ RESULTADO DETECÇÃO DE ASSINATURAS');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log(`👤 Funcionário: ${assinaturaFuncionarioDetectada ? '✅ ASSINADO' : '❌ NÃO ASSINADO'}`);
                    console.log(`👔 Líder: ${assinaturaLiderDetectada ? '✅ ASSINADO' : '❌ NÃO ASSINADO'}`);
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                } catch (err) {
                    console.warn('⚠️ Erro ao detectar assinaturas:', err);
                }
                
                return {
                    id: idDetectado,
                    assinaturaFuncionario: assinaturaFuncionarioDetectada,
                    assinaturaLider: assinaturaLiderDetectada,
                    ent1: horarios[0] || null,
                    sai1: horarios[1] || null,
                    ent2: horarios[2] || null,
                    sai2: horarios[3] || null,
                    ent3: horarios[4] || null,
                    sai3: horarios[5] || null,
                    ent4: horarios[6] || null,
                    sai4: horarios[7] || null,
                    ent5: horarios[8] || null,
                    sai5: horarios[9] || null,
                    motivo: motivoDetectado,
                    confidence: {
                        ent1: horarios[0] ? 95 : 0,
                        sai1: horarios[1] ? 95 : 0,
                        ent2: horarios[2] ? 95 : 0,
                        sai2: horarios[3] ? 95 : 0,
                        ent3: horarios[4] ? 95 : 0,
                        sai3: horarios[5] ? 95 : 0,
                        ent4: horarios[6] ? 95 : 0,
                        sai4: horarios[7] ? 95 : 0,
                        ent5: horarios[8] ? 95 : 0,
                        sai5: horarios[9] ? 95 : 0,
                        motivo: motivoDetectado ? 90 : 0
                    },
                    fullText: fullText
                };
                
            } catch (error) {
                console.error('❌ Erro Azure Vision API:', error);
                throw error;
            }
        }
        
        // 🔴 BUSCA DINÂMICA: Detecta TODAS as batidas (não só 4 fixas)
        function detectarCaixasAmarelas(canvas) {
            
            
            // 📐 GRID AUTOMÁTICO: Detecta quantas colunas e linhas existem
            // Baseado na imagem: primeira linha Y≈300, segunda linha Y≈380, etc
            const regioes = [];
            
            const larguraCampo = 170;
            const alturaCampo = 75;
            const espacamentoX = 200; // Espaço entre colunas
            const espacamentoY = 95;  // Espaço entre linhas
            
            const inicioX = 160;
            const inicioY = 300; // Começa mais alto para pegar primeira linha
            
            const maxColunas = 5; // Máximo 5 por linha (como na imagem 1)
            const maxLinhas = 3;  // Máximo 3 linhas (cobre até 15 batidas)
            
            let indice = 1;
            
            for (let linha = 0; linha < maxLinhas; linha++) {
                for (let coluna = 0; coluna < maxColunas; coluna++) {
                    const x = inicioX + (coluna * espacamentoX);
                    const y = inicioY + (linha * espacamentoY);
                    
                    regioes.push({
                        x: x,
                        y: y,
                        w: larguraCampo,
                        h: alturaCampo,
                        nome: `Batida ${indice}`,
                        linha: linha + 1,
                        coluna: coluna + 1
                    });
                    
                    indice++;
                }
            }
            
            
            
            // 🎨 DEBUG VISUAL: Desenhar retângulos nas regiões buscadas
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            // Desenhar TODAS as regiões em azul (busca direta, sem detecção de cor)
            for (const regiao of regioes) {
                debugCtx.strokeStyle = 'blue';
                debugCtx.lineWidth = 3;
                debugCtx.strokeRect(regiao.x, regiao.y, regiao.w, regiao.h);
                
                // Label
                debugCtx.fillStyle = 'blue';
                debugCtx.font = 'bold 16px Arial';
                debugCtx.fillText(regiao.nome, regiao.x + 5, regiao.y - 5);
            }
            
            // Abrir janela com debug
            try {
                const debugUrl = debugCanvas.toDataURL();
                const debugWindow = window.open('', '_blank', 'width=1200,height=800');
                if (debugWindow) {
                    debugWindow.document.write(`
                        <html>
                        <head><title>Debug - Regiões de Busca</title></head>
                        <body style="margin:0;background:#000;display:flex;justify-content:center;align-items:center;">
                            <div style="text-align:center;">
                                <h2 style="color:white;">🎯 Regiões de Busca Fixas</h2>
                                <p style="color:cyan;">■ AZUL = Busca OCR direta (sem detecção de cor)</p>
                                <img src="${debugUrl}" style="border:2px solid white;max-width:100%;"/>
                                <p style="color:yellow;">Y atual: 460 | Ajuste se necessário!</p>
                            </div>
                        </body>
                        </html>
                    `);
                }
            } catch (e) {
                console.warn('⚠️ Não foi possível abrir janela de debug');
            }
            
            return regioes; // Retorna TODAS as regiões (busca direta)
        }
        
        // OCR em região específica (crop)
        async function ocrRegion(canvas, region) {
            const cropCanvas = document.createElement('canvas');
            const ctx = cropCanvas.getContext('2d');
            
            cropCanvas.width = region.w;
            cropCanvas.height = region.h;
            
            ctx.drawImage(canvas, 
                region.x, region.y, region.w, region.h,
                0, 0, region.w, region.h
            );
            
            // Pré-processar crop
            const blob = await new Promise(resolve => {
                cropCanvas.toBlob(resolve, 'image/png');
            });
            
            const processedBlob = await preprocessarImagem(new File([blob], 'crop.png'));
            
            const result = await Tesseract.recognize(processedBlob, 'por', {
                tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                tessedit_char_whitelist: '0123456789:ENTRADASÍRIO ',
                tessedit_min_orientation_margin: '7.0',
                classify_bln_numeric_mode: '1'
            });
            
            return result.data;
        }
        
        // Detectar checkbox marcado - ANÁLISE PERCENTUAL MELHORADA
        function detectarCheckboxMarcado(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            console.log(`🖼️ Análise de checkbox em imagem ${canvas.width}x${canvas.height}`);
            
            // ✅ COORDENADAS DOS CHECKBOXES (quadradinhos, NÃO o texto)
            // Baseado na imagem 954x641:
            // - Checkboxes ficam à ESQUERDA do texto
            // - Linha 1: Y ~ 385 (60% da altura)
            // - Linha 2: Y ~ 410 (64% da altura)
            // - Margem esquerda dos checkboxes: 5%, depois +20% entre cada um
            
            const largura = canvas.width;
            const altura = canvas.height;
            
            const checkboxes = [
                // Linha 1 (Y = 60%)
                // ✅ AJUSTE CRÍTICO: Quadradinhos ficam BEM À ESQUERDA, antes do texto
                // Baseado na imagem: checkbox tem ~15px, fica a ~50px da esquerda
                { x: Math.round(largura * 0.045), y: Math.round(altura * 0.601), label: 'Esqueceu de registrar o Ponto' },
                { x: Math.round(largura * 0.275), y: Math.round(altura * 0.601), label: 'Falha no App' },
                { x: Math.round(largura * 0.515), y: Math.round(altura * 0.601), label: 'Falta' },
                { x: Math.round(largura * 0.755), y: Math.round(altura * 0.601), label: 'Folga' },
                // Linha 2 (Y = 64%)
                { x: Math.round(largura * 0.045), y: Math.round(altura * 0.641), label: 'Hora Parada' },
                { x: Math.round(largura * 0.275), y: Math.round(altura * 0.641), label: 'Maquina Ponto com defeito' },
                { x: Math.round(largura * 0.515), y: Math.round(altura * 0.641), label: 'Registro em duplicidade' },
                { x: Math.round(largura * 0.655), y: Math.round(altura * 0.641), label: 'Registro indevido' }
            ];
            
            console.log(`📊 Analisando ${checkboxes.length} checkboxes...`);
            
            // 🎨 DEBUG VISUAL: Desenhar círculos vermelhos nas coordenadas
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            debugCtx.strokeStyle = 'red';
            debugCtx.lineWidth = 3;
            debugCtx.fillStyle = 'red';
            debugCtx.font = '14px Arial';
            
            // ✅ NOVA ESTRATÉGIA: Pegar o checkbox com MAIOR % de preto
            let maxPreto = 0;
            let checkboxMarcado = null;
            
            checkboxes.forEach((cb, index) => {
                // Desenhar círculo vermelho
                debugCtx.beginPath();
                debugCtx.arc(cb.x, cb.y, 10, 0, 2 * Math.PI);
                debugCtx.stroke();
                
                // Desenhar número
                debugCtx.fillText(`${index + 1}`, cb.x + 15, cb.y + 5);
                
                // Analisar área 18x18
                const tamanho = 18;
                const imageData = ctx.getImageData(cb.x - tamanho/2, cb.y - tamanho/2, tamanho, tamanho);
                const data = imageData.data;
                
                let pixelsPretos = 0;
                let pixelsTotal = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Contar pixels pretos/escuros
                    if (r + g + b < 350) {
                        pixelsPretos++;
                    }
                    pixelsTotal++;
                }
                
                const percentualPreto = (pixelsPretos / pixelsTotal) * 100;
                
                console.log(`📍 ${cb.label} (${cb.x},${cb.y}): ${percentualPreto.toFixed(1)}% preto`);
                
                // Guardar o que tiver MAIS preto
                if (percentualPreto > maxPreto) {
                    maxPreto = percentualPreto;
                    checkboxMarcado = cb.label;
                }
            });
            
            // 🎨 Abrir imagem de debug automaticamente em nova aba
            const debugUrl = debugCanvas.toDataURL('image/png');
            console.log('🎨 IMAGEM DE DEBUG GERADA!');
            console.log('👁️ Abrindo imagem com círculos vermelhos em nova aba...');
            console.log('📍 Legenda: 1=Esqueceu, 2=Falha no App, 3=Falta, 4=Folga, 5=Hora Parada, 6=Maquina defeito, 7=Duplicidade, 8=Indevido');
            
            // Abrir em nova aba automaticamente
            const debugWindow = window.open();
            if (debugWindow) {
                debugWindow.document.write(`<img src="${debugUrl}" style="max-width:100%; height:auto;">`);
                debugWindow.document.title = 'Debug - Posições dos Checkboxes';
            } else {
                console.log('⚠️ Pop-up bloqueado! Cole este link numa nova aba:');
                console.log(debugUrl);
            }
            
            // ✅ Retornar o checkbox com MAIOR concentração de preto (se > 15%)
            if (maxPreto > 15) {
                
                return checkboxMarcado;
            }
            
            console.log('⚠️ Nenhum checkbox com concentração suficiente, usando padrão');
            return 'Esqueceu de registrar o Ponto';
        }
        
        // ==========================================
        // DETECÇÃO DE ASSINATURAS (FUNCIONÁRIO E LÍDER)
        // ==========================================
        function detectarAssinaturas(canvas) {
            console.log('✍️ Iniciando detecção de assinaturas (Funcionário + Líder)...');
            
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const largura = canvas.width;
            const altura = canvas.height;
            
            // 📍 REGIÕES DAS ASSINATURAS
            // Baseado na imagem fornecida:
            
            // FUNCIONÁRIO (lado esquerdo inferior)
            // Região focada ACIMA do nome impresso "ADEMIR QUEIROZ DE SOUSA"
            const regiaoFuncionario = {
                x: Math.round(largura * 0.05),  // 5% da largura
                y: Math.round(altura * 0.80),   // 80% da altura (área da assinatura manuscrita)
                w: Math.round(largura * 0.40),  // 40% da largura
                h: Math.round(altura * 0.10),   // 10% da altura (só a área da assinatura, não o texto)
                nome: 'Funcionário',
                cor: '#3b82f6'  // Azul
            };
            
            // LÍDER (lado direito inferior)
            // Região focada ACIMA do nome impresso "JOÃO CARLOS ALMEIDA LOPES"
            const regiaoLider = {
                x: Math.round(largura * 0.52),  // 52% da largura (metade direita)
                y: Math.round(altura * 0.80),   // 80% da altura (área da assinatura manuscrita)
                w: Math.round(largura * 0.43),  // 43% da largura
                h: Math.round(altura * 0.10),   // 10% da altura (só a área da assinatura)
                nome: 'Líder',
                cor: '#10b981'  // Verde
            };
            
            const regioes = [regiaoFuncionario, regiaoLider];
            
            // 🎨 DEBUG VISUAL: Criar canvas com retângulos coloridos
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            // Analisar cada região
            const resultados = {};
            
            regioes.forEach(regiao => {
                console.log(`\n📍 Analisando ${regiao.nome}:`);
                console.log(`   Região: X=${regiao.x}, Y=${regiao.y}, W=${regiao.w}, H=${regiao.h}`);
                
                // Extrair dados da região
                const imageData = ctx.getImageData(regiao.x, regiao.y, regiao.w, regiao.h);
                const data = imageData.data;
                
                // Análise de pixels
                let pixelsEscuros = 0;
                let pixelsTotal = 0;
                let pixelsMuitoEscuros = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const luminosidade = (r + g + b) / 3;
                    
                    pixelsTotal++;
                    
                    if (luminosidade < 180) {
                        pixelsEscuros++;
                    }
                    
                    if (luminosidade < 100) {
                        pixelsMuitoEscuros++;
                    }
                }
                
                const percentualEscuros = (pixelsEscuros / pixelsTotal) * 100;
                const percentualMuitoEscuros = (pixelsMuitoEscuros / pixelsTotal) * 100;
                
                console.log(`   📊 Pixels escuros (<180): ${percentualEscuros.toFixed(2)}%`);
                console.log(`   📊 Pixels muito escuros (<100): ${percentualMuitoEscuros.toFixed(2)}%`);
                
                // Critério de detecção (threshold ajustado para distinguir assinatura manuscrita de texto impresso)
                // Texto impresso: ~1-2% pixels escuros
                // Assinatura manuscrita: ~5-10% pixels escuros
                const temAssinatura = percentualMuitoEscuros > 3 || percentualEscuros > 5;
                
                console.log(`   ${temAssinatura ? '✅ ASSINADO' : '❌ NÃO ASSINADO'}`);
                
                // Guardar resultado (usar chaves fixas para evitar problemas)
                if (regiao.nome === 'Funcionário') {
                    resultados.funcionario = temAssinatura;
                } else if (regiao.nome === 'Líder') {
                    resultados.lider = temAssinatura;
                }
                
                // Desenhar retângulo colorido
                debugCtx.strokeStyle = temAssinatura ? regiao.cor : '#ef4444'; // Verde/Azul se assinado, Vermelho se não
                debugCtx.lineWidth = 4;
                debugCtx.strokeRect(regiao.x, regiao.y, regiao.w, regiao.h);
                
                // Desenhar label
                debugCtx.fillStyle = temAssinatura ? regiao.cor : '#ef4444';
                debugCtx.font = 'bold 24px Arial';
                const label = `${temAssinatura ? '✅' : '❌'} ${regiao.nome.toUpperCase()}`;
                const textMetrics = debugCtx.measureText(label);
                const padding = 10;
                
                // Fundo do texto
                debugCtx.fillRect(
                    regiao.x, 
                    regiao.y - 40, 
                    textMetrics.width + padding * 2, 
                    35
                );
                
                // Texto
                debugCtx.fillStyle = 'white';
                debugCtx.fillText(label, regiao.x + padding, regiao.y - 12);
                
                // Adicionar percentuais
                debugCtx.font = '14px Arial';
                debugCtx.fillStyle = temAssinatura ? regiao.cor : '#ef4444';
                const stats = `${percentualMuitoEscuros.toFixed(1)}% preto | ${percentualEscuros.toFixed(1)}% escuro`;
                debugCtx.fillText(stats, regiao.x + 10, regiao.y + 25);
            });
            
            // 🎨 Mostrar imagem de debug
            const debugUrl = debugCanvas.toDataURL('image/png');
            const debugWindow = window.open('', '_blank', 'width=1000,height=800');
            if (debugWindow) {
                debugWindow.document.write(`
                    <html>
                        <head>
                            <title>🔍 Detecção de Assinaturas</title>
                            <style>
                                body { 
                                    margin: 0; 
                                    padding: 20px; 
                                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                                    font-family: Arial, sans-serif;
                                }
                                .container {
                                    background: rgba(30, 41, 59, 0.95);
                                    border-radius: 15px;
                                    padding: 20px;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                }
                                h1 { 
                                    color: #e2e8f0; 
                                    margin: 0 0 15px 0;
                                    font-size: 28px;
                                }
                                .stats {
                                    display: grid;
                                    grid-template-columns: 1fr 1fr;
                                    gap: 15px;
                                    margin-bottom: 20px;
                                }
                                .stat-box {
                                    padding: 15px;
                                    border-radius: 10px;
                                    text-align: center;
                                }
                                .stat-box.funcionario { background: #dbeafe; border: 3px solid #3b82f6; }
                                .stat-box.lider { background: #d1fae5; border: 3px solid #10b981; }
                                .stat-box.unsigned { background: #fee2e2; border: 3px solid #ef4444; }
                                .stat-box h3 { margin: 0 0 5px 0; font-size: 18px; }
                                .stat-box .status { font-size: 32px; margin: 5px 0; }
                                .stat-box .label { font-size: 14px; color: #64748b; }
                                img { 
                                    max-width: 100%; 
                                    border: 3px solid #cbd5e1; 
                                    border-radius: 10px;
                                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                }
                                .info {
                                    margin-top: 15px;
                                    padding: 15px;
                                    background: #f1f5f9;
                                    border-left: 4px solid #3b82f6;
                                    border-radius: 5px;
                                    font-size: 13px;
                                    color: #475569;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="container">
                                <h1>🔍 Detecção de Assinaturas</h1>
                                <div class="stats">
                                    <div class="stat-box ${resultados.funcionario ? 'funcionario' : 'unsigned'}">
                                        <h3>👤 FUNCIONÁRIO</h3>
                                        <div class="status">${resultados.funcionario ? '✅' : '❌'}</div>
                                        <div class="label">${resultados.funcionario ? 'ASSINADO' : 'NÃO ASSINADO'}</div>
                                    </div>
                                    <div class="stat-box ${resultados.lider ? 'lider' : 'unsigned'}">
                                        <h3>👔 LÍDER</h3>
                                        <div class="status">${resultados.lider ? '✅' : '❌'}</div>
                                        <div class="label">${resultados.lider ? 'ASSINADO' : 'NÃO ASSINADO'}</div>
                                    </div>
                                </div>
                                <img src="${debugUrl}">
                                <div class="info">
                                    <strong>ℹ️ Legenda:</strong><br>
                                    🔵 Retângulo AZUL = Região do Funcionário<br>
                                    🟢 Retângulo VERDE = Região do Líder<br>
                                    🔴 Retângulo VERMELHO = Assinatura não detectada<br><br>
                                    <strong>Limiar de detecção:</strong> ≥2% pixels muito escuros OU ≥6% pixels escuros
                                </div>
                            </div>
                        </body>
                    </html>
                `);
            }
            
            return resultados;
        }
        
        // ==========================================
        // EXTRAÇÃO DE ID DO PDF (VERSÃO CORRIGIDA FINAL)
        // ==========================================
        async function extrairIdDoPDF(canvas) {
            console.log('🔍 Iniciando extração de ID (posição: ID IMP)...');
            console.log('📐 Dimensões do canvas original:', canvas.width + 'x' + canvas.height);
            
            try {
                // ✅ REGIÃO CORRETA: "ID IMP: XX" na SEGUNDA linha do cabeçalho
                // Layout: [Nome/Cidade/Data] na linha 1, [REG/Projeto/ID IMP] na linha 2
                // ID IMP está no canto direito da segunda linha do cabeçalho
                const idRegion = { 
                    x: 700,  // Mais à esquerda para capturar "ID IMP:" completo
                    y: 175,  // Ajustado para linha 2 do cabeçalho
                    w: 150,  // Largura maior para capturar "ID IMP: XX" completo
                    h: 40    // Altura maior para garantir captura
                };
                
                console.log(`📍 Buscando na região: X=${idRegion.x}, Y=${idRegion.y}, W=${idRegion.w}, H=${idRegion.h}`);
                
                // Crop da região
                const cropCanvas = document.createElement('canvas');
                const ctx = cropCanvas.getContext('2d');
                
                // Ampliar 4x para melhor leitura
                const scale = 4;
                cropCanvas.width = idRegion.w * scale;
                cropCanvas.height = idRegion.h * scale;
                
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(canvas, 
                    idRegion.x, idRegion.y, idRegion.w, idRegion.h,
                    0, 0, cropCanvas.width, cropCanvas.height
                );
                
                // Processamento de imagem: binarização forte
                const imageData = ctx.getImageData(0, 0, cropCanvas.width, cropCanvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Converter para escala de cinza
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    // Binarização AGRESSIVA: texto preto vs fundo branco
                    // Threshold mais alto para melhor contraste
                    const binary = gray < 180 ? 0 : 255;
                    data[i] = data[i + 1] = data[i + 2] = binary;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // OCR otimizado
                const blob = await new Promise(resolve => cropCanvas.toBlob(resolve, 'image/png'));
                
                const result = await Tesseract.recognize(blob, 'por', {
                    tessedit_char_whitelist: '0123456789IDIMP: ',
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
                    preserve_interword_spaces: '1'
                });
                
                // 🔍 DEBUG VISUAL: Mostrar imagem processada e abrir em nova aba
                const debugUrl = cropCanvas.toDataURL();
                console.log('🖼️ Região processada (copie o link abaixo e cole em nova aba):');
                console.log(debugUrl);
                console.log('📊 Tamanho da região: ' + cropCanvas.width + 'x' + cropCanvas.height + 'px');
                
                // Abrir automaticamente em nova janela para visualização
                try {
                    const debugWindow = window.open();
                    if (debugWindow) {
                        debugWindow.document.write(`<img src="${debugUrl}" style="border: 2px solid red;"/>`);
                        debugWindow.document.write(`<p>Região: X=${idRegion.x}, Y=${idRegion.y}, W=${idRegion.w}, H=${idRegion.h}</p>`);
                    }
                } catch (e) {
                    console.warn('⚠️ Não foi possível abrir janela de debug (popup bloqueado?)');
                }
                
                // ✅ VERIFICAÇÃO SEGURA: checar se result existe antes de acessar propriedades
                if (!result || !result.data) {
                    console.error('❌ OCR não retornou dados válidos:', result);
                    return null;
                }
                
                const textoExtraido = result.data.text || '';
                const confidence = result.data.confidence || 0;
                
                console.log(`   📄 Texto extraído: "${textoExtraido.trim()}"`);
                console.log(`   📊 Confiança: ${Math.round(confidence)}%`);
                
                if (!textoExtraido) {
                    console.warn('   ⚠️ OCR não retornou texto');
                    return null;
                }
                
                // ✅ EXTRAIR ID: APENAS se tiver "ID IMP" próximo ao número
                // Padrão 1: "ID IMP: 22" ou "ID IMP 22" ou "IDIMP:22"
                let match = textoExtraido.match(/ID\s*IMP\s*:?\s*(\d{1,3})/i);
                
                // Padrão 2: Número ISOLADO de 1-2 dígitos (ID IMP geralmente é < 100)
                // IMPORTANTE: NÃO capturar números de data (evita "17" de "17/11")
                if (!match) {
                    // Procurar número que NÃO está próximo de barra (/)
                    const textoLimpo = textoExtraido.replace(/\d{1,2}\/\d{1,2}(\/\d{2,4})?/g, ''); // Remove datas
                    match = textoLimpo.match(/\b(\d{1,2})\b/); // Números de 1-2 dígitos SOMENTE
                }
                
                if (match && match[1]) {
                    const id = parseInt(match[1]);
                    
                    // Validar se está em range válido (1-99, expandido para permitir até 200 se necessário)
                    if (id > 0 && id <= 200) {
                        console.log(`✅ ID detectado: #${id} (confiança: ${Math.round(confidence)}%)`);
                        return id.toString();
                    } else {
                        console.warn(`   ⚠️ Número encontrado (${id}) mas fora do range válido (1-200)`);
                    }
                } else {
                    console.warn('   ⚠️ Nenhum padrão de ID encontrado no texto');
                }
                
                // 🔄 FALLBACK: Tentar regiões alternativas
                console.log('🔄 Tentando regiões alternativas...');
                
                const alternativeRegions = [
                    { x: 650, y: 175, w: 200, h: 40, desc: 'Região ampla esquerda' },
                    { x: 680, y: 160, w: 160, h: 45, desc: 'Mais alto' },
                    { x: 720, y: 190, w: 140, h: 35, desc: 'Centro-direita' },
                    { x: 750, y: 175, w: 120, h: 40, desc: 'Extrema direita' },
                    { x: 600, y: 170, w: 250, h: 50, desc: 'Região MUITO ampla (última tentativa)' }
                ];
                
                for (const altRegion of alternativeRegions) {
                    console.log(`   🔄 Tentando: ${altRegion.desc} (X=${altRegion.x}, Y=${altRegion.y})`);
                    
                    const altCanvas = document.createElement('canvas');
                    const altCtx = altCanvas.getContext('2d');
                    const altScale = 4;
                    
                    altCanvas.width = altRegion.w * altScale;
                    altCanvas.height = altRegion.h * altScale;
                    altCtx.imageSmoothingEnabled = false;
                    altCtx.drawImage(canvas, 
                        altRegion.x, altRegion.y, altRegion.w, altRegion.h,
                        0, 0, altCanvas.width, altCanvas.height
                    );
                    
                    // Pré-processamento
                    const altImageData = altCtx.getImageData(0, 0, altCanvas.width, altCanvas.height);
                    const altData = altImageData.data;
                    for (let i = 0; i < altData.length; i += 4) {
                        const gray = 0.299 * altData[i] + 0.587 * altData[i + 1] + 0.114 * altData[i + 2];
                        const binary = gray < 160 ? 0 : 255;
                        altData[i] = altData[i + 1] = altData[i + 2] = binary;
                    }
                    altCtx.putImageData(altImageData, 0, 0);
                    
                    const altBlob = await new Promise(resolve => altCanvas.toBlob(resolve, 'image/png'));
                    
                    // Tentar com PSM.SINGLE_LINE primeiro
                    let altResult = await Tesseract.recognize(altBlob, 'por', {
                        tessedit_char_whitelist: '0123456789IDIMP: ',
                        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
                    });
                    
                    // Se falhar, tentar com PSM.AUTO
                    if (!altResult?.data?.text || altResult.data.text.trim() === '') {
                        console.log('      🔄 PSM.SINGLE_LINE falhou, tentando PSM.AUTO...');
                        altResult = await Tesseract.recognize(altBlob, 'por', {
                            tessedit_char_whitelist: '0123456789IDIMP: ',
                            tessedit_pageseg_mode: Tesseract.PSM.AUTO
                        });
                    }
                    
                    if (altResult?.data?.text) {
                        const altTexto = altResult.data.text.trim();
                        console.log(`      📄 Texto alternativo: "${altTexto}"`);
                        
                        const altMatch = altTexto.match(/ID\s*IMP\s*:?\s*(\d{1,3})/i) || 
                                        altTexto.replace(/\d{1,2}\/\d{1,2}/g, '').match(/\b(\d{1,2})\b/);
                        
                        if (altMatch?.[1]) {
                            const altId = parseInt(altMatch[1]);
                            if (altId > 0 && altId <= 200) {
                                console.log(`✅ ID detectado na região alternativa: #${altId}`);
                                return altId.toString();
                            }
                        }
                    }
                }
                
            } catch (err) {
                console.error('❌ Erro ao extrair ID:', err);
                console.error('Stack trace:', err.stack);
            }
            
            console.warn('⚠️ ID não encontrado no PDF (tentativas esgotadas)');
            return null;
        }

        
        // ==========================================
        // PROCESSAMENTO DE IMAGEM COM VALIDAÇÃO INTELIGENTE
        // ==========================================
        async function processarImagem(file) {
            console.log('📸 Processando imagem:', file.name || 'clipboard');
            
            // Mostrar preview
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('previewImage').src = e.target.result;
                document.getElementById('previewArea').style.display = 'block';
                currentAnexoImage = e.target.result;
            };
            reader.readAsDataURL(file);
            
            // Mostrar status
            document.getElementById('ocrStatus').style.display = 'block';
            document.getElementById('ocrResult').style.display = 'none';
            document.getElementById('ocrStatusText').textContent = '🔍 Analisando com Google Vision AI...';
            
            try {
                // Converter para base64
                const readerBase64 = new FileReader();
                const base64Image = await new Promise((resolve) => {
                    readerBase64.onload = (e) => resolve(e.target.result);
                    readerBase64.readAsDataURL(file);
                });
                
                // ======================================
                // ETAPA 1: VALIDAR ID (mantém lógica existente)
                // ======================================
                document.getElementById('ocrStatusText').textContent = '🔍 Verificando ID do formulário...';
                
                const dadosExtraidos = await extrairDadosComGoogleVision(base64Image);
                
                const idEncontrado = dadosExtraidos.id;
                const idEsperado = currentAnexoEmployee?.id;
                
                console.log('');
                
                console.log('');
                
                // ⚠️ CASO 1: IDs diferentes OU não detectado = PERGUNTAR
                if (idEsperado && idEncontrado && parseInt(idEncontrado) !== parseInt(idEsperado)) {
                    const continuar = confirm(
                        `⚠️ ID DIFERENTE!\n\n` +
                        `ID esperado: #${idEsperado}\n` +
                        `ID detectado: #${idEncontrado}\n\n` +
                        `Deseja continuar mesmo assim?`
                    );
                    
                    if (!continuar) {
                        document.getElementById('ocrStatus').style.display = 'none';
                        return;
                    }
                }
                
                // ⚠️ CASO 2: Não leu ID = PERGUNTAR
                if (idEsperado && !idEncontrado) {
                    const continuar = confirm(
                        `⚠️ ID NÃO DETECTADO\n\n` +
                        `Não foi possível ler o ID automaticamente.\n\n` +
                        `👤 Funcionário: ${currentAnexoEmployee.name}\n` +
                        `📋 ID esperado: #${idEsperado}\n\n` +
                        `Deseja continuar?`
                    );
                    
                    if (!continuar) {
                        document.getElementById('ocrStatus').style.display = 'none';
                        return;
                    }
                }
                
                // ✅ CASO 3: IDs batem
                if (idEncontrado && idEsperado && parseInt(idEncontrado) === parseInt(idEsperado)) {
                    console.log(`✅✅✅ ID VALIDADO COM SUCESSO! ✅✅✅`);
                }
                
                // ℹ️ CASO 4: Primeiro formulário
                if (!idEsperado) {
                    console.log(`ℹ️ Funcionário ainda não possui ID no sistema`);
                }
                
                // ======================================
                // ETAPA 2: USAR DADOS DO GOOGLE VISION
                // ======================================
                
                currentOCRData = dadosExtraidos;
                
                // Esconder status e mostrar resultado
                document.getElementById('ocrStatus').style.display = 'none';
                mostrarResultadoOCR(dadosExtraidos);
                document.getElementById('btnConfirmarAnexo').style.display = 'block';
                
            } catch (err) {
                console.error('❌ Erro no OCR:', err);
                console.error('Stack:', err.stack);
                document.getElementById('ocrStatusText').textContent = '⚠️ Erro - Você pode continuar manualmente';
                document.getElementById('btnConfirmarAnexo').style.display = 'block';
            }
        }

        
        // ⚠️ FUNÇÃO ANTIGA - NÃO MAIS USADA (substituída por extrairIdDoPDF(canvas))
        /*
        function extrairIdDoPDF_OLD(texto, palavrasComConfidencia = []) {
            console.log('🔍 Buscando ID no PDF...');
            
            // MÉTODO 1: Buscar padrão "ID #22" no texto completo
            const patterns = [
                /ID\s*#\s*(\d+)/i,
                /ID#(\d+)/i,
                /ID:(\d+)/i,
                /ID\s+(\d+)/i,
                /\bI\s*D\s*#?\s*(\d+)/i
            ];
            
            for (const pattern of patterns) {
                const match = texto.match(pattern);
                if (match) {
                    const id = match[1];
                    // Validar que não é REG, Projeto ou Data
                    if (parseInt(id) < 200 && id.length <= 3) {
                        console.log(`🆔 ID encontrado (método 1 - texto): #${id}`);
                        return id;
                    }
                }
            }
            
            // MÉTODO 2: Buscar "#" seguido de número pequeno em qualquer lugar
            const hashMatch = texto.match(/#\s*(\d{1,3})\b/);
            if (hashMatch) {
                const id = hashMatch[1];
                if (parseInt(id) > 0 && parseInt(id) < 200) {
                    console.log(`🆔 ID encontrado (método 2 - hash): #${id}`);
                    return id;
                }
            }
            
            // MÉTODO 3: Buscar em palavras com alta confiança no CANTO SUPERIOR DIREITO
            if (palavrasComConfidencia && palavrasComConfidencia.length > 0) {
                console.log('🔍 Analisando posições das palavras...');
                
                const candidatosID = [];
                
                palavrasComConfidencia.forEach((word, index) => {
                    // Procurar números de 1-3 dígitos no canto superior direito
                    const match = word.text.match(/^#?(\d{1,3})$/);
                    if (match && word.confidence > 80) {
                        const id = match[1];
                        const x = word.bbox.x0;
                        const y = word.bbox.y0;
                        const num = parseInt(id);
                        
                        // ID deve estar: TOPO (Y < 250) e DIREITA (X > 550)
                        // Número pequeno (< 200) para diferenciar de REG/Projeto
                        if (num > 0 && num < 200 && x > 550 && y < 250) {
                            candidatosID.push({
                                id: id,
                                confidence: word.confidence,
                                x: x,
                                y: y,
                                score: x - (y * 2) // Prioriza X alto e Y baixo (números positivos)
                            });
                        }
                    }
                });
                
                // Ordenar por score (prioriza topo-direito)
                candidatosID.sort((a, b) => b.score - a.score);
                
                if (candidatosID.length > 0) {
                    const melhor = candidatosID[0];
                    console.log(`🆔 ID encontrado (método 3 - posição): #${melhor.id}`);
                    console.log(`   X=${Math.round(melhor.x)}, Y=${Math.round(melhor.y)}, Score=${Math.round(melhor.score)}, Confiança=${Math.round(melhor.confidence)}%`);
                    if (candidatosID.length > 1) {
                        console.log(`   Rejeitados: ${candidatosID.slice(1).map(c => `#${c.id} (X=${Math.round(c.x)}, Y=${Math.round(c.y)}, Score=${Math.round(c.score)})`).join(', ')}`);
                    }
                    return melhor.id;
                }
            }
            
            console.warn('⚠️ ID não encontrado no PDF');
            return null;
        }
        */

        // ⚠️ FUNÇÃO ANTIGA - NÃO MAIS USADA (sistema híbrido agora detecta caixas automaticamente)
        /*
        // 🆕 EXTRAÇÃO MELHORADA COM VALIDAÇÃO INTELIGENTE
        function extrairDadosOCRMelhorado(texto, palavrasFiltradas, ocrData) {
            console.log('🔍 Iniciando extração melhorada de dados...');
            
            const dados = {
                ent1: null,
                sai1: null,
                ent2: null,
                sai2: null,
                ent3: null,
                sai3: null,
                motivo: null,
                confidence: {
                    ent1: 0,
                    sai1: 0,
                    ent2: 0,
                    sai2: 0,
                    ent3: 0,
                    sai3: 0,
                    motivo: 0
                }
            };
            
            // EXTRAÇÃO DE HORÁRIOS COM VALIDAÇÃO
            const horariosEncontrados = [];
            
            // Buscar horários nas palavras filtradas (confiança > 70%)
            for (let i = 0; i < palavrasFiltradas.length; i++) {
                const word = palavrasFiltradas[i];
                
                // Padrão 1: HH:MM
                const match1 = word.text.match(/^(\d{1,2}):(\d{2})$/);
                if (match1) {
                    const hora = parseInt(match1[1]);
                    const min = parseInt(match1[2]);
                    
                    if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                        horariosEncontrados.push({
                            horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                            confidence: word.confidence,
                            posicao: word.bbox.x0
                        });
                        console.log(`✅ Horário detectado: ${hora}:${min} (confiança: ${Math.round(word.confidence)}%)`);
                    }
                }
                
                // Padrão 2: HHMM (4 dígitos)
                const match2 = word.text.match(/^(\d{4})$/);
                if (match2) {
                    const valor = match2[1];
                    const hora = parseInt(valor.substring(0, 2));
                    const min = parseInt(valor.substring(2, 4));
                    
                    if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                        if (parseInt(valor) < 2020 || parseInt(valor) > 2030) {
                            horariosEncontrados.push({
                                horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                                confidence: word.confidence,
                                posicao: word.bbox.x0
                            });
                            console.log(`✅ Horário detectado (4 dígitos): ${hora}:${min} (confiança: ${Math.round(word.confidence)}%)`);
                        }
                    }
                }
                
                // Padrão 3: HH MM (dois números separados por espaço) - "07 10"
                const match3 = word.text.match(/^(\d{2})$/);
                if (match3 && i + 1 < palavrasFiltradas.length) {
                    const nextWord = palavrasFiltradas[i + 1];
                    const match4 = nextWord.text.match(/^(\d{2})$/);
                    
                    if (match4) {
                        const hora = parseInt(match3[1]);
                        const min = parseInt(match4[1]);
                        
                        // Verificar se próxima palavra está próxima horizontalmente (mesmo horário)
                        const distancia = Math.abs(nextWord.bbox.x0 - (word.bbox.x0 + 30));
                        const distanciaVertical = Math.abs(nextWord.bbox.y0 - word.bbox.y0);
                        
                        console.log(`🔍 Par "${word.text}" + "${nextWord.text}": X1=${Math.round(word.bbox.x0)}, X2=${Math.round(nextWord.bbox.x0)}, distH=${Math.round(distancia)}px, distV=${Math.round(distanciaVertical)}px`);
                        
                        if (distancia < 80 && distanciaVertical < 20 && hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                            horariosEncontrados.push({
                                horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                                confidence: (word.confidence + nextWord.confidence) / 2,
                                posicao: word.bbox.x0
                            });
                            console.log(`✅ Horário detectado (espaçado): ${hora}:${min} (confiança: ${Math.round((word.confidence + nextWord.confidence) / 2)}%)`);
                            i++; // Pular próxima palavra já processada
                        } else {
                            const motivos = [];
                            if (distancia >= 80) motivos.push('muito distante');
                            if (distanciaVertical >= 20) motivos.push('não alinhado');
                            if (hora < 0 || hora > 23 || min < 0 || min > 59) motivos.push('inválido');
                            console.log(`❌ Rejeitado: ${motivos.join(', ')}`);
                        }
                    }
                }
            }
            
            // Ordenar horários por posição (esquerda → direita, cima → baixo)
            horariosEncontrados.sort((a, b) => a.posicao - b.posicao);
            
            console.log(`📊 Total de horários válidos encontrados: ${horariosEncontrados.length}`);
            
            // Atribuir horários aos campos (máximo 6: ent1, sai1, ent2, sai2, ent3, sai3)
            const campos = ['ent1', 'sai1', 'ent2', 'sai2', 'ent3', 'sai3'];
            horariosEncontrados.slice(0, 6).forEach((h, index) => {
                if (campos[index]) {
                    dados[campos[index]] = h.horario;
                    dados.confidence[campos[index]] = Math.round(h.confidence);
                }
            });
            
            // EXTRAÇÃO DE MOTIVO COM DETECÇÃO DE CHECKBOX MARCADO
            const textoLower = texto.toLowerCase();
            const distanciaMax = 100;
            
            // Buscar marcações "X" com alta confiança
            const marcacoesX = palavrasFiltradas.filter(word => 
                /^[xX✓✔☑☒]$/.test(word.text) && word.confidence > 60
            );
            
            console.log(`✓ Marcações "X" encontradas (confiança > 60%): ${marcacoesX.length}`);
            
            // Lista de justificativas
            const justificativasMap = [
                { palavras: ['esquec', 'registr.*ponto'], motivo: 'Esqueceu de registrar o Ponto' },
                { palavras: ['falha.*app', 'app'], motivo: 'Falha no App' },
                { palavras: ['falta'], motivo: 'Falta' },
                { palavras: ['folga'], motivo: 'Folga' },
                { palavras: ['hora.*parada', 'parada'], motivo: 'Hora Parada' },
                { palavras: ['maquina.*defeito', 'máquina.*defeito', 'defeito'], motivo: 'Maquina Ponto com defeito' },
                { palavras: ['duplicidade', 'duplicado'], motivo: 'Registro em duplicidade' },
                { palavras: ['indevido'], motivo: 'Registro indevido' }
            ];
            
            let motivoDetectado = null;
            let menorDistancia = Infinity;
            let confidenciaMotivo = 0;
            
            justificativasMap.forEach(item => {
                item.palavras.forEach(palavra => {
                    const regex = new RegExp(palavra, 'i');
                    const match = textoLower.search(regex);
                    
                    if (match !== -1) {
                        // Procurar "X" próximo
                        marcacoesX.forEach(xWord => {
                            const dist = Math.abs(xWord.bbox.x0 - match);
                            if (dist < distanciaMax && dist < menorDistancia) {
                                menorDistancia = dist;
                                motivoDetectado = item.motivo;
                                confidenciaMotivo = Math.round(xWord.confidence);
                                console.log(`✅ Motivo detectado: "${item.motivo}" (confiança: ${confidenciaMotivo}%, distância: ${dist})`);
                            }
                        });
                    }
                });
            });
            
            dados.motivo = motivoDetectado;
            dados.confidence.motivo = confidenciaMotivo;
            
            console.log('📝 Extração finalizada:', dados);
            return dados;
        }
        */

        // Extrair horários e motivo do texto OCR (FUNÇÃO ANTIGA - MANTER COMO FALLBACK)
        function extrairDadosOCR(texto) {
            console.log('📄 Texto OCR completo:', texto);
            
            const dados = {
                ent1: null,
                sai1: null,
                ent2: null,
                sai2: null,
                ent3: null,
                sai3: null,
                ent4: null,
                sai4: null,
                ent5: null,
                sai5: null,
                motivo: null
            };
            
            // MELHORAR DETECÇÃO DE HORÁRIOS
            // Procurar múltiplos padrões
            const horariosEncontrados = [];
            
            // Padrão 1: HH:MM ou HH MM (com separador)
            const regex1 = /\b(\d{1,2})\s*[:\s]\s*(\d{2})\b/g;
            let match;
            
            while ((match = regex1.exec(texto)) !== null) {
                let hora = parseInt(match[1]);
                let min = parseInt(match[2]);
                
                if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                    horariosEncontrados.push({
                        hora: match[1].padStart(2, '0'),
                        min: match[2].padStart(2, '0'),
                        original: match[0],
                        posicao: match.index,
                        tipo: 'separado'
                    });
                }
            }
            
            // Padrão 2: HHMM (4 dígitos juntos) - NOVO!
            const regex2 = /\b(\d{4})\b/g;
            
            while ((match = regex2.exec(texto)) !== null) {
                const valor = match[1];
                const hora = parseInt(valor.substring(0, 2));
                const min = parseInt(valor.substring(2, 4));
                
                console.log(`🔍 Padrão2 encontrado: "${valor}" → Hora=${hora}, Min=${min}`);
                
                // FILTROS DE VALIDAÇÃO
                // 1. Validar se pode ser horário
                if (hora < 0 || hora > 23 || min < 0 || min > 59) {
                    console.log(`   ❌ Rejeitado: horário inválido (hora ${hora}, min ${min})`);
                    continue;
                }
                
                // 2. Ignorar anos (2024, 2025, etc)
                if (parseInt(valor) >= 2000 && parseInt(valor) <= 2100) {
                    console.log(`   ❌ Rejeitado: parece ano (${valor})`);
                    continue;
                }
                
                // 3. Ignorar se vier depois de "Data:" ou "/" (contexto de data)
                const contextoAntes = texto.substring(Math.max(0, match.index - 20), match.index);
                if (/data:\s*\d+\/\d+\/$/i.test(contextoAntes)) {
                    console.log(`   ❌ Rejeitado: contexto de data (${contextoAntes})`);
                    continue;
                }
                if (/\/\d+\/$/i.test(contextoAntes)) {
                    console.log(`   ❌ Rejeitado: contexto de barra (${contextoAntes})`);
                    continue;
                }
                
                const horarioStr = `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                
                // Não adicionar se já existe (evitar duplicata)
                const jaExiste = horariosEncontrados.find(h => `${h.hora}:${h.min}` === horarioStr);
                
                if (!jaExiste) {
                    console.log(`   ✅ Aceito: ${horarioStr}`);
                    horariosEncontrados.push({
                        hora: hora.toString().padStart(2, '0'),
                        min: min.toString().padStart(2, '0'),
                        original: match[0],
                        posicao: match.index,
                        tipo: '4digitos'
                    });
                } else {
                    console.log(`   ⚠️ Duplicado: ${horarioStr}`);
                }
            }
            
            // Ordenar por posição no texto
            horariosEncontrados.sort((a, b) => a.posicao - b.posicao);
            
            console.log('⏰ Horários detectados:', horariosEncontrados);
            
            // Filtrar duplicatas por valor
            const horariosLimpos = [];
            horariosEncontrados.forEach(h => {
                const horarioStr = `${h.hora}:${h.min}`;
                if (!horariosLimpos.find(hl => hl === horarioStr)) {
                    horariosLimpos.push(horarioStr);
                }
            });
            
            console.log('⏰ Horários únicos:', horariosLimpos);
            
            // Atribuir horários detectados
            if (horariosLimpos.length >= 1) dados.ent1 = horariosLimpos[0];
            if (horariosLimpos.length >= 2) dados.sai1 = horariosLimpos[1];
            if (horariosLimpos.length >= 3) dados.ent2 = horariosLimpos[2];
            if (horariosLimpos.length >= 4) dados.sai2 = horariosLimpos[3];
            if (horariosLimpos.length >= 5) dados.ent3 = horariosLimpos[4];
            if (horariosLimpos.length >= 6) dados.sai3 = horariosLimpos[5];
            
            // DETECTAR MOTIVO com múltiplas estratégias
            const textoLower = texto.toLowerCase();
            
            // 1. Procurar por "X" ou marcações próximo às palavras-chave
            const distanciaMax = 100; // aumentado para captar melhor
            
            // Lista de palavras-chave para cada justificativa
            const justificativasMap = [
                { palavras: ['esquec', 'registr.*ponto'], motivo: 'Esqueceu de registrar o Ponto' },
                { palavras: ['falha.*app', 'app'], motivo: 'Falha no App' },
                { palavras: ['falta'], motivo: 'Falta' },
                { palavras: ['folga'], motivo: 'Folga' },
                { palavras: ['hora.*parada', 'parada'], motivo: 'Hora Parada' },
                { palavras: ['maquina.*defeito', 'máquina.*defeito', 'defeito'], motivo: 'Maquina Ponto com defeito' },
                { palavras: ['duplicidade', 'duplicado'], motivo: 'Registro em duplicidade' },
                { palavras: ['indevido'], motivo: 'Registro indevido' }
            ];
            
            // Procurar "X", checkboxes marcados, ou qualquer símbolo de marcação
            // Melhorado para captar mais variações
            const regexX = /\b[xX✓✔☑☒]\b|\\[xX\\]|\(\\s*[xX]\\s*\)|\[[xX]\]/g;
            const xMatches = [];
            let xMatch;
            while ((xMatch = regexX.exec(texto)) !== null) {
                xMatches.push(xMatch.index);
            }
            
            console.log('✓ Marcações "X" encontradas em:', xMatches);
            
            // Verificar qual opção tem "X" mais próximo
            let motivoDetectado = null;
            let menorDistancia = Infinity;
            
            justificativasMap.forEach(item => {
                item.palavras.forEach(palavra => {
                    const regex = new RegExp(palavra, 'i');
                    const match = textoLower.search(regex);
                    
                    if (match !== -1) {
                        xMatches.forEach(xPos => {
                            const dist = Math.abs(xPos - match);
                            if (dist < distanciaMax && dist < menorDistancia) {
                                menorDistancia = dist;
                                motivoDetectado = item.motivo;
                                console.log(`✅ Motivo detectado: "${item.motivo}" (distância: ${dist} do "X")`);
                                console.log(`✅ Motivo detectado: "${item.motivo}" (distância: ${dist} do "X")`);
                            }
                        });
                    }
                });
            });
            
            dados.motivo = motivoDetectado;
            console.log('📝 Motivo detectado:', motivoDetectado);
            
            return dados;
        }
        
        // 🆕 Mostrar resultado do OCR COM INDICADORES DE CONFIANÇA
        function mostrarResultadoOCR(dados) {
            // Função auxiliar para cor do indicador baseado na confiança
            const getConfidenceColor = (confidence) => {
                if (confidence >= 80) return '#10b981'; // Verde
                if (confidence >= 60) return '#f59e0b'; // Amarelo
                return '#ef4444'; // Vermelho
            };
            
            const getConfidenceBadge = (confidence, label) => {
                if (!confidence || confidence === 0) return '';
                const color = getConfidenceColor(confidence);
                return `<span style="display: inline-block; margin-left: 8px; padding: 2px 8px; background: ${color}; color: white; border-radius: 12px; font-size: 10px; font-weight: 600;">${confidence}%</span>`;
            };
            
            // 🔒 BUSCAR HORÁRIOS JÁ BATIDOS do funcionário
            const horariosJaBatidos = {
                ent1: currentAnexoEmployee?.punches?.ent1 || currentAnexoEmployee?.ent1,
                sai1: currentAnexoEmployee?.punches?.sai1 || currentAnexoEmployee?.sai1,
                ent2: currentAnexoEmployee?.punches?.ent2 || currentAnexoEmployee?.ent2,
                sai2: currentAnexoEmployee?.punches?.sai2 || currentAnexoEmployee?.sai2,
                ent3: currentAnexoEmployee?.punches?.ent3 || currentAnexoEmployee?.ent3,
                sai3: currentAnexoEmployee?.punches?.sai3 || currentAnexoEmployee?.sai3
            };
            
            console.log('🔒 Horários já batidos:', horariosJaBatidos);
            
            // Função para criar campo (bloqueado se já batido, editável se vazio)
            const criarCampo = (id, label, valorOCR, valorJaBatido, confidence) => {
                const jaBatido = valorJaBatido && valorJaBatido !== '--:--';
                const valor = jaBatido ? valorJaBatido : (valorOCR || '');
                const bloqueado = jaBatido ? 'disabled' : '';
                const corBorda = jaBatido ? '#94a3b8' : getConfidenceColor(confidence || 0);
                const bgColor = jaBatido ? '#f1f5f9' : 'white';
                const badge = jaBatido ? '<span style="display: inline-block; margin-left: 8px; padding: 2px 8px; background: #64748b; color: white; border-radius: 12px; font-size: 10px; font-weight: 600;">🔒 JÁ BATIDO</span>' : getConfidenceBadge(confidence, label);
                
                return `
                    <div>
                        <label style="font-size: 12px; color: #065f46; font-weight: 500;">
                            ${label}: ${badge}
                        </label>
                        <input type="time" id="${id}" value="${valor}" ${bloqueado}
                               style="width: 100%; padding: 6px; border: 2px solid ${corBorda}; border-radius: 4px; background: ${bgColor}; cursor: ${jaBatido ? 'not-allowed' : 'text'};">
                    </div>
                `;
            };
            
            let html = `
                <div style="margin-bottom: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div style="padding: 12px; background: ${dados.assinaturaFuncionario ? '#dbeafe' : '#fee2e2'}; border-left: 4px solid ${dados.assinaturaFuncionario ? '#3b82f6' : '#ef4444'}; border-radius: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;">${dados.assinaturaFuncionario ? '✅' : '❌'}</span>
                            <div>
                                <div style="font-weight: 600; color: ${dados.assinaturaFuncionario ? '#1e40af' : '#991b1b'}; font-size: 14px;">
                                    👤 Funcionário
                                </div>
                                <div style="font-size: 11px; color: ${dados.assinaturaFuncionario ? '#1e40af' : '#b91c1c'}; margin-top: 2px;">
                                    ${dados.assinaturaFuncionario ? 'ASSINADO' : 'NÃO ASSINADO'}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="padding: 12px; background: ${dados.assinaturaLider ? '#d1fae5' : '#fee2e2'}; border-left: 4px solid ${dados.assinaturaLider ? '#10b981' : '#ef4444'}; border-radius: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;">${dados.assinaturaLider ? '✅' : '❌'}</span>
                            <div>
                                <div style="font-weight: 600; color: ${dados.assinaturaLider ? '#065f46' : '#991b1b'}; font-size: 14px;">
                                    👔 Líder
                                </div>
                                <div style="font-size: 11px; color: ${dados.assinaturaLider ? '#047857' : '#b91c1c'}; margin-top: 2px;">
                                    ${dados.assinaturaLider ? 'ASSINADO' : 'NÃO ASSINADO'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 16px;">
                    <label style="display: block; font-weight: 600; color: #065f46; margin-bottom: 8px;">
                        📝 Motivo: ${getConfidenceBadge(dados.confidence?.motivo, 'Motivo')}
                    </label>
                    <select id="ocrMotivo" style="width: 100%; padding: 8px; border: 2px solid ${getConfidenceColor(dados.confidence?.motivo || 0)}; border-radius: 6px; font-size: 14px;">
                        <option value="">-- Selecione --</option>
                        <option value="Esqueceu de registrar o Ponto" ${dados.motivo === 'Esqueceu de registrar o Ponto' ? 'selected' : ''}>Esqueceu de registrar o Ponto</option>
                        <option value="Falha no App" ${dados.motivo === 'Falha no App' ? 'selected' : ''}>Falha no App</option>
                        <option value="Falta" ${dados.motivo === 'Falta' ? 'selected' : ''}>Falta</option>
                        <option value="Folga" ${dados.motivo === 'Folga' ? 'selected' : ''}>Folga</option>
                        <option value="Hora Parada" ${dados.motivo === 'Hora Parada' ? 'selected' : ''}>Hora Parada</option>
                        <option value="Maquina Ponto com defeito" ${dados.motivo === 'Maquina Ponto com defeito' ? 'selected' : ''}>Maquina Ponto com defeito</option>
                        <option value="Registro em duplicidade" ${dados.motivo === 'Registro em duplicidade' ? 'selected' : ''}>Registro em duplicidade</option>
                        <option value="Registro indevido" ${dados.motivo === 'Registro indevido' ? 'selected' : ''}>Registro indevido</option>
                    </select>
                </div>
                
                <div style="margin-bottom: 8px;">
                    <label style="display: block; font-weight: 600; color: #065f46; margin-bottom: 8px;">⏰ Horários (corrija se necessário):</label>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    ${criarCampo('ocrEnt1', 'Entrada 1', dados.ent1, horariosJaBatidos.ent1, dados.confidence?.ent1)}
                    ${criarCampo('ocrSai1', 'Saída 1', dados.sai1, horariosJaBatidos.sai1, dados.confidence?.sai1)}
                    ${criarCampo('ocrEnt2', 'Entrada 2', dados.ent2, horariosJaBatidos.ent2, dados.confidence?.ent2)}
                    ${criarCampo('ocrSai2', 'Saída 2', dados.sai2, horariosJaBatidos.sai2, dados.confidence?.sai2)}
                    ${criarCampo('ocrEnt3', 'Entrada 3', dados.ent3, horariosJaBatidos.ent3, dados.confidence?.ent3)}
                    ${criarCampo('ocrSai3', 'Saída 3', dados.sai3, horariosJaBatidos.sai3, dados.confidence?.sai3)}
                </div>
                
                <div style="margin-top: 12px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 4px;">
                    <div style="font-size: 12px; color: #1e40af; line-height: 1.5;">
                        <strong>🎯 Indicadores:</strong><br>
                        <span style="color: #64748b;">🔒</span> Cinza: Horário já batido (bloqueado)<br>
                        <span style="color: #10b981;">●</span> Verde (≥80%): Alta confiança<br>
                        <span style="color: #f59e0b;">●</span> Amarelo (60-80%): Média confiança - revisar<br>
                        <span style="color: #ef4444;">●</span> Vermelho (<60%): Baixa confiança - corrigir
                    </div>
                </div>
            `;
            
            document.getElementById('ocrResultContent').innerHTML = html;
            document.getElementById('ocrResult').style.display = 'block';
        }
        
        // Confirmar e enviar anexo
        async function confirmarAnexo() {
            if (!currentAnexoEmployee || !currentAnexoImage) {
                alert('❌ Erro: Nenhuma imagem selecionada');
                return;
            }
            
            // ✍️ VALIDAR ASSINATURAS ANTES DE ENVIAR
            if (currentOCRData && (currentOCRData.assinaturaFuncionario === false || currentOCRData.assinaturaLider === false)) {
                const faltantes = [];
                if (!currentOCRData.assinaturaFuncionario) faltantes.push('👤 Funcionário');
                if (!currentOCRData.assinaturaLider) faltantes.push('👔 Líder');
                
                const confirmar = confirm(
                    `⚠️ ASSINATURAS FALTANDO\n\n` +
                    `As seguintes assinaturas não foram detectadas:\n${faltantes.join('\n')}\n\n` +
                    `Deseja prosseguir mesmo assim?\n\n` +
                    `✅ OK = Aceitar sem assinatura\n` +
                    `❌ Cancelar = Não enviar`
                );
                
                if (!confirmar) {
                    console.log('❌ Usuário cancelou envio por falta de assinaturas');
                    return;
                }
                
                console.log('⚠️ Usuário aceitou enviar sem assinaturas completas');
            }
            
            const btn = document.getElementById('btnConfirmarAnexo');
            btn.disabled = true;
            btn.textContent = 'Enviando...';
            
            try {
                // LER VALORES EDITADOS PELO USUÁRIO
                const motivoEditado = document.getElementById('ocrMotivo')?.value || '';
                const ent1 = document.getElementById('ocrEnt1')?.value || '';
                const sai1 = document.getElementById('ocrSai1')?.value || '';
                const ent2 = document.getElementById('ocrEnt2')?.value || '';
                const sai2 = document.getElementById('ocrSai2')?.value || '';
                const ent3 = document.getElementById('ocrEnt3')?.value || '';
                const sai3 = document.getElementById('ocrSai3')?.value || '';
                
                // Atualizar currentOCRData com valores editados
                currentOCRData = {
                    motivo: motivoEditado,
                    ent1: ent1,
                    sai1: sai1,
                    ent2: ent2,
                    sai2: sai2,
                    ent3: ent3,
                    sai3: sai3
                };
                
                console.log('📝 Dados finais (editados pelo usuário):', currentOCRData);
                
                // 🔑 USAR SEMPRE A DATA DA TABELA, IGNORAR rawData.Data
                let dataFormatted = currentAnexoEmployee.date;
                
                console.log(`📅 Data da TABELA (USANDO ESTA): ${currentAnexoEmployee.date}`);
                console.log(`📅 Data da API rawData (IGNORANDO): ${currentAnexoEmployee.rawData?.Data}`);
                
                // Formato estranho da API: 28T00:00:00/10/2025 -> 2025-10-28
                const strangeMatch = dataFormatted.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
                if (strangeMatch) {
                    const dia = strangeMatch[1].padStart(2, '0');
                    const mes = strangeMatch[2].padStart(2, '0');
                    const ano = strangeMatch[3];
                    dataFormatted = `${ano}-${mes}-${dia}`;
                    console.log(`� Formato estranho detectado, convertido para: ${dataFormatted}`);
                } else if (dataFormatted.includes('T')) {
                    // Formato ISO: 2025-10-28T00:00:00
                    dataFormatted = dataFormatted.split('T')[0];
                } else if (dataFormatted.includes('/')) {
                    // Formato BR: 28/10/2025 -> 2025-10-28
                    const parts = dataFormatted.split('/');
                    if (parts.length === 3) {
                        dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                        console.log(`🔧 Formato BR detectado, convertido para: ${dataFormatted}`);
                    }
                }
                
                console.log(`📅 Data formatada final para envio: ${dataFormatted}`);
                
                // Preparar dados (usando CPF + DATA como chave única)
                const payload = {
                    cpf: currentAnexoEmployee.cpf,  // ✅ CPF como identificador único
                    reg: currentAnexoEmployee.reg,
                    data: dataFormatted,
                    empresa_id: currentAnexoEmployee.empresaId || currentAnexoEmployee.companyId,
                    empresa_nome: currentAnexoEmployee.city,
                    funcionario_nome: currentAnexoEmployee.name,
                    imageBase64: currentAnexoImage,
                    motivo: currentOCRData.motivo,
                    horarios: currentOCRData,
                    ocr_texto: JSON.stringify(currentOCRData),
                    perguntas_rh: JSON.stringify(currentAnexoEmployee.questions || {})
                };
                
                console.log('📤 Enviando anexo com data:', payload.data);
                
                // Upload pro servidor (Azure Blob + SQL)
                // O servidor fará UPDATE automaticamente se registro já existir (REG+DATA+EMPRESA_ID)
                const response = await fetch(`${API_BASE_URL}/api/anexos/upload`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('✅ Anexo salvo:', result);
                    
                    // BUSCAR a referência correta do funcionário em allEmployees
                    const dataFormatada = currentAnexoEmployee.rawData?.Data?.split('T')[0] || currentAnexoEmployee.date;
                    const empRef = allEmployees.find(e => 
                        e.reg === currentAnexoEmployee.reg && 
                        (e.rawData?.Data?.split('T')[0] === dataFormatada || e.date === dataFormatada)
                    );
                    
                    if (empRef) {
                        // Atualizar referência com anexo
                        empRef.anexoUrl = result.blobUrl;
                        empRef.motivo = result.motivo || empRef.motivo;
                        empRef.attachments = [result.filename];
                        empRef.id = empRef.id || currentAnexoEmployee.id; // Manter ID
                        
                        // PREENCHER OS CAMPOS NA TABELA
                        empRef.punches.ent1 = currentOCRData.ent1 || empRef.punches.ent1;
                        empRef.punches.sai1 = currentOCRData.sai1 || empRef.punches.sai1;
                        empRef.punches.ent2 = currentOCRData.ent2 || empRef.punches.ent2;
                        empRef.punches.sai2 = currentOCRData.sai2 || empRef.punches.sai2;
                        empRef.punches.ent3 = currentOCRData.ent3 || empRef.punches.ent3;
                        empRef.punches.sai3 = currentOCRData.sai3 || empRef.punches.sai3;
                        
                        // NÃO marcar como pendingOCR (vamos enviar direto)
                        empRef.ocrData = currentOCRData;
                        
                        console.log('📝 Campos preenchidos na tabela');
                        console.log('   Ent1:', empRef.punches.ent1, 'Sai1:', empRef.punches.sai1);
                        console.log('   Ent2:', empRef.punches.ent2, 'Sai2:', empRef.punches.sai2);
                        console.log('   Ent3:', empRef.punches.ent3, 'Sai3:', empRef.punches.sai3);
                        
                        // Re-renderizar tabela
                        renderTable();
                        
                        // FECHAR MODAL PRIMEIRO
                        fecharModalAnexo();
                        
                        // 🚀 ENVIAR AUTOMATICAMENTE PARA SECULLUM (SEM CHECKBOX)
                        console.log('🚀 Enviando automaticamente para Secullum...');
                        showLoading('Enviando para Secullum...');
                        
                        try {
                            await enviarParaSecullum(empRef, true); // true = autoEnvio sem popup
                            
                            hideLoading();
                            
                            // Montar string de horários enviados (usar empRef.punches que é garantido)
                            const horariosStr = [
                                empRef.punches?.ent1, 
                                empRef.punches?.sai1, 
                                empRef.punches?.ent2, 
                                empRef.punches?.sai2, 
                                empRef.punches?.ent3, 
                                empRef.punches?.sai3
                            ].filter(h => h).join(', ');
                            
                            showAlert(
                                'Sucesso!',
                                `✅ Anexo salvo e horários enviados para Secullum!\n\n` +
                                `📎 Arquivo: ${result.filename}\n` +
                                `📝 Motivo: ${result.motivo || 'Não detectado'}\n` +
                                `⏰ Horários: ${horariosStr}`,
                                'success'
                            );
                            
                        } catch (err) {
                            hideLoading();
                            console.error('❌ Erro ao enviar para Secullum:', err);
                            showAlert('Erro', `Anexo salvo mas erro ao enviar para Secullum:\n${err.message}`, 'error');
                        }
                    } else {
                        throw new Error('Funcionário não encontrado em allEmployees');
                    }
                } else {
                    throw new Error(result.error || 'Erro desconhecido');
                }
                
            } catch (err) {
                console.error('❌ Erro ao enviar anexo:', err);
                alert(`❌ Erro ao enviar anexo:\n${err.message}`);
            } finally {
                // ✅ Sempre resetar botão (sucesso ou erro)
                btn.disabled = false;
                btn.textContent = 'Confirmar Anexo';
            }
        }
        
        // Enviar horários OCR para Secullum (quando usuário clica no checkbox verde)
        async function enviarParaSecullum(empRef, autoEnvio = false) {
            console.log(`🚀 Enviando horários para Secullum: REG=${empRef.reg}, Data=${empRef.date}`);
            
            if (!empRef) {
                alert('❌ Erro: Funcionário não encontrado!');
                return;
            }
            
            // Se for inversão (pendingSwap), mostrar popup de confirmação
            if (empRef.pendingSwap && !autoEnvio) {
                if (!confirm(`✅ Confirmar envio para Secullum?\n\nFuncionário: ${empRef.name}\nData: ${empRef.date}\n\nHorários:\n` +
                             `Ent1: ${empRef.punches?.ent1 || '--:--'} | Sai1: ${empRef.punches?.sai1 || '--:--'}\n` +
                             `Ent2: ${empRef.punches?.ent2 || '--:--'} | Sai2: ${empRef.punches?.sai2 || '--:--'}\n` +
                             `Ent3: ${empRef.punches?.ent3 || '--:--'} | Sai3: ${empRef.punches?.sai3 || '--:--'}`)) {
                    return;
                }
            }
            
            showLoading('Enviando para Secullum...');
            
            try {
                let sucessos = 0;
                let erros = 0;
                let periodoEncerrado = false;
                
                // Se há inversões pendentes, enviar TODOS os horários (com valores já trocados localmente)
                if (empRef.pendingSwap) {
                    console.log('🔄 Enviando horários invertidos para Secullum...');
                    
                    const funcionarioId = empRef.rawData?.FuncionarioId || empRef.dadosCompletos?.FuncionarioId;
                    const numeroFolha = empRef.rawData?.Funcionario?.NumeroFolha || empRef.NumeroFolha;
                    
                    if (!funcionarioId || !numeroFolha) {
                        throw new Error('Dados do funcionário não encontrados!');
                    }
                    
                    // Enviar TODOS os horários atuais (que já estão invertidos localmente)
                    const horariosInvertidos = [
                        { coluna: 'Entrada1', hora: empRef.punches.ent1 },
                        { coluna: 'Saida1', hora: empRef.punches.sai1 },
                        { coluna: 'Entrada2', hora: empRef.punches.ent2 },
                        { coluna: 'Saida2', hora: empRef.punches.sai2 },
                        { coluna: 'Entrada3', hora: empRef.punches.ent3 },
                        { coluna: 'Saida3', hora: empRef.punches.sai3 },
                        { coluna: 'Entrada4', hora: empRef.punches.ent4 },
                        { coluna: 'Saida4', hora: empRef.punches.sai4 },
                        { coluna: 'Entrada5', hora: empRef.punches.ent5 },
                        { coluna: 'Saida5', hora: empRef.punches.sai5 }
                    ].filter(item => item.hora && item.hora !== '--:--');
                    
                    console.log('📤 Horários a enviar (já invertidos):', horariosInvertidos);
                    
                    for (const item of horariosInvertidos) {
                        try {
                            const payload = {
                                FuncionarioId: funcionarioId,
                                NumeroFolha: numeroFolha,
                                Data: empRef.rawData?.Data || empRef.date,
                                Coluna: item.coluna,
                                Hora: item.hora,
                                Motivo: 'Inversão de horários',
                                created_by: window.CURRENT_USER || 'Sistema'
                            };
                            
                            console.log(`📤 Enviando ${item.coluna}: ${item.hora}`);
                            
                            const apiResponse = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`, {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${API_CONFIG.token}`,
                                    'secullumidbancoselecionado': empRef.empresaId || empRef.companyId
                                },
                                body: JSON.stringify(payload)
                            });
                            
                            if (apiResponse.ok) {
                                sucessos++;
                                console.log(`✅ ${item.coluna} enviada: ${item.hora}`);
                            } else {
                                erros++;
                                const errorText = await apiResponse.text();
                                console.warn(`⚠️ Erro ao enviar ${item.coluna}: ${apiResponse.status} - ${errorText}`);
                            }
                            
                            // Aguardar 300ms entre requests
                            await new Promise(resolve => setTimeout(resolve, 300));
                            
                        } catch (err) {
                            erros++;
                            console.error(`❌ Erro ao enviar ${item.coluna}:`, err);
                        }
                    }
                    
                    // Limpar flags
                    empRef.swappedPunches = [];
                    empRef.pendingSwap = false;
                    
                } else {
                    // Envio normal (OCR)
                    console.log('📋 Verificando horários para envio...');
                    console.log('   empRef.ent1:', empRef.ent1);
                    console.log('   empRef.punches.ent1:', empRef.punches?.ent1);
                    console.log('   empRef.sai1:', empRef.sai1);
                    console.log('   empRef.punches.sai1:', empRef.punches?.sai1);
                    
                    const horariosParaEnviar = [
                        { coluna: 'Entrada1', hora: empRef.punches?.ent1 || empRef.ent1 },
                        { coluna: 'Saida1', hora: empRef.punches?.sai1 || empRef.sai1 },
                        { coluna: 'Entrada2', hora: empRef.punches?.ent2 || empRef.ent2 },
                        { coluna: 'Saida2', hora: empRef.punches?.sai2 || empRef.sai2 },
                        { coluna: 'Entrada3', hora: empRef.punches?.ent3 || empRef.ent3 },
                        { coluna: 'Saida3', hora: empRef.punches?.sai3 || empRef.sai3 }
                    ].filter(item => item.hora);
                    
                    const funcionarioId = empRef.rawData?.FuncionarioId || empRef.dadosCompletos?.FuncionarioId;
                    const numeroFolha = empRef.rawData?.Funcionario?.NumeroFolha || empRef.NumeroFolha;
                    
                    if (!funcionarioId) {
                        throw new Error('FuncionarioId não encontrado!');
                    }
                    
                    if (!numeroFolha) {
                        throw new Error('NumeroFolha não encontrado!');
                    }
                    
                    for (const item of horariosParaEnviar) {
                        try {
                            const payload = {
                                FuncionarioId: funcionarioId,
                                NumeroFolha: numeroFolha,
                                Data: empRef.rawData?.Data || empRef.date,
                                Coluna: item.coluna,
                                Hora: item.hora,
                                Motivo: empRef.motivo || 'Justificativa anexada via OCR',
                                created_by: window.CURRENT_USER || 'Sistema'
                            };
                            
                            console.log(`📤 Enviando ${item.coluna}: ${item.hora}`, payload);
                            
                            const apiResponse = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`, {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${API_CONFIG.token}`,
                                    'secullumidbancoselecionado': empRef.empresaId || empRef.companyId
                                },
                                body: JSON.stringify(payload)
                            });
                            
                            if (apiResponse.ok) {
                                sucessos++;
                                console.log(`✅ ${item.coluna} enviada: ${item.hora}`);
                            } else {
                                erros++;
                                const errorText = await apiResponse.text();
                                
                                if (errorText.includes('período encerrado') || errorText.includes('período fechado')) {
                                    periodoEncerrado = true;
                                    console.warn(`🔒 ${item.coluna}: Período encerrado`);
                                } else {
                                    console.warn(`⚠️ Erro ao enviar ${item.coluna}: ${apiResponse.status} - ${errorText}`);
                                }
                            }
                        } catch (err) {
                            erros++;
                            console.error(`❌ Erro ao enviar ${item.coluna}:`, err);
                        }
                    }
                    
                    // Remover flag pendingOCR
                    empRef.pendingOCR = false;
                }
                
                hideLoading();
                
                // Recarregar dados
                await searchPeriod();
                
                let mensagem = `📊 Envio concluído:\n✅ ${sucessos} horários enviados\n❌ ${erros} erros`;
                
                if (periodoEncerrado) {
                    mensagem += `\n\n🔒 ATENÇÃO: Período encerrado!\nEntre em contato com o RH.`;
                }
                
                alert(mensagem);
                
            } catch (err) {
                hideLoading();
                console.error('❌ Erro ao enviar para Secullum:', err);
                alert(`❌ Erro: ${err.message}`);
            }
        }
        
        // Remover anexo
        async function removeAttachment(reg, date) {
            if (!confirm('⚠️ Deseja realmente remover o anexo?')) return;
            
            try {
                const employee = allEmployees.find(emp => emp.reg === reg);
                if (!employee) return;
                
                // Buscar ID do anexo no SQL
                const response = await fetch(`${API_BASE_URL}/api/anexos/${reg}/${employee.rawData?.Data || date}`, {
                    headers: getAuthHeaders()
                });
                const anexo = await response.json();
                
                if (!anexo || anexo.error) {
                    throw new Error('Anexo não encontrado no servidor');
                }
                
                // Deletar do servidor
                const deleteResponse = await fetch(`${API_BASE_URL}/api/anexos/${anexo.id}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });
                
                const result = await deleteResponse.json();
                
                if (result.success) {
                    employee.anexoUrl = null;
                    employee.attachments = [];
                    employee.motivo = '';
                    
                    renderTable();
                    alert('✅ Anexo removido com sucesso!');
                } else {
                    throw new Error(result.error || 'Erro ao deletar');
                }
                
            } catch (err) {
                console.error('❌ Erro ao remover anexo:', err);
                alert(`❌ Erro ao remover anexo:\n${err.message}`);
            }
        }

        // Remover anexo (versão antiga - manter compatibilidade)
        function simulateOCR(filename) {
            return { time: '--:--', reason: 'Arquivo: ' + filename };
        }

        // Gerar formulário para um empregado
        // Gerar slots de horário SEMPRE com 4 batidas (2 entradas + 2 saídas)
        function generateTimeSlots(punches, questions = {}) {
            let html = '';
            
            // Coletar TODAS as batidas (entrada e saída) em ordem com seus tipos
            const todasBatidas = [
                { time: punches.ent1, type: 'ent1', label: 'Entrada 1' },
                { time: punches.sai1, type: 'sai1', label: 'Saída 1' },
                { time: punches.ent2, type: 'ent2', label: 'Entrada 2' },
                { time: punches.sai2, type: 'sai2', label: 'Saída 2' },
                { time: punches.ent3, type: 'ent3', label: 'Entrada 3' },
                { time: punches.sai3, type: 'sai3', label: 'Saída 3' },
                { time: punches.ent4, type: 'ent4', label: 'Entrada 4' },
                { time: punches.sai4, type: 'sai4', label: 'Saída 4' },
                { time: punches.ent5, type: 'ent5', label: 'Entrada 5' },
                { time: punches.sai5, type: 'sai5', label: 'Saída 5' }
            ].filter(p => p.time && p.time !== '--:--');
            
            const totalBatidas = todasBatidas.length;
            
            // Se tiver batidas ímpares (5, 7, 9...), adicionar um slot vazio para justificar
            const totalSlots = (totalBatidas % 2 === 1) ? totalBatidas + 1 : Math.max(totalBatidas, 4);
            
            // Gerar slots para todas as batidas reais
            for (let i = 0; i < totalBatidas; i++) {
                const question = questions[todasBatidas[i].type];
                html += generateTimeSlot(todasBatidas[i].time, todasBatidas[i].label, question);
            }
            
            // Se for ímpar, adicionar slot vazio para justificar o par
            if (totalBatidas % 2 === 1) {
                html += generateTimeSlot(null, null, null);
            }
            
            // Se tiver menos de 4 batidas (e for par), preencher até 4
            const slotsGerados = (totalBatidas % 2 === 1) ? totalBatidas + 1 : totalBatidas;
            if (slotsGerados < 4) {
                for (let i = slotsGerados; i < 4; i++) {
                    html += generateTimeSlot(null, null, null);
                }
            }
            
            return html;
        }

        function generateForm(emp, index, total) {
            return `
                <div class="form-page">
                    <div class="form-border">
                        <div class="form-header">
                            <div class="form-logo">
                                <div class="logo-circle">L</div>
                                <div class="logo-text">LARSIL</div>
                            </div>
                            <div class="form-title">PONTO MANUAL COMPLEMENTAR AO PONTO ELETRÔNICO</div>
                        </div>
                        
                        <div class="form-orientation">
                            <strong>Orientação:</strong> Preencha somente os horários que não conseguiu bater e marque a justificativa
                        </div>
                        
                        <div class="form-employee-data">
                            <div class="form-row">
                                <div class="form-field">
                                    <span class="form-field-label">Nome:</span>
                                    <span class="form-field-value" style="font-size: 18px;">${emp.name}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Cidade:</span>
                                    <span class="form-field-value">${emp.city}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Data:</span>
                                    <span class="form-field-value">${emp.date}</span>
                                </div>
                            </div>
                            <div class="form-row-2">
                                <div class="form-field">
                                    <span class="form-field-label">REG:</span>
                                    <span class="form-field-value">${emp.reg}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Projeto:</span>
                                    <span class="form-field-value">${emp.projeto || 'N/A'}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">ID IMP:</span>
                                    <span class="form-field-value">${index}</span>
                                </div>
                            </div>
                            <div style="font-size: 14px; color: #6b7280; margin-top: 4px;">(${emp.day})</div>
                        </div>
                        
                        <div class="section-header">HORÁRIOS (preencher somente os que faltaram)</div>
                        
                        <div class="form-times">
                            <div class="times-grid">
                                ${generateTimeSlots(emp.punches, emp.questions || {})}
                            </div>
                        </div>
                        
                        <div class="section-header">JUSTIFICATIVA (marque o motivo)</div>
                        
                        <div class="form-justification">
                            <div class="justification-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Esqueceu de registrar o Ponto</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Falha no App</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Falta</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Folga</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Hora Parada</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Maquina Ponto com defeito</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Registro em duplicidade</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Registro indevido</label>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-signatures">
                            <div class="signature-box left">
                                <div class="signature-space"></div>
                                <div class="signature-line">
                                    <div class="signature-name">${emp.name}</div>
                                    <div class="signature-label">Assinatura do funcionário</div>
                                </div>
                            </div>
                            <div class="signature-box right">
                                ${useDigitalSignature ? `
                                    <div class="digital-signature">Fabio Oliveira</div>
                                    <div class="signature-line">
                                        <div class="signature-name">FABIO OLIVEIRA</div>
                                        <div class="signature-label">Assinatura digital do líder</div>
                                    </div>
                                ` : `
                                    <div class="signature-space"></div>
                                    <div class="signature-line">
                                        <div class="signature-name">${emp.nomeLider || 'LÍDER NÃO INFORMADO'}</div>
                                        <div class="signature-label">Assinatura do líder</div>
                                    </div>
                                `}
                            </div>
                        </div>
                    </div>
                    <div class="form-footer">SECULLUM • 4573.1197</div>
                </div>
            `;
        }

        function generateTimeSlot(time, label = null, question = null) {
            if (time) {
                return `
                    <div class="time-slot" style="position: relative;">
                        ${question ? `
                            <div style="position: absolute; top: -8px; left: 0; right: 0; background: linear-gradient(135deg, #fb923c 0%, #f97316 100%); padding: 4px 6px; border-radius: 6px 6px 0 0; font-size: 9px; font-weight: 600; text-align: left; box-shadow: 0 2px 4px rgba(251, 146, 60, 0.3); color: #1f2937;">
                                <span style="font-weight: 700;">RH:</span> ${question}
                            </div>
                        ` : ''}
                        <div class="time-value present" style="${question ? 'margin-top: 12px;' : ''}">${time}</div>
                        <div class="time-status batido">BATIDO</div>
                        <div style="margin-top: 3px; font-size: 10px; display: flex; align-items: center;">
                            <input type="checkbox" id="anular_${time.replace(':', '')}" style="margin-right: 5px; width: 14px; height: 14px;">
                            <label for="anular_${time.replace(':', '')}" style="margin: 0; font-weight: normal;">ANULAR BATIDA</label>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="time-slot">
                        <div style="font-weight: 900; font-size: 14px; color: #000; margin-bottom: 8px; text-align: center; letter-spacing: 1px;">
                            ${label || 'HORÁRIO'}
                        </div>
                        <div class="time-value missing">__:__</div>
                    </div>
                `;
            }
        }

        // Event Listeners
        document.getElementById('btnFilter').addEventListener('click', () => {
            showOnlyInconsistencies = !showOnlyInconsistencies;
            const btn = document.getElementById('btnFilter');
            const text = document.getElementById('filterText');
            
            if (showOnlyInconsistencies) {
                btn.classList.add('active');
                text.textContent = 'Mostrando Só Inconsistências';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Mostrar Só Inconsistências';
            }
            
            renderTable();
        });

        // ==========================================
        // SISTEMA DE PERGUNTAS
        // ==========================================
        let currentQuestionContext = null;

        // 🔴 CORREÇÃO: Salvar perguntas no banco de dados (com merge de dados existentes)
        async function saveQuestionsToDB(employee, dateContext) {
            try {
                let dataFormatted = employee.anexoDate || dateContext;
                if (dataFormatted.includes('/')) {
                    const parts = dataFormatted.split('/');
                    dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                } else if (dataFormatted.includes('T')) {
                    dataFormatted = dataFormatted.split('T')[0];
                }
                
                console.log(`💾 Salvando perguntas: ${employee.name} (${dataFormatted})`);
                
                // 🔑 1. BUSCAR dados existentes primeiro
                let existingData = {};
                try {
                    const fetchResponse = await fetch(
                        `${API_BASE_URL}/api/anexos/${dataFormatted}/${employee.empresaId || employee.rawData?.Empresa || 0}`,
                        { headers: getAuthHeaders() }
                    );
                    
                    if (fetchResponse.ok) {
                        const anexos = await fetchResponse.json();
                        const anexoExistente = anexos.find(a => 
                            a.cpf?.replace(/\D/g, '') === employee.cpf?.replace(/\D/g, '')
                        );
                        if (anexoExistente?.perguntas_rh) {
                            existingData = JSON.parse(anexoExistente.perguntas_rh);
                            console.log(`📋 Dados existentes:`, existingData);
                        }
                    }
                } catch (err) {
                    console.warn('⚠️ Não foi possível buscar dados existentes');
                }
                
                // 🔑 2. MESCLAR dados antigos + novos
                const mergedData = {
                    ...existingData,
                    ...employee.questions,
                    ...employee.approved
                };
                
                console.log(`💾 Dados mesclados a salvar:`, mergedData);
                
                // 🔑 3. SALVAR
                const response = await fetch(
                    `${API_BASE_URL}/api/anexos/${employee.cpf}/${dataFormatted}/questions`,
                    {
                        method: 'PUT',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            perguntas_rh: JSON.stringify(mergedData),
                            reg: employee.reg,
                            empresa_id: employee.empresaId || employee.rawData?.Empresa || 0,
                            empresa_nome: employee.city || employee.rawData?.['Empresa Nome'] || 'N/A',
                            funcionario_nome: employee.name || 'N/A'
                        })
                    }
                );
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                console.log('✅ Perguntas salvas com sucesso');
                
            } catch (err) {
                console.error('❌ Erro ao salvar perguntas:', err);
                showAlert('Erro', `Não foi possível salvar: ${err.message}`, 'error');
            }
        }

        // Salvar aprovação de horário trocado no banco
        async function saveApprovalToDB(employee, dateContext, punchType, approvalComment) {
            try {
                // Mesma lógica de formatação de data
                let dataFormatted = null;
                
                if (employee.anexoDate) {
                    dataFormatted = employee.anexoDate;
                } else if (dateContext) {
                    if (dateContext.includes('/')) {
                        const parts = dateContext.split('/');
                        dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                    } else {
                        dataFormatted = dateContext.split('T')[0];
                    }
                } else {
                    dataFormatted = employee.rawData?.Data 
                        ? employee.rawData.Data.split('T')[0] 
                        : employee.date.split('T')[0];
                }
                
                console.log(`✅ Salvando aprovação: ${employee.name} (CPF: ${employee.cpf}, Data: ${dataFormatted}, ${punchType})`);
                
                // 🔑 BUSCAR DADOS EXISTENTES DO BANCO PRIMEIRO
                let existingData = {};
                try {
                    const fetchResponse = await fetch(`${API_BASE_URL}/api/anexos/${dataFormatted}/${employee.rawData?.Empresa || 0}`, {
                        headers: getAuthHeaders()
                    });
                    if (fetchResponse.ok) {
                        const anexos = await fetchResponse.json();
                        const anexoExistente = anexos.find(a => 
                            a.cpf?.replace(/\D/g, '') === employee.cpf?.replace(/\D/g, '')
                        );
                        if (anexoExistente && anexoExistente.perguntas_rh) {
                            existingData = JSON.parse(anexoExistente.perguntas_rh);
                            console.log(`📋 Dados existentes encontrados:`, existingData);
                        }
                    }
                } catch (err) {
                    console.warn(`⚠️ Não foi possível buscar dados existentes:`, err);
                }
                
                // Mesclar TUDO: dados existentes + questions atuais + nova aprovação
                const approvedKey = `${punchType}_approved`;
                const mergedData = {
                    ...existingData,           // 1. Dados que já estavam no banco
                    ...employee.questions,     // 2. Perguntas atuais do objeto
                    ...employee.approved,      // 3. Aprovações atuais do objeto
                    [approvedKey]: approvalComment  // 4. Nova aprovação
                };
                
                console.log(`💾 Dados a salvar (mesclados):`, mergedData);
                
                const response = await fetch(`${API_BASE_URL}/api/anexos/${employee.cpf}/${dataFormatted}/questions`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        perguntas_rh: JSON.stringify(mergedData),
                        reg: employee.reg,
                        empresa_id: employee.rawData?.Empresa || 0,
                        empresa_nome: employee.rawData?.['Empresa Nome'] || 'N/A',
                        funcionario_nome: employee.name || 'N/A'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`✅ Aprovação salva:`, result);
                showAlert('Sucesso', `Horário ${punchType} aprovado para ${employee.name}!`, 'success');
                
            } catch (err) {
                console.error('❌ Erro ao salvar aprovação:', err);
                showAlert('Erro', `Não foi possível salvar a aprovação: ${err.message}`, 'error');
            }
        }

        function askQuestion(event, reg, date, punchType, name) {
            event.stopPropagation(); // Evitar duplo clique na célula
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) return;

            const punchTime = employee.punches[punchType] || '--:--';
            const punchLabel = {
                'ent1': 'Entrada 1',
                'sai1': 'Saída 1',
                'ent2': 'Entrada 2',
                'sai2': 'Saída 2',
                'ent3': 'Entrada 3',
                'sai3': 'Saída 3',
                'ent4': 'Entrada 4',
                'sai4': 'Saída 4',
                'ent5': 'Entrada 5',
                'sai5': 'Saída 5'
            }[punchType];

            // Armazenar contexto
            currentQuestionContext = { reg, date, punchType };

            // Atualizar modal
            document.getElementById('questionContext').textContent = 
                `${name} - ${punchLabel}: ${punchTime} (${date})`;
            
            // Limpar input anterior
            document.getElementById('questionInput').value = employee.questions?.[punchType] || '';

            // Mostrar modal
            document.getElementById('questionModal').classList.add('active');
            document.getElementById('questionInput').focus();
        }

        // Botão OK do modal
        document.getElementById('questionOkBtn').addEventListener('click', async () => {
            const question = document.getElementById('questionInput').value.trim();
            
            if (!question) {
                const msgType = currentQuestionContext?.isApproval ? 'motivo da aprovação' : 'pergunta';
                showAlert('Atenção', `Digite ${msgType} antes de confirmar!`, 'warning');
                return;
            }

            if (currentQuestionContext) {
                const { reg, date, punchType, isApproval } = currentQuestionContext;
                
                console.log(`🔍 Buscando funcionário: REG=${reg}, Data=${date}`);
                
                // 🔑 Buscar funcionário pela DATA E REG (não importa se tem anexo ou não)
                // Se tiver anexo, vai salvar. Se não tiver, vai avisar.
                let employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                
                if (!employee) {
                    console.warn(`⚠️ Funcionário não encontrado: REG=${reg}, Data=${date}`);
                    showAlert('Erro', 'Funcionário não encontrado para esta data.', 'error');
                    return;
                }
                
                console.log(`✅ Funcionário encontrado: ${employee.name} - Data: ${employee.date} - Anexo: ${employee.anexoUrl ? 'SIM' : 'NÃO'}`);
                
                if (employee) {
                    if (isApproval) {
                        // ✅ APROVAÇÃO DE HORÁRIO TROCADO
                        if (!employee.approved) {
                            employee.approved = {};
                        }
                        employee.approved[punchType] = question;
                        console.log(`✅ Horário aprovado: ${employee.name} - ${punchType} - "${question}"`);
                        
                        // Salvar aprovação no banco (aguardar para atualizar tabela depois)
                        await saveApprovalToDB(employee, date, punchType, question);
                    } else {
                        // ❓ PERGUNTA NORMAL DO RH
                        if (!employee.questions) {
                            employee.questions = {};
                        }
                        employee.questions[punchType] = question;
                        console.log(`✅ Pergunta adicionada: ${employee.name} - ${punchType} - "${question}"`);
                        
                        // Salvar pergunta no banco
                        await saveQuestionsToDB(employee, date);
                    }
                    
                    // Fechar modal
                    document.getElementById('questionModal').classList.remove('active');
                    
                    // Atualizar tabela (agora com dados salvos)
                    renderTable();
                }
            }
        });

        // Botão Cancelar do modal
        document.getElementById('questionCancelBtn').addEventListener('click', () => {
            document.getElementById('questionModal').classList.remove('active');
        });

        // Fechar modal ao clicar fora
        document.getElementById('questionModal').addEventListener('click', (e) => {
            if (e.target.id === 'questionModal') {
                document.getElementById('questionModal').classList.remove('active');
            }
        });

        // ==========================================
        // APROVAÇÃO DE HORÁRIOS TROCADOS
        // ==========================================
        function approveSwappedTime(event, reg, date, punchType, name) {
            event.stopPropagation();
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) return;

            const punchTime = employee.punches[punchType] || '--:--';
            const punchLabel = {
                'ent1': 'Entrada 1',
                'sai1': 'Saída 1',
                'ent2': 'Entrada 2',
                'sai2': 'Saída 2',
                'ent3': 'Entrada 3',
                'sai3': 'Saída 3',
                'ent4': 'Entrada 4',
                'sai4': 'Saída 4',
                'ent5': 'Entrada 5',
                'sai5': 'Saída 5'
            }[punchType];

            // Armazenar contexto
            currentQuestionContext = { reg, date, punchType, isApproval: true };

            // Atualizar modal com mensagem de aprovação
            document.getElementById('questionContext').textContent = 
                `⚠️ APROVAR HORÁRIO TROCADO\n${name} - ${punchLabel}: ${punchTime} (${date})`;
            
            // Limpar input
            document.getElementById('questionInput').value = '';
            document.getElementById('questionInput').placeholder = 'Digite o motivo da aprovação (ex: "Troca autorizada com colega")';

            // Mostrar modal
            document.getElementById('questionModal').classList.add('active');
            document.getElementById('questionInput').focus();
        }

        // Variável global para rastrear célula selecionada
        let selectedCell = null;

        // Mostrar setas de navegação ao clicar na célula (igual Secullum)
        function showSwapMenu(event, cell) {
            event.stopPropagation();
            
            // Remover setas antigas
            document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
            
            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punch = cell.dataset.punch;
            const name = cell.dataset.name;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee || !employee.punches[punch]) return;
            
            // Se já está selecionada, desselecionar
            if (selectedCell === cell) {
                cell.classList.remove('selected-cell');
                selectedCell = null;
                return;
            }
            
            // Remover seleção anterior
            if (selectedCell) {
                selectedCell.classList.remove('selected-cell');
            }
            
            // Marcar célula como selecionada
            cell.classList.add('selected-cell');
            selectedCell = cell;
            
            // Adicionar seta em TODAS as outras células com horário da MESMA LINHA
            const rowCells = document.querySelectorAll(`.punch-cell[data-reg="${reg}"][data-date="${date}"]`);
            
            rowCells.forEach(targetCell => {
                const targetPunch = targetCell.dataset.punch;
                
                // Ignorar a própria célula
                if (targetCell === cell) return;
                
                // Verificar se tem horário
                if (!employee.punches[targetPunch] || employee.punches[targetPunch] === '--:--') return;
                
                // Adicionar seta única no canto
                const arrow = document.createElement('span');
                arrow.className = 'swap-arrow';
                arrow.textContent = '↔';
                arrow.title = 'Trocar horários';
                arrow.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.swap-arrow').forEach(a => a.remove());
                    cell.classList.remove('selected-cell');
                    selectedCell = null;
                    swapPunches(e, reg, date, punch, targetPunch, name);
                };
                
                targetCell.appendChild(arrow);
            });
            
            // Remover setas ao clicar fora
            setTimeout(() => {
                function closeArrows(e) {
                    if (!e.target.closest('.punch-cell') && !e.target.classList.contains('swap-arrow')) {
                        document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
                        if (selectedCell) {
                            selectedCell.classList.remove('selected-cell');
                            selectedCell = null;
                        }
                        document.removeEventListener('click', closeArrows);
                    }
                }
                document.addEventListener('click', closeArrows);
            }, 100);
        }
        
        // Inverter batidas LOCALMENTE (não envia para API imediatamente)
        async function swapPunches(event, reg, date, punch1, punch2, name) {
            event.stopPropagation();
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'Funcionário não encontrado!', 'error');
                return;
            }

            const punch1Label = {
                'ent1': 'Entrada 1', 'sai1': 'Saída 1',
                'ent2': 'Entrada 2', 'sai2': 'Saída 2',
                'ent3': 'Entrada 3', 'sai3': 'Saída 3',
                'ent4': 'Entrada 4', 'sai4': 'Saída 4',
                'ent5': 'Entrada 5', 'sai5': 'Saída 5'
            }[punch1];

            const punch2Label = {
                'ent1': 'Entrada 1', 'sai1': 'Saída 1',
                'ent2': 'Entrada 2', 'sai2': 'Saída 2',
                'ent3': 'Entrada 3', 'sai3': 'Saída 3',
                'ent4': 'Entrada 4', 'sai4': 'Saída 4',
                'ent5': 'Entrada 5', 'sai5': 'Saída 5'
            }[punch2];

            const time1 = employee.punches[punch1] || '--:--';
            const time2 = employee.punches[punch2] || '--:--';

            const confirmed = confirm(
                `🔄 TEM CERTEZA QUE DESEJA INVERTER HORÁRIOS?\n\n` +
                `Funcionário: ${name}\n` +
                `Data: ${date}\n\n` +
                `${punch1Label}: ${time1} → ${time2}\n` +
                `${punch2Label}: ${time2} → ${time1}\n\n` +
                `⚠️ Esta ação enviará IMEDIATAMENTE para Secullum!`
            );

            if (!confirmed) {
                // Limpar seleção
                document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
                document.querySelectorAll('.selected-cell').forEach(cell => cell.classList.remove('selected-cell'));
                selectedCell = null;
                return;
            }

            try {
                // TROCAR OS HORÁRIOS LOCALMENTE
                const tempTime = employee.punches[punch1];
                employee.punches[punch1] = employee.punches[punch2];
                employee.punches[punch2] = tempTime;

                // Marcar como pendente de envio
                employee.pendingSwap = true;
                
                // Guardar informações da troca
                if (!employee.swappedPunches) {
                    employee.swappedPunches = [];
                }
                employee.swappedPunches.push({
                    punch1,
                    punch2,
                    time1: employee.punches[punch1], // novo valor
                    time2: employee.punches[punch2]  // novo valor
                });

                // Limpar seleção
                document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
                document.querySelectorAll('.selected-cell').forEach(cell => cell.classList.remove('selected-cell'));
                selectedCell = null;

                // Atualizar tabela visualmente
                renderTable();

                // ENVIAR IMEDIATAMENTE para Secullum
                await enviarParaSecullum(employee);

            } catch (error) {
                console.error('Erro ao inverter batidas:', error);
                showAlert(
                    'Erro ao Inverter',
                    `Não foi possível inverter as batidas:\n\n${error.message}`,
                    'error'
                );
            }
        }

        // ==========================================
        // MONITOR DE MÁQUINAS DE PONTO
        // ==========================================
        function openMachineMonitor() {
            // Abrir monitor.html em nova guia
            window.open('monitor.html', '_blank');
        }

        // PAINEL DE PRESENÇA
        function openPresencePanel() {
            // Abrir presenca.html em nova guia
            window.open('presenca.html', '_blank');
        }

        function closeMachineMonitor() {
            document.getElementById('machineMonitorModal').classList.remove('active');
        }

        function logout() {
            // Limpar todos os dados do localStorage
            localStorage.clear();
            sessionStorage.clear();
            
            // Redirecionar para login
            window.location.href = '/login.html';
        }

        async function refreshMachineMonitor() {
            try {
                showLoading('Consultando máquinas de todas as empresas...');
                
                // Definir quais bancos consultar
                let bancosParaConsultar = [];
                
                if (API_CONFIG.selectedCompanies.includes('all')) {
                    // Se "TODAS" selecionado, busca de TODAS as empresas
                    bancosParaConsultar = API_CONFIG.companies.map(c => c.id);
                } else {
                    // Senão, busca apenas das empresas selecionadas
                    bancosParaConsultar = API_CONFIG.selectedCompanies;
                }
                
                if (bancosParaConsultar.length === 0) {
                    alert('❌ Erro: Nenhuma empresa disponível!\n\nFaça login primeiro.');
                    hideLoading();
                    return;
                }
                
                // Buscar máquinas de todas as empresas em paralelo (SEM AUTENTICAÇÃO)
                const promises = bancosParaConsultar.map(bancoid => {
                    return fetch(`${API_BASE_URL}/api/machine-monitor?bancoid=${bancoid}`)
                        .then(async r => {
                            if (!r.ok) {
                                console.warn(`⚠️ Erro ao consultar banco ${bancoid}: HTTP ${r.status}`);
                                return [];
                            }
                            return r.json();
                        })
                        .catch(err => {
                            console.error(`❌ Erro ao consultar banco ${bancoid}:`, err);
                            return [];
                        });
                });
                
                const results = await Promise.all(promises);
                const machines = results.flat();
                
                const now = new Date();
                document.getElementById('monitorLastUpdate').textContent = now.toLocaleTimeString('pt-BR');
                
                const content = document.getElementById('machineMonitorContent');
                
                if (machines.length === 0) {
                    content.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">Nenhuma máquina encontrada</div>';
                    hideLoading();
                    return;
                }
                
                // Ordenar por última sincronização (mais recente primeiro)
                machines.sort((a, b) => {
                    const dateA = a.lastSync ? new Date(a.lastSync).getTime() : 0;
                    const dateB = b.lastSync ? new Date(b.lastSync).getTime() : 0;
                    return dateB - dateA; // DESC (mais recente primeiro)
                });
                
                // Tabela estilo lista limpa
                let html = `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 14px 16px; text-align: left; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">🖥️ EQUIPAMENTO</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">📅 ÚLTIMA SINC</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">📦 QTD BATIDAS</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">⏱️ HÁ QUANTO TEMPO</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">📊 STATUS</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                machines.forEach((machine, index) => {
                    // Verificar se lastSync é válido
                    let lastSync = null;
                    if (machine.lastSync && 
                        machine.lastSync !== 'Nunca sincronizado' && 
                        machine.lastSync !== 'Erro ao consultar' &&
                        !machine.lastSync.includes('Nunca') &&
                        !machine.lastSync.includes('Erro')) {
                        try {
                            lastSync = new Date(machine.lastSync);
                            // Validar se a data é válida
                            if (isNaN(lastSync.getTime())) {
                                lastSync = null;
                            }
                        } catch (e) {
                            lastSync = null;
                        }
                    }
                    
                    const diffMinutes = lastSync ? Math.floor((now - lastSync) / 60000) : 99999;
                    
                    let statusColor = '#10b981'; // Verde
                    let statusText = '✅ ONLINE';
                    let bgRow = index % 2 === 0 ? '#f8fafc' : 'white';
                    
                    if (!lastSync || diffMinutes > 60) {
                        statusColor = '#ef4444'; // Vermelho
                        statusText = '❌ OFFLINE';
                    } else if (diffMinutes > 30) {
                        statusColor = '#f59e0b'; // Amarelo
                        statusText = '⚠️ ALERTA';
                    }
                    
                    const tempoAtras = lastSync 
                        ? (diffMinutes < 1 ? 'Agora' : diffMinutes < 60 ? `${diffMinutes} min` : `${Math.floor(diffMinutes/60)}h ${diffMinutes%60}min`)
                        : 'Nunca';
                    
                    html += `
                        <tr style="background: ${bgRow}; border-bottom: 1px solid #e2e8f0; transition: all 0.2s;" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='${bgRow}'">
                            <td style="padding: 14px 16px; font-weight: 600; color: #1e293b; font-size: 14px;">
                                ${machine.name}
                                <div style="font-size: 11px; color: #94a3b8; font-weight: 400; margin-top: 2px;">
                                    🆔 ${machine.id} • 🌐 ${machine.ip || 'N/A'}
                                </div>
                            </td>
                            <td style="padding: 14px 16px; text-align: center; color: #475569; font-size: 13px;">
                                ${lastSync ? lastSync.toLocaleString('pt-BR', {day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'}) : '<span style="color: #94a3b8;">Sem dados</span>'}
                            </td>
                            <td style="padding: 14px 16px; text-align: center;">
                                <span style="background: ${machine.totalBatidas > 0 ? '#10b98120' : '#ef444420'}; color: ${machine.totalBatidas > 0 ? '#10b981' : '#ef4444'}; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 700;">
                                    ${machine.totalBatidas || 0} ${machine.lastSyncCount > 0 ? `(${machine.lastSyncCount} na última)` : ''}
                                </span>
                            </td>
                            <td style="padding: 14px 16px; text-align: center; color: ${statusColor}; font-weight: 700; font-size: 14px;">
                                ${tempoAtras}
                            </td>
                            <td style="padding: 14px 16px; text-align: center;">
                                <span style="background: ${statusColor}; color: white; padding: 6px 14px; border-radius: 20px; font-size: 11px; font-weight: 700; white-space: nowrap; display: inline-block;">
                                    ${statusText}
                                </span>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                content.innerHTML = html;
                
                hideLoading();
            } catch (err) {
                console.error('❌ Erro ao buscar máquinas:', err);
                showAlert('Erro', 'Não foi possível consultar as máquinas: ' + err.message, 'error');
                hideLoading();
            }
        }

        function exportMachineMonitor() {
            showAlert('Info', 'Use a captura de tela do Windows (Win + Shift + S) para tirar um print do monitor!', 'info');
        }

        // Fechar modal ao clicar fora
        document.getElementById('machineMonitorModal').addEventListener('click', (e) => {
            if (e.target.id === 'machineMonitorModal') {
                closeMachineMonitor();
            }
        });

        // ==========================================
        // DELETAR PONTO (CRUD)
        // ==========================================
        async function deletePunch(event, reg, date, punchType, columnName) {
            event.stopPropagation(); // Não abrir edição
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'Funcionário não encontrado', 'error');
                return;
            }
            
            const currentTime = employee.punches[punchType];
            if (!currentTime || currentTime === '--:--') {
                showAlert('Info', 'Não há ponto para apagar neste horário', 'info');
                return;
            }
            
            // Confirmar exclusão
            if (!confirm(`⚠️ Tem certeza que deseja APAGAR o ponto?\n\n${employee.name}\n${columnName}: ${currentTime}\nData: ${date}`)) {
                return;
            }
            
            try {
                showLoading('Apagando ponto...');
                
                // Converter data para formato ISO
                let dataFormatted = date;
                if (date.includes('/')) {
                    const parts = date.split('/');
                    dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                }
                if (dataFormatted.includes('T')) {
                    dataFormatted = dataFormatted.split('T')[0];
                }
                
                console.log(`🗑️ Apagando ${columnName}:`, {
                    NumeroFolha: reg,
                    Data: dataFormatted + 'T00:00:00',
                    Coluna: columnName,
                    Hora: '', // Vazio = DELETE
                    Motivo: 'Exclusão via sistema'
                });
                
                // Enviar para API Secullum (Hora vazia = DELETE)
                const response = await fetch('https://pontowebintegracaoexterna.secullum.com.br/IntegracaoExterna/CartaoPonto/Manual', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Token': secullumToken
                    },
                    body: JSON.stringify({
                        NumeroFolha: reg,
                        Data: dataFormatted + 'T00:00:00',
                        Coluna: columnName,
                        Hora: null, // NULL = DELETE na API Secullum
                        Motivo: 'Exclusão via sistema'
                    })
                });
                
                console.log(`📊 Status da resposta: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`❌ Erro:`, errorText);
                    throw new Error(`Erro ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log(`✅ Ponto apagado com sucesso:`, result);
                
                // Atualizar na memória
                employee.punches[punchType] = null;
                
                // Atualizar visualmente
                renderTable();
                
                hideLoading();
                showAlert('Sucesso', `Ponto ${columnName} apagado com sucesso!`, 'success');
                
            } catch (err) {
                console.error('❌ Erro ao apagar ponto:', err);
                hideLoading();
                showAlert('Erro', `Não foi possível apagar o ponto: ${err.message}`, 'error');
            }
        }

        // ==========================================
        // EDIÇÃO INLINE (Estilo Excel)
        // ==========================================
        let currentEditingCell = null;

        function startInlineEdit(cell) {
            // Se já está editando outra célula, cancela
            if (currentEditingCell && currentEditingCell !== cell) {
                cancelInlineEdit(currentEditingCell);
            }

            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punchType = cell.dataset.punch; // ent1, sai1, ent2, etc
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) return;

            // Valor atual
            const currentValue = employee.punches[punchType] || '';

            // Marcar célula como editando
            cell.classList.add('editing');
            currentEditingCell = cell;

            // Criar input
            const input = document.createElement('input');
            input.type = 'time';
            input.className = 'inline-input';
            input.value = currentValue;
            
            // Limpar célula e adicionar input
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();

            // Flag para evitar múltiplas chamadas
            let saving = false;

            // Função para salvar (evita duplicação)
            const save = () => {
                if (!saving) {
                    saving = true;
                    input.removeEventListener('blur', save);
                    saveInlineEdit(cell, reg, date, punchType, input.value);
                }
            };

            // Eventos do input
            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    save();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    saving = true; // Prevenir blur
                    input.removeEventListener('blur', save);
                    cancelInlineEdit(cell);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    saving = true; // Prevenir blur
                    input.removeEventListener('blur', save);
                    saveInlineEdit(cell, reg, date, punchType, input.value);
                    // Mover para próxima célula editável
                    const nextCell = e.shiftKey ? getPreviousEditableCell(cell) : getNextEditableCell(cell);
                    if (nextCell) {
                        setTimeout(() => startInlineEdit(nextCell), 100);
                    }
                }
            });
        }

        function getNextEditableCell(currentCell) {
            const row = currentCell.parentElement;
            const cells = Array.from(row.querySelectorAll('.editable-cell'));
            const currentIndex = cells.indexOf(currentCell);
            
            if (currentIndex < cells.length - 1) {
                return cells[currentIndex + 1];
            } else {
                // Próxima linha
                const nextRow = row.nextElementSibling;
                if (nextRow) {
                    return nextRow.querySelector('.editable-cell');
                }
            }
            return null;
        }

        function getPreviousEditableCell(currentCell) {
            const row = currentCell.parentElement;
            const cells = Array.from(row.querySelectorAll('.editable-cell'));
            const currentIndex = cells.indexOf(currentCell);
            
            if (currentIndex > 0) {
                return cells[currentIndex - 1];
            } else {
                // Linha anterior
                const prevRow = row.previousElementSibling;
                if (prevRow) {
                    const prevCells = prevRow.querySelectorAll('.editable-cell');
                    return prevCells[prevCells.length - 1];
                }
            }
            return null;
        }

        async function saveInlineEdit(cell, reg, date, punchType, newValue) {
            if (!currentEditingCell) return;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                cancelInlineEdit(cell);
                return;
            }

            // Se o valor não mudou, apenas cancela
            const oldValue = employee.punches[punchType] || '';
            if (newValue === oldValue) {
                cancelInlineEdit(cell);
                return;
            }

            // Mostrar feedback visual
            cell.classList.add('saving-cell');
            cell.classList.remove('editing');
            
            // Limpar completamente a célula antes de adicionar novo conteúdo
            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            
            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'punch-time present';
            loadingSpan.style.fontSize = '13px';
            loadingSpan.textContent = newValue || '--:--';
            cell.appendChild(loadingSpan);

            try {
                // Mapear tipo de punch para nome da coluna
                const colunaMap = {
                    'ent1': 'Entrada1',
                    'sai1': 'Saida1',
                    'ent2': 'Entrada2',
                    'sai2': 'Saida2',
                    'ent3': 'Entrada3',
                    'sai3': 'Saida3',
                    'ent4': 'Entrada4',
                    'sai4': 'Saida4',
                    'ent5': 'Entrada5',
                    'sai5': 'Saida5'
                };

                // Buscar dados completos do funcionário (igual no modal)
                const funcionarioId = employee.rawData?.FuncionarioId || employee.dadosCompletos?.FuncionarioId;
                const data = employee.rawData?.Data || employee.dadosCompletos?.Data || employee.date;
                
                if (!funcionarioId) {
                    throw new Error('ID do funcionário não encontrado! Recarregue os dados.');
                }

                const payload = {
                    NumeroFolha: reg,
                    Data: data, // Usar data original da API (já vem formatada)
                    Coluna: colunaMap[punchType],
                    Hora: newValue,
                    Motivo: 'Edição inline via sistema'
                };

                console.log(`💾 Salvando ${colunaMap[punchType]}: ${newValue}`, payload);

                const endpoint = `${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`;

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`,
                        'Content-Type': 'application/json',
                        'secullumidbancoselecionado': employee.empresaId || employee.companyId
                    },
                    body: JSON.stringify(payload)
                });

                console.log(`📊 Status da resposta: ${response.status}`);

                if (response.ok) {
                    // Tenta ler como JSON, mas aceita resposta vazia
                    const responseText = await response.text();
                    console.log(`📄 Resposta texto: "${responseText}"`);
                    
                    let result = null;
                    if (responseText && responseText.trim() !== '') {
                        try {
                            result = JSON.parse(responseText);
                        } catch (e) {
                            console.warn('⚠️ Resposta não é JSON válido, mas status é OK');
                        }
                    }
                    
                    console.log(`✅ ${colunaMap[punchType]} registrada com sucesso!`, result || '(sem retorno JSON)');
                    
                    // Atualizar valor local
                    employee.punches[punchType] = newValue;
                    
                    // Re-renderizar célula com sucesso
                    cell.classList.remove('saving-cell');
                    
                    // Limpar completamente antes de adicionar
                    while (cell.firstChild) {
                        cell.removeChild(cell.firstChild);
                    }
                    
                    const editIcon = document.createElement('span');
                    editIcon.className = 'edit-icon';
                    editIcon.textContent = '✏️';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = `punch-time ${newValue ? 'present' : 'missing'}`;
                    timeSpan.style.fontSize = '13px';
                    timeSpan.textContent = newValue || '--:--';
                    
                    cell.appendChild(editIcon);
                    cell.appendChild(timeSpan);
                    
                    // Atualizar status de inconsistência (sem recarregar tudo)
                    updateEmployeeStatus(employee);
                    
                    // VERIFICAR SE FICOU COM ORDEM INCORRETA OU BATIDAS ÍMPARES
                    const batidas = [
                        employee.punches.ent1, employee.punches.sai1,
                        employee.punches.ent2, employee.punches.sai2,
                        employee.punches.ent3, employee.punches.sai3,
                        employee.punches.ent4, employee.punches.sai4,
                        employee.punches.ent5, employee.punches.sai5
                    ].filter(h => h && h !== '--:--');
                    
                    const totalBatidas = batidas.length;
                    
                    // Verificar ordem cronológica
                    const timeToMinutes = (time) => {
                        if (!time) return 0;
                        const [h, m] = time.split(':').map(Number);
                        return h * 60 + m;
                    };
                    
                    let ordemIncorreta = false;
                    const horariosOrdenados = [
                        employee.punches.ent1, employee.punches.sai1,
                        employee.punches.ent2, employee.punches.sai2,
                        employee.punches.ent3, employee.punches.sai3,
                        employee.punches.ent4, employee.punches.sai4,
                        employee.punches.ent5, employee.punches.sai5
                    ].filter(h => h && h !== '--:--');
                    
                    for (let i = 1; i < horariosOrdenados.length; i++) {
                        const anterior = timeToMinutes(horariosOrdenados[i - 1]);
                        const atual = timeToMinutes(horariosOrdenados[i]);
                        
                        if (atual <= anterior) {
                            ordemIncorreta = true;
                            break;
                        }
                    }
                    
                    // AVISOS
                    if (ordemIncorreta) {
                        alert(`⚠️ ATENÇÃO: ORDEM CRONOLÓGICA INCORRETA!\n\n` +
                              `Os horários devem estar em ordem crescente.\n` +
                              `Verifique: ${horariosOrdenados.join(' → ')}\n\n` +
                              `A linha ficou marcada em AMARELO.`);
                    } else if (totalBatidas !== 4) {
                        alert(`⚠️ ATENÇÃO: ${totalBatidas} batidas registradas!\n\n` +
                              `Padrão esperado: 4 batidas (2 pares)\n` +
                              `Atual: ${horariosOrdenados.join(', ')}\n\n` +
                              `A linha ficou marcada em AMARELO.`);
                    }
                    
                } else {
                    const errorText = await response.text();
                    console.error('❌ Erro:', errorText);
                    alert(`Erro ao salvar: ${errorText}`);
                    cancelInlineEdit(cell);
                }
            } catch (error) {
                console.error('❌ Erro na requisição:', error);
                alert('Erro ao salvar alteração. Verifique o console.');
                cancelInlineEdit(cell);
            }

            currentEditingCell = null;
        }

        function cancelInlineEdit(cell) {
            if (!cell) return;
            
            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punchType = cell.dataset.punch;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            const currentValue = employee ? (employee.punches[punchType] || '') : '';

            cell.classList.remove('editing', 'saving-cell');
            
            // Limpar completamente antes de adicionar (evita erro de DOM)
            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            
            const editIcon = document.createElement('span');
            editIcon.className = 'edit-icon';
            editIcon.textContent = '✏️';
            
            const timeSpan = document.createElement('span');
            timeSpan.className = `punch-time ${currentValue ? 'present' : 'missing'}`;
            timeSpan.style.fontSize = '13px';
            timeSpan.textContent = currentValue || '--:--';
            
            cell.appendChild(editIcon);
            cell.appendChild(timeSpan);
            
            currentEditingCell = null;
        }

        // Função auxiliar para atualizar status de um funcionário
        function updateEmployeeStatus(employee) {
            const p = employee.punches;
            
            // Coletar todas as batidas válidas
            const batidas = [
                p.ent1, p.sai1,
                p.ent2, p.sai2,
                p.ent3, p.sai3,
                p.ent4, p.sai4,
                p.ent5, p.sai5
            ].filter(h => h && h !== '--:--');
            
            const totalBatidas = batidas.length;
            
            // Função para converter HH:MM em minutos
            const timeToMinutes = (time) => {
                if (!time) return 0;
                const [h, m] = time.split(':').map(Number);
                return h * 60 + m;
            };
            
            // VALIDAR ORDEM CRONOLÓGICA
            let ordemIncorreta = false;
            const horariosOrdenados = [
                { nome: 'Entrada 1', hora: p.ent1 },
                { nome: 'Saída 1', hora: p.sai1 },
                { nome: 'Entrada 2', hora: p.ent2 },
                { nome: 'Saída 2', hora: p.sai2 },
                { nome: 'Entrada 3', hora: p.ent3 },
                { nome: 'Saída 3', hora: p.sai3 },
                { nome: 'Entrada 4', hora: p.ent4 },
                { nome: 'Saída 4', hora: p.sai4 },
                { nome: 'Entrada 5', hora: p.ent5 },
                { nome: 'Saída 5', hora: p.sai5 }
            ].filter(h => h.hora && h.hora !== '--:--');
            
            for (let i = 1; i < horariosOrdenados.length; i++) {
                const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                const atual = timeToMinutes(horariosOrdenados[i].hora);
                
                if (atual <= anterior) {
                    ordemIncorreta = true;
                    console.log(`⚠️ ORDEM INCORRETA: ${employee.name} - ${horariosOrdenados[i - 1].nome} (${horariosOrdenados[i - 1].hora}) >= ${horariosOrdenados[i].nome} (${horariosOrdenados[i].hora})`);
                    break;
                }
            }
            
            // Verificar se tem motivo especial
            const motivosEspeciais = ['FALTA', 'FÉRIAS', 'AFASTAMENTO INSS', 'LICENÇA MATERNIDADE'];
            const temMotivoEspecial = motivosEspeciais.includes(employee.motivo);
            
            // Marca inconsistência se:
            // 1. NÃO tem exatamente 4 batidas
            // 2. OU horários em ordem incorreta
            // 3. E NÃO tem motivo especial
            const batidaIncorreta = totalBatidas !== 4 || ordemIncorreta;
            
            if (batidaIncorreta && !temMotivoEspecial) {
                employee.hasInconsistency = true;
            } else {
                employee.hasInconsistency = false;
            }
            
            // Re-renderizar apenas a linha deste funcionário
            renderTable();
        }

        // ==========================================
        // EDIÇÃO DE BATIDAS
        // ==========================================
        let currentEditEmployee = null;

        function openEditModal(reg, date) {
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                alert('Funcionário não encontrado!');
                return;
            }

            currentEditEmployee = employee;

            // Preencher informações do funcionário
            document.getElementById('editEmployeeName').textContent = employee.name;
            document.getElementById('editEmployeeReg').textContent = employee.reg;
            document.getElementById('editEmployeeDate').textContent = date;

            // Preencher horários atuais (convertendo HH:MM para HH:MM formato do input)
            const setTimeValue = (id, value) => {
                const input = document.getElementById(id);
                if (value && value !== '--:--') {
                    // Se já está no formato HH:MM, usa direto
                    input.value = value.length === 4 ? `0${value}` : value; // Adiciona zero se for H:MM
                } else {
                    input.value = '';
                }
            };

            setTimeValue('editEnt1', employee.punches.ent1);
            setTimeValue('editSai1', employee.punches.sai1);
            setTimeValue('editEnt2', employee.punches.ent2);
            setTimeValue('editSai2', employee.punches.sai2);
            setTimeValue('editEnt3', employee.punches.ent3);
            setTimeValue('editSai3', employee.punches.sai3);
            setTimeValue('editEnt4', employee.punches.ent4);
            setTimeValue('editSai4', employee.punches.sai4);
            setTimeValue('editEnt5', employee.punches.ent5);
            setTimeValue('editSai5', employee.punches.sai5);

            // Mostrar modal
            document.getElementById('editModal').style.display = 'flex';
        }

        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditEmployee = null;
        }

        async function confirmSaveEdit() {
            if (!currentEditEmployee) return;

            // Coletar valores editados
            const getTimeValue = (id) => {
                const value = document.getElementById(id).value;
                return value ? value : null;
            };

            const updatedPunches = {
                ent1: getTimeValue('editEnt1'),
                sai1: getTimeValue('editSai1'),
                ent2: getTimeValue('editEnt2'),
                sai2: getTimeValue('editSai2'),
                ent3: getTimeValue('editEnt3'),
                sai3: getTimeValue('editSai3'),
                ent4: getTimeValue('editEnt4'),
                sai4: getTimeValue('editSai4'),
                ent5: getTimeValue('editEnt5'),
                sai5: getTimeValue('editSai5')
            };

            console.log('📝 Dados a serem enviados:', updatedPunches);
            console.log('👤 Funcionário:', currentEditEmployee);

            // Confirmar antes de enviar
            const confirmacao = confirm(
                `Confirma o envio das alterações para:\n\n` +
                `${currentEditEmployee.name} (REG: ${currentEditEmployee.reg})\n` +
                `Data: ${currentEditEmployee.date}\n\n` +
                `⚠️ Esta ação irá atualizar os dados na Secullum!`
            );

            if (!confirmacao) return;

            try {
                // Buscar o ID do funcionário na API (necessário para o endpoint)
                const funcionarioId = currentEditEmployee.rawData?.FuncionarioId || currentEditEmployee.dadosCompletos?.FuncionarioId;
                const data = currentEditEmployee.rawData?.Data || currentEditEmployee.dadosCompletos?.Data || currentEditEmployee.data;
                
                if (!funcionarioId) {
                    throw new Error('ID do funcionário não encontrado! Recarregue os dados.');
                }

                console.log(`🔧 Iniciando atualização de batidas...`);
                console.log(`👤 FuncionarioId: ${funcionarioId}`);
                console.log(`📅 Data: ${data}`);

                // Endpoint da Secullum para incluir batida manual
                const endpoint = `${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`;
                
                let sucessos = 0;
                let erros = 0;

                // Enviar cada batida individualmente
                const batidas = [
                    { tipo: 'E', hora: updatedPunches.ent1, label: 'Entrada 1', coluna: 'Entrada1' },
                    { tipo: 'S', hora: updatedPunches.sai1, label: 'Saída 1', coluna: 'Saida1' },
                    { tipo: 'E', hora: updatedPunches.ent2, label: 'Entrada 2', coluna: 'Entrada2' },
                    { tipo: 'S', hora: updatedPunches.sai2, label: 'Saída 2', coluna: 'Saida2' },
                    { tipo: 'E', hora: updatedPunches.ent3, label: 'Entrada 3', coluna: 'Entrada3' },
                    { tipo: 'S', hora: updatedPunches.sai3, label: 'Saída 3', coluna: 'Saida3' },
                    { tipo: 'E', hora: updatedPunches.ent4, label: 'Entrada 4', coluna: 'Entrada4' },
                    { tipo: 'S', hora: updatedPunches.sai4, label: 'Saída 4', coluna: 'Saida4' },
                    { tipo: 'E', hora: updatedPunches.ent5, label: 'Entrada 5', coluna: 'Entrada5' },
                    { tipo: 'S', hora: updatedPunches.sai5, label: 'Saída 5', coluna: 'Saida5' }
                ];

                for (const batida of batidas) {
                    if (!batida.hora) continue; // Pula se não tiver horário

                    const payload = {
                        NumeroFolha: currentEditEmployee.reg,
                        Data: data,
                        Coluna: batida.coluna, // "Entrada1", "Saida1", etc (TEXTO, não número!)
                        Hora: batida.hora,
                        Motivo: 'Inclusão manual via sistema'
                    };

                    console.log(`📤 Enviando ${batida.label}: ${batida.hora}`, payload);

                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${API_CONFIG.token}`,
                                'Content-Type': 'application/json',
                                'secullumidbancoselecionado': currentEditEmployee.empresaId || API_CONFIG.companies[0]?.id
                            },
                            body: JSON.stringify(payload)
                        });

                        console.log(`📊 Status da resposta: ${response.status}`);

                        if (response.ok) {
                            // Tenta ler como JSON, mas aceita resposta vazia
                            const responseText = await response.text();
                            console.log(`📄 Resposta texto: "${responseText}"`);
                            
                            let result = null;
                            if (responseText && responseText.trim() !== '') {
                                try {
                                    result = JSON.parse(responseText);
                                } catch (e) {
                                    console.warn('⚠️ Resposta não é JSON válido, mas status é OK');
                                }
                            }
                            
                            console.log(`✅ ${batida.label} registrada com sucesso!`, result || '(sem retorno JSON)');
                            sucessos++;
                        } else {
                            const errorText = await response.text();
                            console.error(`❌ Erro ao registrar ${batida.label}: ${response.status} - ${errorText}`);
                            erros++;
                        }
                    } catch (fetchError) {
                        console.error(`❌ Erro de rede ao enviar ${batida.label}:`, fetchError);
                        erros++;
                    }

                    // Delay entre requisições para evitar sobrecarga
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                if (erros === 0) {
                    alert(`✅ Todas as batidas foram atualizadas com sucesso!\n\n${sucessos} horários registrados.`);
                } else {
                    alert(`⚠️ Atualização parcial:\n\n✅ ${sucessos} registros com sucesso\n❌ ${erros} erros\n\nVerifique o console para detalhes.`);
                }

                closeEditModal();

                // Recarregar dados
                console.log('🔄 Recarregando dados...');
                await searchPeriod();

            } catch (error) {
                console.error('❌ Erro ao atualizar batidas:', error);
                alert(`❌ Erro ao atualizar batidas:\n\n${error.message}`);
            }
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================
        
        // 🔴 CORREÇÃO: Event listeners duplicados REMOVIDOS
        // Agora usa event delegation configurado na inicialização (linha ~2395)
        
        // Checkbox "Selecionar Todos"
        document.getElementById('selectAll').addEventListener('change', (e) => {
            const displayedEmployees = showOnlyInconsistencies 
                ? allEmployees.filter(emp => emp.hasInconsistency)
                : allEmployees;
            
            if (e.target.checked) {
                // ✅ SELECIONAR usando ID ÚNICO (REG + DATA)
                selectedEmployees = displayedEmployees.map(emp => `${emp.reg}_${emp.date}`);
            } else {
                selectedEmployees = [];
            }
            
            // ✅ NÃO CHAMAR renderTable()! Atualizar diretamente os checkboxes
            document.querySelectorAll('.employee-checkbox').forEach(cb => {
                const uniqueId = cb.dataset.id;
                if (displayedEmployees.some(emp => `${emp.reg}_${emp.date}` === uniqueId)) {
                    cb.checked = e.target.checked;
                    const row = cb.closest('tr');
                    if (row) {
                        if (e.target.checked) {
                            row.classList.add('selected');
                        } else {
                            row.classList.remove('selected');
                        }
                    }
                }
            });
        });

        // Função compartilhada de geração de PDF
        async function generatePDFs() {
            console.log('🚀 generatePDFs() iniciada');
            console.log(`📋 Selecionados: ${selectedEmployees.length} - ${JSON.stringify(selectedEmployees.slice(0, 3))}`);
            
            // ✅ VERIFICAR SE HÁ SELEÇÃO
            if (selectedEmployees.length === 0) {
                showAlert('Atenção', 'Selecione pelo menos um colaborador usando os checkboxes!', 'warning');
                return;
            }
            
            // ✅ GERAR APENAS OS SELECIONADOS (não todos os exibidos)
            const displayedEmployees = showOnlyInconsistencies 
                ? allEmployees.filter(emp => emp.hasInconsistency)
                : allEmployees;
            
            console.log(`📊 Total displayedEmployees: ${displayedEmployees.length}`);
            
            // ✅ FILTRAR usando ID ÚNICO (REG + DATA) para pegar apenas os dias selecionados
            const toGenerate = displayedEmployees.filter(emp => {
                const uniqueId = `${emp.reg}_${emp.date}`;
                return selectedEmployees.includes(uniqueId);
            });
            
            console.log(`🎯 toGenerate: ${toGenerate.length} registros`);
            console.log(`📝 Primeiro registro:`, toGenerate[0]);
            
            if (toGenerate.length === 0) {
                showAlert('Atenção', 'Nenhum colaborador selecionado encontrado!', 'warning');
                return;
            }
            
            // 🆔 MOSTRAR DIÁLOGO DE CONFIRMAÇÃO
            const confirmar = confirm(
                `⚠️ GERAR PDF PARA ENVIO?\n\n` +
                `Os registros serão salvos no banco de dados e receberão IDs únicos.\n\n` +
                `Total: ${toGenerate.length} registro(s)`
            );
            
            if (!confirmar) {
                console.log('❌ Geração de PDF cancelada pelo usuário');
                return;
            }
            
            // 💾 MOSTRAR LOADING E SALVAR NO BANCO
            console.log('💾 Salvando justificativas no banco de dados...');
            showAlert('Aguarde', 'Salvando justificativas no banco de dados...', 'info');
            
            // 🔍 Verificar se algum registro já foi impresso
            const registrosExistentes = [];
            const registrosNovos = [];
            
            try {
                for (const emp of toGenerate) {
                    // Preparar dados para enviar
                    const payload = {
                        cpf: emp.cpf,
                        reg: emp.reg,
                        data: emp.date,
                        empresa_id: emp.empresaId || emp.companyId || 0,
                        nome: emp.name || '',
                        motivo: emp.motivo || ''
                    };
                    
                    console.log(`📤 Salvando ${emp.name} (CPF: ${emp.cpf})`);
                    
                    const response = await fetch(`${API_BASE_URL}/api/justificativa/salvar`, {
                        method: 'POST',
                        headers: getAuthHeaders(),
                        body: JSON.stringify(payload)
                    });
                    
                    if (response.ok) {
                        const { id, novo, mensagem } = await response.json();
                        emp.id = id;
                        console.log(`✅ ${mensagem} - ID: #${id}`);
                        
                        // Separar novos de existentes
                        if (novo) {
                            registrosNovos.push(emp.name);
                        } else {
                            registrosExistentes.push(emp.name);
                        }
                    } else {
                        const errorText = await response.text();
                        console.error(`❌ Erro ao salvar ${emp.name}: ${response.status} - ${errorText}`);
                        showAlert('Erro', `Erro ao salvar justificativa de ${emp.name}`, 'error');
                        return;
                    }
                }
                
                // Fechar alert de loading
                hideAlert();
                
                // ⚠️ AVISAR SE HÁ REIMPRESSÕES
                if (registrosExistentes.length > 0) {
                    const nomes = registrosExistentes.join('\n• ');
                    const confirmar = confirm(
                        `⚠️ REIMPRESSÃO DETECTADA\n\n` +
                        `Os seguintes registros JÁ FORAM IMPRESSOS:\n\n• ${nomes}\n\n` +
                        `${registrosNovos.length > 0 ? `\nNovos registros: ${registrosNovos.length}\n\n` : ''}` +
                        `Deseja REIMPRIMIR mesmo assim?`
                    );
                    
                    if (!confirmar) {
                        console.log('❌ Reimpressão cancelada pelo usuário');
                        return;
                    }
                }
                
                console.log(`📄 Gerando PDF para ${toGenerate.length} registro(s) selecionado(s)`);
                
                // Gerar PDFs usando emp.id do banco
                const pdfPages = document.getElementById('pdfPages');
                pdfPages.innerHTML = toGenerate.map((emp) => generateForm(emp, emp.id || '?', toGenerate.length)).join('');
                
                // Atualizar contador
                document.getElementById('pdfCount').textContent = `${toGenerate.length} formulário(s) • 1 por página A4 Paisagem`;
                
                // Mostrar preview
                document.getElementById('mainInterface').classList.add('hidden');
                document.getElementById('pdfPreview').classList.add('active');
                
                // Recarregar dados para atualizar a tabela com os novos IDs
                await reloadData();
                
            } catch (err) {
                console.error('❌ Erro ao gerar PDFs:', err);
                showAlert('Erro', 'Erro ao gerar PDFs. Verifique o console.', 'error');
            }
        }
        
        // Botão "GERAR PDF" no topo direito
        document.getElementById('btnGenerateTopRight').addEventListener('click', generatePDFs);

        document.getElementById('btnClosePDF').addEventListener('click', () => {
            document.getElementById('pdfPreview').classList.remove('active');
            document.getElementById('mainInterface').classList.remove('hidden');
        });

        // Event Listeners API - Removido botão manual, conecta automaticamente

        // Botão de buscar período
        document.getElementById('btnSearchDates').addEventListener('click', async () => {
            if (isAPIConnected) {
                await searchPeriod();
            } else {
                alert('⚠️ Primeiro conecte à API!');
            }
        });

        // Campo de busca por nome - atualiza em tempo real
        document.getElementById('searchName')?.addEventListener('input', () => {
            renderTable();
        });
        
        // Filtro de líder (atualizar em tempo real)
        document.getElementById('searchLider')?.addEventListener('input', () => {
            renderTable();
        });

        // Botão limpar filtro
        document.getElementById('btnClearFilter')?.addEventListener('click', () => {
            document.getElementById('searchName').value = '';
            document.getElementById('searchLider').value = '';
            document.getElementById('searchProject').value = '';
            renderTable();
        });
        
        // Filtro de projeto (atualizar em tempo real)
        document.getElementById('searchProject')?.addEventListener('input', () => {
            renderTable();
        });

        // ==========================================
        // 🧪 BOTÃO DE TESTE - ANEXO OCR
        // ==========================================
        document.getElementById('btnTesteAnexo').addEventListener('click', () => {
            document.getElementById('inputTesteAnexo').click();
        });

        document.getElementById('inputTesteAnexo').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            console.clear();
            console.log('🧪🧪🧪 TESTE DE ANEXO E OCR INICIADO 🧪🧪🧪');
            console.log('📁 Arquivo selecionado:', file.name, `(${(file.size / 1024).toFixed(2)} KB)`);

            try {
                // Converter para base64
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const imageBase64 = event.target.result;
                    
                    console.log('📊 Tamanho base64:', imageBase64.length, 'caracteres');

                    // Chamar função de OCR
                    console.log('');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('🚀 INICIANDO AZURE COMPUTER VISION OCR');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    
                    const resultado = await extrairDadosComGoogleVision(imageBase64);
                    
                    console.log('');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('📊 RESULTADO FINAL DO OCR');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('🆔 ID detectado:', resultado.id || 'NÃO DETECTADO');
                    console.log('📝 Motivo:', resultado.motivo || 'NÃO DETECTADO');
                    console.log('⏰ Horários extraídos:');
                    console.log('   Ent1:', resultado.ent1 || 'vazio');
                    console.log('   Sai1:', resultado.sai1 || 'vazio');
                    console.log('   Ent2:', resultado.ent2 || 'vazio');
                    console.log('   Sai2:', resultado.sai2 || 'vazio');
                    console.log('   Ent3:', resultado.ent3 || 'vazio');
                    console.log('   Sai3:', resultado.sai3 || 'vazio');
                    console.log('🎯 Confiança:');
                    console.log('   ID:', resultado.confidence?.id || 0, '%');
                    console.log('   Motivo:', resultado.confidence?.motivo || 0, '%');
                    console.log('   Ent1:', resultado.confidence?.ent1 || 0, '%');
                    console.log('   Sai1:', resultado.confidence?.sai1 || 0, '%');
                    console.log('   Ent2:', resultado.confidence?.ent2 || 0, '%');
                    console.log('   Sai2:', resultado.confidence?.sai2 || 0, '%');
                    console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
                    console.log('');
                    
                    // Mostrar popup com resultado
                    const horariosStr = [
                        resultado.ent1 ? `Ent1: ${resultado.ent1}` : null,
                        resultado.sai1 ? `Sai1: ${resultado.sai1}` : null,
                        resultado.ent2 ? `Ent2: ${resultado.ent2}` : null,
                        resultado.sai2 ? `Sai2: ${resultado.sai2}` : null,
                        resultado.ent3 ? `Ent3: ${resultado.ent3}` : null,
                        resultado.sai3 ? `Sai3: ${resultado.sai3}` : null
                    ].filter(h => h).join('\n');
                    
                    alert(
                        `🧪 RESULTADO DO TESTE DE OCR\n\n` +
                        `🆔 ID: ${resultado.id || 'NÃO DETECTADO'}\n` +
                        `📝 Motivo: ${resultado.motivo || 'PADRÃO'} ⚠️\n` +
                        `   (Detecção de checkbox visual não implementada no OCR - sempre usa padrão)\n\n` +
                        `⏰ Horários:\n${horariosStr || 'Nenhum horário detectado'}\n\n` +
                        `✅ Verifique o console (F12) para detalhes completos!`
                    );
                };
                reader.readAsDataURL(file);

            } catch (err) {
                console.error('❌ Erro no teste:', err);
                alert(`❌ Erro no teste:\n${err.message}`);
            }

            // Limpar input para permitir retestar o mesmo arquivo
            e.target.value = '';
        });

        // Inicializar
        renderTable();
        
        // Definir datas padrão: HOJE em ambos os campos
        (function setDefaultDates() {
            const today = new Date();
            
            // Formatar para YYYY-MM-DD (formato aceito pelo input type="date")
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            document.getElementById('dateStart').value = formatDate(today);
            document.getElementById('dateEnd').value = formatDate(today);
            
            console.log(`📅 Datas padrão configuradas: ${formatDate(today)} (hoje)`);
        })();
    </script>
    
    <!-- Modal de Upload de Anexo -->
    <div id="modalAnexo" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 10000; justify-content: center; align-items: center; overflow-y: auto;">
        <div style="background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 16px; padding: 24px 32px; max-width: 900px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.7); position: relative; margin: 20px auto;">
            <button onclick="fecharModalAnexo()" style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 32px; cursor: pointer; color: #94a3b8; padding: 0; width: 40px; height: 40px; line-height: 1;">×</button>
            
            <h2 style="font-size: 24px; font-weight: bold; background: linear-gradient(135deg, #60a5fa, #a78bfa); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0 0 8px 0;">📎 Anexar Justificativa</h2>
            <p style="color: #94a3b8; margin: 0 0 24px 0; font-size: 14px;" id="modalAnexoInfo">REG: 000 | Data: 00/00/0000</p>
            
            <div id="dropZone" style="border: 3px dashed #3b82f6; border-radius: 12px; padding: 32px 24px; text-align: center; background: rgba(59, 130, 246, 0.1); cursor: pointer; transition: all 0.3s; margin-bottom: 16px;">
                <div style="font-size: 40px; margin-bottom: 12px;">📋</div>
                <h3 style="font-size: 16px; font-weight: 600; color: #e2e8f0; margin: 0 0 6px 0;">Cole o print aqui (Ctrl+V)</h3>
                <p style="color: #94a3b8; margin: 0; font-size: 13px;">Ou clique para selecionar arquivo</p>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
            </div>
            
            <div id="previewArea" style="display: none; margin-bottom: 16px;">
                <img id="previewImage" style="max-width: 100%; max-height: 300px; width: auto; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: block; margin: 0 auto;">
            </div>
            
            <div id="ocrStatus" style="display: none; padding: 16px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 8px; margin-bottom: 16px;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div class="spinner" style="border: 3px solid rgba(148, 163, 184, 0.2); border-top: 3px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite;"></div>
                    <span id="ocrStatusText" style="color: #e2e8f0;">Processando OCR...</span>
                </div>
            </div>
            
            <div id="ocrResult" style="display: none; padding: 16px; background: rgba(16, 185, 129, 0.15); border: 2px solid rgba(16, 185, 129, 0.4); border-radius: 8px; margin-bottom: 16px;">
                <h4 style="margin: 0 0 12px 0; color: #6ee7b7; font-size: 16px; font-weight: 600;">✅ Dados Detectados:</h4>
                <div id="ocrResultContent" style="color: #a7f3d0; font-size: 14px; line-height: 1.8;"></div>
            </div>
            
            <div style="display: flex; gap: 12px;">
                <button onclick="fecharModalAnexo()" style="flex: 1; padding: 12px 24px; background: rgba(107, 114, 128, 0.8); color: white; border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Cancelar</button>
                <button id="btnConfirmarAnexo" onclick="confirmarAnexo()" style="flex: 1; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; display: none;">Confirmar Anexo</button>
            </div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #dropZone:hover {
            border-color: #2563eb;
            background: rgba(59, 130, 246, 0.15);
            transform: scale(1.02);
        }
        
        #dropZone.dragover {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            transform: scale(1.05);
        }
    </style>
</body>
</html>

< ! - -   C a c h e   B u s t e r :   2 0 2 5 - 1 0 - 3 0   1 4 : 0 6 : 3 8   - - > 
 
 