<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestão de Ponto - Justificativas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
            min-height: 100vh;
            color: #e2e8f0;
        }

        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 16px;
        }

        /* Header Card */
        .header-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 24px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-card h1 {
            font-size: 30px;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .header-card p {
            color: #94a3b8;
            margin-top: 4px;
        }

        .date-input {
            padding: 8px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            font-size: 18px;
            font-weight: 600;
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
        }
        
        .date-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        /* Stats Cards */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            padding: 24px;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border-color: rgba(148, 163, 184, 0.2);
        }

        .stat-card .label {
            font-size: 14px;
            color: #94a3b8;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .stat-card .value {
            font-size: 30px;
            font-weight: bold;
            color: #e2e8f0;
        }

        /* Controls */
        .controls-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
            padding: 16px;
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .controls-left {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .btn-filter {
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border: 2px solid rgba(148, 163, 184, 0.2);
        }

        .btn-filter:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.4);
            transform: translateY(-2px);
        }

        .btn-filter.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            border: 2px solid transparent;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
        }

        .btn-filter.active:hover {
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4);
        }

        .btn-clear {
            background: rgba(239, 68, 68, 0.15);
            color: #fca5a5;
            border: 2px solid rgba(239, 68, 68, 0.3);
        }

        .btn-clear:hover {
            background: rgba(239, 68, 68, 0.25);
            border-color: rgba(239, 68, 68, 0.5);
            transform: translateY(-2px);
        }

        .btn-generate {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            font-size: 18px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-generate:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .checkbox-signature {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: #faf5ff;
            border: 2px solid #d8b4fe;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .checkbox-signature:hover {
            background: #f3e8ff;
        }

        .checkbox-signature input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .checkbox-signature span {
            font-weight: 500;
            color: #7c3aed;
        }

        /* Table */
        .table-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            overflow-x: auto;
            overflow-y: visible;
            position: relative;
        }

        /* Scrollbar horizontal sticky */
        .table-card::-webkit-scrollbar {
            height: 14px;
        }

        .table-card::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 8px;
        }

        .table-card::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 8px;
            border: 2px solid #f1f5f9;
            cursor: grab;
        }

        .table-card::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #2563eb, #1e40af);
        }

        .table-card::-webkit-scrollbar-thumb:active {
            cursor: grabbing;
            background: #1e40af;
        }

        table {
            width: 100%;
            min-width: 2120px;
            border-collapse: collapse;
        }

        thead {
            background: linear-gradient(135deg, #1e40af, #3b82f6);
            color: white;
        }

        th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85rem;
            letter-spacing: 0.5px;
        }

        th.center {
            text-align: center;
        }

        td {
            padding: 12px 16px;
            border-bottom: 1px solid #e5e7eb;
            color: #1f2937;
        }

        td.center {
            text-align: center;
        }

        tbody tr {
            transition: all 0.3s ease;
        }

        tbody tr:hover {
            background: #f9fafb;
            transform: translateX(4px);
        }

        tbody tr.inconsistency {
            background: #fef2f2;
            border-left: 4px solid #ef4444;
        }

        tbody tr.selected {
            background: #dbeafe;
            border-left: 4px solid #3b82f6;
        }

        .punch-time {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .punch-time.present {
            color: #22c55e;
        }

        .punch-time.missing {
            color: #ef4444;
        }

        .punch-time.optional {
            color: #9ca3af;
        }

        /* ERRO: Horário fora de ordem cronológica */
        .punch-time.error-time {
            color: #ffffff !important;
            background: #b91c1c !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            font-weight: 700 !important;
            /* 🚨 PERFORMANCE: Removida animação infinita para economizar CPU */
            box-shadow: 0 0 0 2px rgba(185, 28, 28, 0.5);
        }

        @keyframes pulseError {
            0%, 100% {
                background: #b91c1c;
                box-shadow: 0 0 0 0 rgba(185, 28, 28, 0.7);
            }
            50% {
                background: #dc2626;
                box-shadow: 0 0 0 6px rgba(185, 28, 28, 0);
            }
        }

        /* APROVADO: Horário aprovado pelo RH */
        .punch-time.approved {
            color: #ffffff !important;
            background: #10b981 !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            font-weight: 700 !important;
        }

        .approved-badge {
            position: absolute;
            bottom: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: #10b981;
            color: white;
            border-radius: 50%;
            font-size: 11px;
            line-height: 16px;
            text-align: center;
            font-weight: bold;
            z-index: 10;
        }

        .approve-icon {
            position: absolute;
            top: 2px;
            left: 2px;
            cursor: pointer;
            font-size: 16px;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 10;
        }
        
        .approve-icon::before {
            content: '✅';
        }

        .approve-icon:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .swap-icon {
            display: inline-block;
            cursor: pointer;
            font-size: 16px;
            margin-right: 6px;
            opacity: 0.7;
            transition: all 0.2s;
            vertical-align: middle;
            color: #3b82f6;
        }

        .swap-icon:hover {
            opacity: 1;
            transform: scale(1.2) rotate(180deg);
        }

        /* Edição Inline - Estilo Excel - REMOVIDO */

        .question-icon {
            position: absolute;
            top: 2px;
            right: 2px;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.6;
            transition: all 0.2s;
            z-index: 10;
        }
        
        .question-icon::before {
            content: '❓';
        }

        .question-icon:hover {
            opacity: 1;
            transform: scale(1.15);
        }

        .has-question {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 14px;
            color: #f59e0b;
            filter: drop-shadow(0 0 2px rgba(245, 158, 11, 0.5));
            /* 🚨 PERFORMANCE: Removida animação infinita - usar hover ao invés */
        }
        
        .question-icon:hover {
            transform: scale(1.2);
        }

        .delete-question-icon {
            position: absolute;
            top: 2px;
            left: 2px;
            cursor: pointer;
            font-size: 14px;
            opacity: 0.7;
            transition: all 0.2s;
            z-index: 10;
            color: #ef4444;
        }
        
        .delete-question-icon::before {
            content: '❌';
        }

        .delete-question-icon:hover {
            opacity: 1;
            transform: scale(1.2);
        }

        .editable-cell.editing {
            padding: 0 !important;
            background: rgba(15, 23, 42, 1) !important;
            box-shadow: inset 0 0 0 2px #3b82f6 !important;
        }

        .inline-input {
            width: 100%;
            height: 100%;
            border: none;
            background: rgba(15, 23, 42, 0.8);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 13px;
            text-align: center;
            padding: 8px 12px;
            color: #22c55e;
            outline: none;
        }

        .inline-input:focus {
            background: rgba(15, 23, 42, 1);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .saving-cell {
            background: rgba(59, 130, 246, 0.2) !important;
            animation: pulse 0.5s ease-in-out;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 9999px;
            font-size: 12px;
            font-weight: 600;
        }

        .status-badge.ok {
            background: rgba(16, 185, 129, 0.2);
            color: #6ee7b7;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        .status-badge.error {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        /* Info Box */
        .info-box {
            margin-top: 24px;
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            gap: 12px;
        }

        .info-box svg {
            flex-shrink: 0;
            margin-top: 4px;
            color: #60a5fa;
        }

        .info-box p {
            font-weight: 600;
            color: #e2e8f0;
            margin-bottom: 4px;
        }

        .info-box ol {
            color: #cbd5e1;
            font-size: 14px;
            padding-left: 20px;
        }

        .info-box li {
            margin: 4px 0;
        }

        /* PDF Preview */
        .pdf-preview {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #0f172a;
            z-index: 1000;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 32px;
            display: none;
        }

        .pdf-preview.active {
            display: block;
        }

        @media screen {
            .pdf-preview {
                overflow-y: auto;
                overflow-x: hidden;
            }
        }

        .pdf-controls {
            max-width: 210mm;
            margin: 0 auto 24px;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            padding: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pdf-controls h2 {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .pdf-controls p {
            color: #94a3b8;
        }

        .pdf-controls-buttons {
            display: flex;
            gap: 12px;
        }

        .btn-print {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-print:hover {
            background: linear-gradient(135deg, #059669, #047857);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .btn-close {
            background: rgba(75, 85, 99, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: white;
        }

        .btn-close:hover {
            background: rgba(55, 65, 81, 1);
        }

        /* Form Page A4 Landscape */
        .form-page {
            width: 297mm;
            height: 210mm;
            background: white;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            margin: 0 auto 32px;
            padding: 10mm;
            overflow: hidden;
        }

        @media screen {
            .form-page {
                max-width: calc(100vw - 64px);
                width: auto;
                aspect-ratio: 297/210;
            }
        }

        @media print {
            body { 
                margin: 0 !important; 
                padding: 0 !important;
                background: white !important;
                overflow: hidden !important;
            }
            
            html {
                overflow: hidden !important;
            }
            
            @page { 
                size: A4 landscape; 
                margin: 0mm;
            }
            
            .pdf-preview {
                position: static !important;
                padding: 0 !important;
                background: white !important;
                overflow: visible !important;
            }
            
            .pdf-controls { 
                display: none !important; 
            }
            
            .form-page {
                page-break-after: always;
                page-break-inside: avoid;
                margin: 0 !important;
                padding: 10mm !important;
                box-shadow: none !important;
                width: 297mm !important;
                height: 210mm !important;
                max-width: none !important;
                overflow: visible !important;
            }
            
            .form-page:last-child {
                page-break-after: auto;
            }
            
            #pdfPages {
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* Esconder Cache Buster e qualquer conteúdo após o body */
            html::after,
            body::after,
            body ~ * {
                display: none !important;
                visibility: hidden !important;
                position: absolute !important;
                left: -9999px !important;
            }
            
            /* Garantir que apenas pdfPages seja impresso */
            body > *:not(#pdfPreview) {
                display: none !important;
            }
            
            #pdfPreview {
                display: block !important;
                position: static !important;
            }
        }

        .form-border {
            border: 4px solid black;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .form-header {
            background: #d1d5db;
            border-bottom: 2px solid black;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .form-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-circle {
            width: 48px;
            height: 48px;
            background: #4b5563;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
        }

        .logo-text {
            font-weight: bold;
            font-size: 20px;
        }

        .form-title {
            flex: 1;
            text-align: center;
            font-weight: bold;
            font-size: 16px;
            color: #1f2937;
        }

        .form-orientation {
            font-size: 12px;
            padding: 8px 16px;
            background: #f3f4f6;
            border-bottom: 2px solid #9ca3af;
            color: #1f2937;
        }

        .form-employee-data {
            padding: 12px 16px;
            border-bottom: 2px solid #9ca3af;
            font-size: 16px;
            color: #1f2937;
        }

        .form-row {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 16px;
            margin-bottom: 8px;
        }

        .form-row-2 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        .form-field {
            display: flex;
            gap: 8px;
        }

        .form-field-label {
            font-weight: 600;
            color: #374151;
        }

        .form-field-value {
            font-weight: bold;
            color: #1f2937;
        }

        .section-header {
            background: #374151;
            color: white;
            text-align: center;
            padding: 8px;
            font-weight: bold;
            font-size: 14px;
            border-bottom: 2px solid black;
        }

        .form-times {
            flex: 1;
            padding: 24px;
            background: #f9fafb;
            border-bottom: 2px solid #9ca3af;
        }

        .times-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 32px;
            align-items: center;
            height: 100%;
            max-width: 1200px;
            margin: 0 auto;
        }

        .time-slot {
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .time-value {
            font-size: 24px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .time-value.present {
            color: black;
        }

        .time-value.missing {
            color: #000;
            background: transparent;
            padding: 0;
            border: none;
            font-size: 28px;
            font-weight: 900;
            font-family: 'Courier New', monospace;
            letter-spacing: 8px;
        }

        .time-status {
            font-size: 12px;
            font-weight: bold;
            padding: 2px 12px;
            border-radius: 4px;
        }

        .time-status.batido {
            background: #dcfce7;
            color: #166534;
        }

        .time-status.justificar {
            background: #fee2e2;
            color: #991b1b;
        }

        .form-justification {
            padding: 12px 16px;
            background: #f9fafb;
            border-bottom: 2px solid #9ca3af;
        }

        .justification-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            font-size: 14px;
            margin-bottom: 8px;
            color: #1f2937;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #1f2937;
        }

        .checkbox-item input {
            width: 16px;
            height: 16px;
        }

        .obs-field {
            margin-top: 8px;
            font-size: 12px;
            color: #1f2937;
        }

        .obs-field .obs-label {
            font-weight: 600;
        }

        .obs-line {
            border-bottom: 2px solid #9ca3af;
            margin-top: 4px;
            padding-bottom: 8px;
        }

        .form-signatures {
            display: grid;
            grid-template-columns: 1fr 1fr;
            padding: 16px;
            margin-top: auto;
        }

        .signature-box {
            text-align: center;
            color: #1f2937;
        }

        .signature-box.left {
            padding-right: 32px;
            border-right: 2px solid #9ca3af;
        }

        .signature-box.right {
            padding-left: 32px;
        }

        .signature-space {
            height: 64px;
        }

        .signature-line {
            border-top: 2px solid black;
            padding-top: 8px;
        }

        .signature-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 4px;
            color: #1f2937;
        }

        .signature-label {
            font-size: 12px;
            color: #4b5563;
        }

        /* Estilo para células de Horário com setas de navegação */
        .punch-cell {
            position: relative;
        }

        .selected-cell {
            background: #dbeafe !important;
            outline: 2px solid #3b82f6 !important;
        }

        /* ========== TOAST NOTIFICATIONS ========== */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10002;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
            max-width: 420px;
        }

        .toast {
            pointer-events: auto;
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 20px;
            border-radius: 10px;
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 8px 32px rgba(0,0,0,0.35);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255,255,255,0.08);
            animation: toastIn 0.35s cubic-bezier(.21,1.02,.73,1) forwards;
            opacity: 0;
            transform: translateX(80px);
            cursor: pointer;
            max-width: 420px;
            word-break: break-word;
        }

        .toast.removing {
            animation: toastOut 0.3s ease-in forwards;
        }

        .toast.success { background: linear-gradient(135deg, rgba(16,185,129,0.92), rgba(5,150,105,0.92)); }
        .toast.error   { background: linear-gradient(135deg, rgba(239,68,68,0.92), rgba(220,38,38,0.92)); }
        .toast.warning { background: linear-gradient(135deg, rgba(245,158,11,0.92), rgba(217,119,6,0.92)); }
        .toast.info    { background: linear-gradient(135deg, rgba(59,130,246,0.92), rgba(37,99,235,0.92)); }

        .toast-icon { font-size: 18px; flex-shrink: 0; }
        .toast-msg  { flex: 1; line-height: 1.4; }
        .toast-close {
            flex-shrink: 0;
            background: none;
            border: none;
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            cursor: pointer;
            padding: 0 0 0 8px;
            line-height: 1;
        }
        .toast-close:hover { color: #fff; }

        @keyframes toastIn {
            from { opacity: 0; transform: translateX(80px); }
            to   { opacity: 1; transform: translateX(0); }
        }
        @keyframes toastOut {
            from { opacity: 1; transform: translateX(0); }
            to   { opacity: 0; transform: translateX(80px); }
        }

        /* ========== COLLAPSIBLE COLUMNS (ENT3-SAI5) ========== */
        .col-extra { transition: width 0.25s ease, padding 0.25s ease, opacity 0.2s ease, max-width 0.25s ease; }
        .col-extra.collapsed {
            width: 0 !important;
            min-width: 0 !important;
            max-width: 0 !important;
            padding: 0 !important;
            overflow: hidden;
            opacity: 0;
            border-left: none;
            border-right: none;
            font-size: 0;
        }
        .toggle-cols-btn {
            background: rgba(139,92,246,0.15);
            color: #a78bfa;
            border: 1px solid rgba(139,92,246,0.3);
            border-radius: 6px;
            padding: 3px 10px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            white-space: nowrap;
            transition: all 0.2s;
        }
        .toggle-cols-btn:hover {
            background: rgba(139,92,246,0.3);
            color: #c4b5fd;
        }

        /* ========== SELECTION COUNTER ========== */
        .selection-counter {
            display: none;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15));
            border: 1px solid rgba(59,130,246,0.3);
            border-radius: 10px;
            color: #93c5fd;
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            transition: all 0.25s ease;
        }
        .selection-counter.active {
            display: flex;
        }
        .selection-counter .count-badge {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: #fff;
            padding: 2px 10px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 700;
            min-width: 28px;
            text-align: center;
        }

        /* TAREFA 7: Estilos para drag-and-drop */
        .punch-cell[draggable="true"] {
            cursor: grab !important;
        }

        .punch-cell[draggable="true"]:active {
            cursor: grabbing !important;
        }

        .drag-over {
            background: #fef3c7 !important;
            outline: 2px dashed #f59e0b !important;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.4);
        }

        .swap-arrow {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #3b82f6;
            color: white;
            width: 18px;
            height: 18px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 100;
            transition: all 0.15s;
        }

        .swap-arrow:hover {
            background: #2563eb;
            transform: scale(1.1);
        }

        .digital-signature {
            font-weight: bold;
            font-style: italic;
            font-size: 36px;
            font-family: 'Brush Script MT', cursive;
            color: #1e40af;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .form-footer {
            font-size: 12px;
            color: #6b7280;
            text-align: center;
            margin-top: 8px;
        }

        .hidden {
            display: none;
        }

        #pdfPages {
            margin: 0;
            padding: 0;
        }

        /* Upload de Anexo */
        .upload-btn {
            background: #3b82f6;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .upload-btn:hover {
            background: #2563eb;
        }

        .attached-file {
            background: #dcfce7;
            color: #166534;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .remove-file {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            cursor: pointer;
            font-size: 10px;
        }

        .motivo-field {
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
        }

        /* botão API */
        .api-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .api-status.connected {
            background: #f1f5f9;
            color: #0f172a;
            border: 2px solid #10b981;
        }

        .api-status.disconnected {
            background: #f1f5f9;
            color: #64748b;
            border: 2px solid #cbd5e1;
        }

        .btn-api {
            background: #6b7280;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-api:hover {
            background: #047857;
        }

        .btn-config {
            background: #6b7280;
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-config:hover {
            background: #4b5563;
        }

        .btn-company {
            padding: 8px 16px;
            border: 2px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }

        .btn-company:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(148, 163, 184, 0.5);
            transform: translateY(-2px);
        }

        .btn-company.active {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white !important;
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .btn-company.loading {
            opacity: 0.6;
            cursor: wait;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-content {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            padding: 32px 48px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(148, 163, 184, 0.2);
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 16px;
            font-weight: 600;
            color: #e2e8f0;
            margin: 0;
        }

        /* Custom Alert Popup */
        .custom-alert {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10001;
            backdrop-filter: blur(10px);
        }

        .custom-alert.active {
            display: flex;
        }

        .alert-content {
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(20px);
            padding: 0;
            border-radius: 16px;
            min-width: 400px;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.1);
            animation: slideUp 0.3s ease-out;
            overflow: hidden;
        }

        .alert-header {
            padding: 24px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .alert-header.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .alert-header.error {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .alert-header.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .alert-header.info {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }

        .alert-title {
            font-size: 20px;
            font-weight: 700;
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .alert-body {
            padding: 24px;
            color: #e2e8f0;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .alert-footer {
            padding: 16px 24px;
            background: rgba(15, 23, 42, 0.5);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .alert-btn {
            padding: 10px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            font-size: 14px;
            transition: all 0.2s;
        }

        .alert-btn.primary {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
        }

        .alert-btn.primary:hover {
            background: linear-gradient(135deg, #2563eb, #7c3aed);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .alert-btn.secondary {
            background: rgba(51, 65, 85, 0.8);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .alert-btn.secondary:hover {
            background: rgba(51, 65, 85, 1);
            border-color: rgba(148, 163, 184, 0.3);
        }
    </style>
    
    <!-- Google Cloud Vision API (substitui Tesseract) -->
</head>
<body>
    <!-- ==========================================
         autenticação - Verificar login Secullum
         ========================================== -->
    <script>
        // Verificar autenticação ANTES de carregar a página
        (function() {
            const token = localStorage.getItem('secullum_token');
            const expiry = localStorage.getItem('secullum_token_expiry');
            const userName = localStorage.getItem('user_name') || localStorage.getItem('secullum_username') || 'Usuário';
            
            // Se não tem token OU token expirou, redirecionar para login
            if (!token || !expiry || Date.now() >= parseInt(expiry)) {
                console.log('🔑 Token inválido ou expirado, redirecionando para login...');
                localStorage.clear(); // Limpar tudo
                window.location.href = '/login.html';
                return;
            }
            
            // 🔑 RESTAURAR TOKEN: Carregar token salvo no localStorage de volta para memória
            if (typeof API_CONFIG !== 'undefined') {
                API_CONFIG.token = token;
            }
            
            console.log('? Usuário autenticado:', userName);
            window.CURRENT_USER = userName;
            window.CURRENT_USER_EMAIL = localStorage.getItem('secullum_username') || userName; // Email do login
            
            // Atualizar nome do Usuário no header quando carregar
            document.addEventListener('DOMContentLoaded', () => {
                const userNameElement = document.getElementById('userName');
                if (userNameElement) {
                    userNameElement.textContent = userName;
                }
                
                // Conectar API automaticamente ao carregar a página
                setTimeout(() => {
                    connectToAPI();
                }, 500);
            });
        })();
    </script>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p class="loading-text" id="loadingText">Carregando...</p>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <!-- Custom Alert -->
    <div class="custom-alert" id="customAlert">
        <div class="alert-content">
            <div class="alert-header" id="alertHeader">
                <div class="alert-title" id="alertTitle"></div>
            </div>
            <div class="alert-body" id="alertBody"></div>
            <div class="alert-footer">
                <button class="alert-btn primary" id="alertOkBtn">OK</button>
            </div>
        </div>
    </div>

    <!-- Modal de Pergunta -->
    <div class="custom-alert" id="questionModal">
        <div class="alert-content" style="min-width: 500px;">
            <div class="alert-header warning">
                <div class="alert-title">? Pergunta ao Colaborador</div>
            </div>
            <div class="alert-body">
                <p id="questionContext" style="margin-bottom: 16px; font-weight: 600;"></p>
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #e2e8f0;">Digite a pergunta:</label>
                <textarea id="questionInput" 
                          rows="4" 
                          style="width: 100%; padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; font-family: inherit; resize: vertical;"
                          placeholder="Ex: Por que bateu o ponto às 10:00 se não estava trabalhando?"></textarea>
            </div>
            <div class="alert-footer">
                <button class="alert-btn secondary" id="questionCancelBtn">Cancelar</button>
                <button class="alert-btn primary" id="questionOkBtn">Adicionar Pergunta</button>
            </div>
        </div>
    </div>

    <!-- Modal Monitor de máquinas -->
    <div class="custom-alert" id="machineMonitorModal">
        <div class="alert-content" style="min-width: 900px; max-width: 95vw;">
            <div class="alert-header" style="background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
                <div class="alert-title">📊 Monitor de Relógios de Ponto</div>
            </div>
            <div class="alert-body" style="max-height: 70vh; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding: 16px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 8px;">
                    <div>
                        <div style="font-size: 12px; color: #94a3b8; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">Última atualização</div>
                        <div id="monitorLastUpdate" style="font-size: 18px; font-weight: 700; color: #e2e8f0; margin-top: 4px;">--:--:--</div>
                    </div>
                    <button class="btn" onclick="refreshMachineMonitor()" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 10px 20px;">
                        <span>🔑</span>
                        <span>Atualizar</span>
                    </button>
                </div>
                <div id="machineMonitorContent">
                    <!-- Será preenchido pelo JavaScript -->
                </div>
            </div>
            <div class="alert-footer">
                <button class="alert-btn secondary" onclick="closeMachineMonitor()">Fechar</button>
                <button class="alert-btn primary" onclick="exportMachineMonitor()">📸 Exportar Print</button>
            </div>
        </div>
    </div>

    <!-- Main Interface -->
    <div id="mainInterface" class="container">
        <!-- Header -->
        <div class="header-card" style="display: flex; justify-content: space-between; align-items: center;">
            <div>
                <h1>Gestão de Ponto - Justificativas</h1>
                <p>Sistema de geração automática de formulários</p>
            </div>
            <div style="display: flex; gap: 10px; align-items: center;">
                <!-- BOTÃO DE TESTE - ANEXO OCR -->
                <button id="btnTesteAnexo" style="margin: 0; font-size: 14px; padding: 10px 20px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                    📎 TESTE ANEXO
                </button>
                <input type="file" id="inputTesteAnexo" accept="image/*" style="display: none;">
                
                <div id="userInfo" style="margin-right: 16px; text-align: right; color: #94a3b8;">
                    <small style="display: block; font-size: 12px;">Logado como:</small>
                    <strong style="display: block; color: #e2e8f0;" id="userName">Admin</strong>
                </div>
                <button class="btn" id="btnMachineMonitor" onclick="openMachineMonitor()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);">
                    <span>📊</span>
                    <span>MONITOR</span>
                </button>
                <button class="btn" onclick="openPresencePanel()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                    <span>📅</span>
                    <span>PRESENÇA</span>
                </button>
                <button class="btn" onclick="openReportDashboard()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                    <span>📈</span>
                    <span>RELATÓRIO</span>
                </button>
                <button class="btn btn-generate" id="btnGenerateTopRight" style="margin: 0; font-size: 16px; padding: 12px 24px;">
                    <span>📄</span>
                    <span>GERAR PDF</span>
                </button>
                <button class="btn" onclick="logout()" style="margin: 0; font-size: 16px; padding: 12px 24px; background: #ef4444;">
                    <span>🚪</span>
                    <span>SAIR</span>
                </button>
            </div>
        </div>

        <!-- Empresas e Status API -->
        <div class="header-card" style="margin-top: 20px;">
            <div style="display: flex; gap: 20px; align-items: center; justify-content: space-between; flex-wrap: wrap;">
                <!-- Empresas -->
                <div style="flex: 1; min-width: 300px;">
                    <label style="display: block; font-size: 13px; font-weight: 600; color: #94a3b8; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px;">🏢 Empresas</label>
                    <div id="companyButtons" style="display: flex; gap: 8px; flex-wrap: wrap;">
                        <button class="btn-company active" data-company="all" onclick="selectCompany('all', this)" style="background: linear-gradient(135deg, #3b82f6, #8b5cf6); border: none; color: white; padding: 8px 16px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                            🏢 TODAS
                        </button>
                        <!-- Botées das empresas Seráo adicionados aqui pelo JavaScript -->
                    </div>
                </div>
                
                <!-- Status API -->
                <div style="display: flex; gap: 12px; align-items: center; padding: 12px 16px; background: rgba(15, 23, 42, 0.6); border-radius: 10px; border: 2px solid rgba(148, 163, 184, 0.2);">
                    <span class="api-status disconnected" id="apiStatus" style="background: rgba(15, 23, 42, 0.8); color: #94a3b8; border: 2px solid rgba(148, 163, 184, 0.2); padding: 8px 16px; border-radius: 8px; font-weight: 600; font-size: 13px; display: flex; align-items: center; gap: 8px;">
                        <span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span>
                        Conectando API...
                    </span>
                </div>
            </div>
        </div>

        <!-- Controls -->
        <div class="controls-card">
            <div class="controls-left" style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap; flex: 1;">
                <!-- Filtros de Data -->
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">Data Início</label>
                    <input type="date" class="date-input" id="dateStart" style="font-size: 13px; padding: 8px 10px; height: 38px;">
                </div>
                <div>
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">Data Fim</label>
                    <input type="date" class="date-input" id="dateEnd" style="font-size: 13px; padding: 8px 10px; height: 38px;">
                </div>
                <button class="btn-primary" id="btnSearchDates" style="padding: 9px 16px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; height: 38px;">
                    🔍 Buscar Período
                </button>
                
                <!-- Filtro por Nome -->
                <div style="flex: 1; min-width: 200px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">🔍 Filtrar por Nome</label>
                    <input type="text" class="date-input" id="searchName" placeholder="Digite o nome..." style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <!-- Filtro por Líder -->
                <div style="min-width: 180px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">👤 Líder</label>
                    <input type="text" class="date-input" id="searchLider" placeholder="Nome do líder..." style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <!-- Filtro por Projeto (Azure) -->
                <div style="min-width: 130px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">📊 Projeto (BDO)</label>
                    <input type="text" class="date-input" id="searchProject" placeholder="Ex: 400" style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <!-- Filtro por Departamento (Secullum) -->
                <div style="min-width: 130px;">
                    <label style="display: block; font-size: 12px; font-weight: 500; color: #94a3b8; margin-bottom: 4px;">🏢 Depto (SEC)</label>
                    <input type="text" class="date-input" id="searchDepartamento" placeholder="Ex: DEPTO" style="font-size: 13px; padding: 8px 10px; width: 100%; height: 38px;">
                </div>
                
                <button class="btn-primary" id="btnClearFilter" style="padding: 9px 14px; background: rgba(239, 68, 68, 0.15); color: #fca5a5; border: 2px solid rgba(239, 68, 68, 0.3); border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 13px; height: 38px;">
                    ❌ Limpar
                </button>
                
                <!-- botão de filtro -->
                <button class="btn btn-filter" id="btnFilter" style="height: 38px;">
                    <span>⚠️</span>
                    <span id="filterText">Mostrar Só Inconsistências</span>
                </button>
            </div>
        </div>

        <!-- Selection Counter -->
        <div class="selection-counter" id="selectionCounter">
            <span>✅ Selecionados:</span>
            <span class="count-badge" id="selectionCount">0</span>
            <span id="selectionLabel">linhas selecionadas</span>
        </div>

        <!-- Table -->
        <div class="table-card">
            <table>
                <thead>
                    <tr>
                        <th style="width: 40px;">
                            <input type="checkbox" id="selectAll" style="width: 18px; height: 18px; cursor: pointer;">
                        </th>
                        <th style="width: 50px;">ID</th>
                        <th style="width: 80px;">REG</th>
                        <th style="min-width: 150px; max-width: 180px;">LÍDER</th>
                        <th style="min-width: 100px; max-width: 120px;">PROJ (BDO)</th>
                        <th style="min-width: 120px; max-width: 140px;">DEPTO (SEC)</th>
                        <th style="min-width: 180px; max-width: 220px;">NOME</th>
                        <th style="width: 140px;">CPF</th>
                        <th style="min-width: 140px;">EMPRESA</th>
                        <th style="width: 100px;">DATA</th>
                        <th style="width: 80px;" class="center">ENT. 1</th>
                        <th style="width: 80px;" class="center">SAÍ. 1</th>
                        <th style="width: 80px;" class="center">ENT. 2</th>
                        <th style="width: 80px;" class="center">SAÍ. 2</th>
                        <th class="center" style="width: 28px; min-width: 28px; max-width: 28px; padding: 0; border: none;">
                            <button class="toggle-cols-btn" id="toggleExtraCols" onclick="toggleExtraColumns()" title="Mostrar/Ocultar ENT.3 a SAÍ.5">◀</button>
                        </th>
                        <th style="width: 80px;" class="center col-extra">ENT. 3</th>
                        <th style="width: 80px;" class="center col-extra">SAÍ. 3</th>
                        <th style="width: 80px;" class="center col-extra">ENT. 4</th>
                        <th style="width: 80px;" class="center col-extra">SAÍ. 4</th>
                        <th style="width: 80px;" class="center col-extra">ENT. 5</th>
                        <th style="width: 80px;" class="center col-extra">SAÍ. 5</th>
                        <th style="width: 70px;" class="center" title="ID de Impressão">ID IMP</th>
                        <th style="min-width: 150px; max-width: 200px;">MOTIVO</th>
                        <th style="width: 100px;">ANEXOS</th>
                        <th style="width: 90px;" class="center">STATUS</th>
                    </tr>
                </thead>
                <tbody id="employeeTable">
                    <!-- Será preenchido pelo JavaScript -->
                </tbody>
            </table>
            
            <!-- Controles de Paginação -->
            <div id="paginationControls" style="display: none; margin-top: 20px;"></div>
        </div>

        <!-- Modal de Edição de Batidas -->
        <div id="editModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 9999; justify-content: center; align-items: center;">
            <div style="background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 12px; padding: 32px; max-width: 600px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 24px;">
                    <h2 style="font-size: 24px; font-weight: bold; background: linear-gradient(135deg, #60a5fa, #a78bfa); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0;">✏️ Editar Batidas</h2>
                    <button onclick="closeEditModal()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #94a3b8; padding: 0; width: 32px; height: 32px; line-height: 1;"></button>
                </div>
                
                <div style="background: rgba(15, 23, 42, 0.6); padding: 16px; border-radius: 8px; margin-bottom: 24px; border: 1px solid rgba(148, 163, 184, 0.1);">
                    <div style="font-weight: 600; color: #e2e8f0;" id="editEmployeeName">NOME DO FUNCIONÁRIO</div>
                    <div style="font-size: 14px; color: #94a3b8; margin-top: 4px;">
                        REG: <span id="editEmployeeReg">000</span> | Data: <span id="editEmployeeDate">00/00/0000</span>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 24px;">
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 1</label>
                        <input type="time" id="editEnt1" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 1</label>
                        <input type="time" id="editSai1" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 2</label>
                        <input type="time" id="editEnt2" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 2</label>
                        <input type="time" id="editSai2" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 3</label>
                        <input type="time" id="editEnt3" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 3</label>
                        <input type="time" id="editSai3" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 4</label>
                        <input type="time" id="editEnt4" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 4</label>
                        <input type="time" id="editSai4" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">ENTRADA 5</label>
                        <input type="time" id="editEnt5" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #94a3b8; margin-bottom: 8px; font-size: 14px;">SAÍDA 5</label>
                        <input type="time" id="editSai5" style="width: 100%; padding: 10px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(15, 23, 42, 0.6); color: #e2e8f0; border-radius: 8px; font-size: 16px; font-family: 'Courier New', monospace;">
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button onclick="closeEditModal()" style="padding: 12px 24px; border: 2px solid rgba(148, 163, 184, 0.3); background: rgba(51, 65, 85, 0.8); color: #e2e8f0; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 16px;">
                        Cancelar
                    </button>
                    <button onclick="confirmSaveEdit()" style="padding: 12px 24px; border: none; background: linear-gradient(135deg, #10b981, #059669); color: white; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                        ? Confirmar e Enviar
                    </button>
                </div>
            </div>
        </div>

        <!-- Info -->
    </div>

    <!-- PDF Preview -->
    <div id="pdfPreview" class="pdf-preview">
        <div class="pdf-controls">
            <div>
                <h2>Pré-visualização - Formato Paisagem</h2>
                <p id="pdfCount">0 formulário(s) • 1 por página A4 Paisagem</p>
            </div>
            <div class="pdf-controls-buttons">
                <button class="btn btn-print" onclick="window.print()">
                    <span>❓</span>
                    <span>Imprimir Todas</span>
                </button>
                <button class="btn btn-close" id="btnClosePDF">
                    <span></span>
                    <span>Fechar</span>
                </button>
            </div>
        </div>
        <div id="pdfPages">
            <!-- Será preenchido pelo JavaScript -->
        </div>
    </div>

    <script>
        // ==========================================
        // SISTEMA DE LOADING E POPUPS
        // ==========================================
        function showLoading(text = 'Carregando...') {
            const overlay = document.getElementById('loadingOverlay');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = text;
            overlay.classList.add('active');
        }

        function hideLoading() {
            const overlay = document.getElementById('loadingOverlay');
            overlay.classList.remove('active');
        }

        // ==========================================
        // TOAST NOTIFICATIONS (substituem showAlert)
        // ==========================================
        function showToast(message, type = 'info', duration = 3500) {
            const container = document.getElementById('toastContainer');
            const icons = { success: '✅', error: '❌', warning: '⚠️', info: 'ℹ️' };

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-msg">${message.replace(/\n/g, '<br>')}</span>
                <button class="toast-close" onclick="this.parentElement.classList.add('removing');setTimeout(()=>this.parentElement.remove(),300)">&times;</button>
            `;
            container.appendChild(toast);

            // Auto-remove
            const autoTimer = setTimeout(() => {
                toast.classList.add('removing');
                setTimeout(() => toast.remove(), 300);
            }, duration);

            // Click to dismiss faster
            toast.addEventListener('click', () => {
                clearTimeout(autoTimer);
                toast.classList.add('removing');
                setTimeout(() => toast.remove(), 300);
            });

            // Limit max toasts visible
            const toasts = container.querySelectorAll('.toast');
            if (toasts.length > 5) {
                toasts[0].classList.add('removing');
                setTimeout(() => toasts[0].remove(), 300);
            }
        }

        // Redirecionar showAlert → showToast (compatibilidade)
        function showAlert(title, message, type = 'info') {
            showToast(message, type);
        }

        // Alias para compatibilidade
        function showNotification(message, type = 'info') {
            showToast(message, type);
        }

        function hideAlert() {
            document.getElementById('customAlert').classList.remove('active');
        }

        // ==========================================
        // SELECTION COUNTER
        // ==========================================
        function updateSelectionCounter() {
            const counter = document.getElementById('selectionCounter');
            const countEl = document.getElementById('selectionCount');
            const labelEl = document.getElementById('selectionLabel');
            if (!counter || !countEl) return;

            const count = selectedEmployees.length;
            if (count > 0) {
                counter.classList.add('active');
                countEl.textContent = count;
                labelEl.textContent = count === 1 ? 'linha selecionada' : 'linhas selecionadas';
            } else {
                counter.classList.remove('active');
            }
        }

        // ==========================================
        // COLLAPSIBLE COLUMNS (ENT.3 – SAÍ.5)
        // ==========================================
        let extraColsCollapsed = false;

        function toggleExtraColumns() {
            extraColsCollapsed = !extraColsCollapsed;
            const cells = document.querySelectorAll('.col-extra');
            const btn = document.getElementById('toggleExtraCols');

            cells.forEach(cell => {
                if (extraColsCollapsed) {
                    cell.classList.add('collapsed');
                } else {
                    cell.classList.remove('collapsed');
                }
            });

            if (btn) {
                btn.textContent = extraColsCollapsed ? '▶' : '◀';
                btn.title = extraColsCollapsed
                    ? 'Expandir colunas ENT.3 a SAÍ.5'
                    : 'Recolher colunas ENT.3 a SAÍ.5';
            }
        }

        // Fechar alert legado ao clicar no botão OK (mantém para modais)
        document.getElementById('alertOkBtn').addEventListener('click', () => {
            document.getElementById('customAlert').classList.remove('active');
        });

        // Fechar alert ao clicar fora
        document.getElementById('customAlert').addEventListener('click', (e) => {
            if (e.target.id === 'customAlert') {
                document.getElementById('customAlert').classList.remove('active');
            }
        });

        // ==========================================
        // JUSTIFICATIVAS PADRONIZADAS
        // ==========================================
        const JUSTIFICATIVAS_PADRAO = [
            'Esqueceu de registrar o Ponto',
            'Falha no App',
            'Falta',
            'Folga',
            'Hora Parada',
            'Maquina Ponto com defeito',
            'Registro em duplicidade',
            'Registro indevido'
        ];

        // Mapeamento OCR ? Justificativa Padronizada
        const MAPEAMENTO_JUSTIFICATIVAS = {
            'esqueceu de registrar o ponto': 'Esqueceu de registrar o Ponto',
            'esqueceu': 'Esqueceu de registrar o Ponto',
            'esquecimento': 'Esqueceu de registrar o Ponto',
            'falha no app': 'Falha no App',
            'falha app': 'Falha no App',
            'falta': 'Falta',
            'folga': 'Folga',
            'hora parada': 'Hora Parada',
            'maquina ponto com defeito': 'Maquina Ponto com defeito',
            'maquina defeito': 'Maquina Ponto com defeito',
            'defeito': 'Maquina Ponto com defeito',
            'registro em duplicidade': 'Registro em duplicidade',
            'duplicidade': 'Registro em duplicidade',
            'registro indevido': 'Registro indevido',
            'indevido': 'Registro indevido'
        };

        // ==========================================
        // configuração DA API SECULLUM
        // ==========================================
        const API_CONFIG = {
            authURL: 'https://autenticador.secullum.com.br/Token',
            baseURL: 'https://pontowebintegracaoexterna.secullum.com.br',
            token: '',
            credentials: {
                grant_type: 'password',
                username: 'ferreira.eduardo@larsil.com.br',
                password: 'larsil123@',
                client_id: '3'
            },
            companies: [], // Será preenchido dinamicamente pela API
            selectedCompanies: ['all'], // 'all' ou array de IDs
            endpoints: {
                auth: '/Token',
                batidas: '/Batidas',
                funcionarios: '/Funcionarios',
                justificativas: '/Justificativas',
                cartaoPontoManual: '/CartaoPonto/Manual',
                cartaoPontoJustificativa: '/CartaoPonto/Justificativa',
                calcular: '/Calcular',
                pendencias: '/Pendencias'
            }
        };

        // ==========================================
        // 📋 JUSTIFICATIVAS SECULLUM
        // ==========================================
        let justificativasSecullum = [];
        let justificativasFolha = [];

        // ==========================================
        // 🚀 CACHE HÍBRIDO INTELIGENTE - 60 DIAS
        // ==========================================
        const CACHE_STRATEGY = {
            DEFAULT_RANGE_DAYS: 60,
            TTL: {
                historical: 24 * 60 * 60 * 1000,
                current_month: 5 * 60 * 1000,
                today: 2 * 60 * 1000  // 🚨 OTIMIZAÇÃO: Aumentado de 30s para 2 minutos para reduzir carga
            }
        };

        // ==========================================
        // ⚡ CONFIGURAÇÃO OTIMIZADA (pode alterar aqui)
        // ==========================================
        const CACHE_CONFIG = {
            daysToLoad: 6,  // Quantidade de dias para carregar (padrão: 6)
            ttl: {
                historical: 24 * 60 * 60 * 1000,  // 24h para dados antigos
                today: 2 * 60 * 1000  // 🚨 OTIMIZAÇÃO: Aumentado de 30s para 2 minutos
            }
        };

        // 🚨 PERFORMANCE: Flag para desabilitar logs excessivos em produção
        const DEBUG_MODE = false;  // Mudar para true apenas para debug
        const debugLog = DEBUG_MODE ? console.log.bind(console) : () => {};

        // 🚨 PERFORMANCE: Função debounce para evitar chamadas excessivas
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Criar versão debounced do renderTable
        const debouncedRenderTable = debounce(() => {
            currentPage = 1;
            renderTable();
        }, 300);

        const SMART_CACHE = {
            employees: new Map(),      // ✅ NOVO: cache por funcionário (REG_DATA_EMPRESA)
            historical: new Map(),
            recent: new Map(),
            today: new Map(),
            metadata: {
                lastFullLoad: null,
                lastUpdate: null,
                totalRequests: 0
            }
        };

        let autoRefreshInterval = null;

        // ==========================================
        // 📦 CACHE POR FUNCIONÁRIO - GET/SET
        // ==========================================
        function getCachedEmployee(reg, date, empresaId) {
            const key = `${reg}_${date}_${empresaId}`;
            return SMART_CACHE.employees.get(key) || null;
        }

        function setCachedEmployee(reg, date, empresaId, data, timestamp = Date.now()) {
            const key = `${reg}_${date}_${empresaId}`;
            data._cacheTimestamp = timestamp;
            SMART_CACHE.employees.set(key, data);
        }

        function getCachedDataByEmployee(dateStart, dateEnd) {
            const start = new Date(dateStart);
            const end = new Date(dateEnd);
            const allBatidas = [];
            
            const selectedCompanies = API_CONFIG.selectedCompanies.includes('all') 
                ? API_CONFIG.companies 
                : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
            
            console.log(`🔍 Buscando no cache: ${dateStart} até ${dateEnd}`);
            console.log(`📦 Cache tem ${SMART_CACHE.employees.size} funcionários`);
            
            // ✅ NOVA ESTRUTURA: cache por funcionário (reg_empresaId)
            // Cada entrada tem { data: { reg, nome, empresaId, empresaNome, batidas: [] }, timestamp, ttl }
            for (const [key, cacheEntry] of SMART_CACHE.employees.entries()) {
                const [reg, empresaId] = key.split('_');
                
                // Filtrar por empresa selecionada
                if (!selectedCompanies.some(c => String(c.id) === String(empresaId))) {
                    continue;
                }
                
                const funcionario = cacheEntry.data;
                
                if (!funcionario || !funcionario.batidas || !Array.isArray(funcionario.batidas)) {
                    continue;
                }
                
                // Filtrar batidas pelo período
                funcionario.batidas.forEach(batida => {
                    const dataBatida = batida.Data ? new Date(batida.Data.split('T')[0]) : null;
                    
                    if (dataBatida && dataBatida >= start && dataBatida <= end) {
                        // Adicionar metadados da empresa se não existirem
                        if (!batida._empresa) {
                            batida._empresa = funcionario.empresaNome;
                            batida._empresaId = funcionario.empresaId;
                        }
                        allBatidas.push(batida);
                    }
                });
            }
            
            console.log(`✅ ${allBatidas.length} batidas encontradas no cache`);
            
            return allBatidas;
        }

        // ==========================================
        // 🎯 INVALIDAÇÃO CIRÚRGICA - 1 FUNCIONÁRIO
        // ==========================================
        async function invalidateSingleEmployee(reg, date, empresaId) {
            // Normalizar data
            let dateStr = date;
            if (date.includes('/')) {
                const [dia, mes, ano] = date.split('/');
                dateStr = `${ano}-${mes.padStart(2,'0')}-${dia.padStart(2,'0')}`;
            } else if (date.includes('T')) {
                dateStr = date.split('T')[0];
            }
            
            const key = `${reg}_${dateStr}_${empresaId}`;
            
            // Remover do cache
            SMART_CACHE.employees.delete(key);
            
            console.log(`🗑️ Cache invalidado: ${reg} em ${dateStr}`);
            
            // Recarregar APENAS este funcionário da API
            return await reloadSingleEmployee(reg, dateStr, empresaId);
        }

        async function reloadSingleEmployee(reg, date, empresaId) {
            const company = API_CONFIG.companies.find(c => c.id === empresaId);
            if (!company) {
                console.warn(`⚠️ Empresa ${empresaId} não encontrada`);
                return null;
            }
            
            console.log(`⚡ Recarregando ${reg} de ${date}...`);
            
            try {
                const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Batidas?dataInicio=${date}&dataFim=${date}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`,
                        'secullumidbancoselecionado': company.id,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    console.warn(`⚠️ Erro ${response.status} ao recarregar ${reg}`);
                    return null;
                }
                
                const result = await response.json();
                
                // Filtrar APENAS o funcionário específico
                const employeeData = result.find(batida => {
                    const regBatida = batida.Funcionario?.NumeroIdentificador || 
                                     batida.Funcionario?.NumeroFolha;
                    return regBatida === reg;
                });
                
                if (employeeData) {
                    employeeData._empresa = company.name;
                    employeeData._empresaId = company.id;
                    
                    // Salvar no cache
                    setCachedEmployee(reg, date, empresaId, employeeData);
                    
                    console.log(`✅ ${reg} atualizado no cache`);
                    return employeeData;
                }
                
                console.warn(`⚠️ Funcionário ${reg} não encontrado nos dados`);
                
            } catch (err) {
                console.error(`❌ Erro ao recarregar ${reg}:`, err);
            }
            
            return null;
        }

        // ==========================================
        // HELPER: Adicionar token de autenticação em todas as requisições
        // ==========================================
        function getAuthHeaders(additionalHeaders = {}) {
            const token = localStorage.getItem('token') || sessionStorage.getItem('token');
            
            if (!token) {
                throw new Error('Token não fornecido');
            }
            
            return {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`,
                ...additionalHeaders
            };
        }

        // Helper para fetch com autenticação (retorna null se não autenticado)
        async function authenticatedFetch(url, options = {}) {
            const headers = getAuthHeaders(options.headers || {});
            if (!headers) {
                console.warn('⚠️ Requisição ignorada - sem autenticação:', url);
                return null;
            }
            return fetch(url, { ...options, headers });
        }

        // ==========================================
        // configuração GLOBAL DA API
        // ==========================================
        const API_BASE_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : 'https://justificativas.up.railway.app';

        // ==========================================
        // configuração SQL AZURE (Node.js API)
        // ==========================================
        const SQL_API = {
            baseURL: `${API_BASE_URL}/api`,
            endpoints: {
                colaboradores: '/colaboradores',
                colaboradorByCPF: '/colaboradores/cpf',
                colaboradoresBatchCPF: '/colaboradores/batch-cpf'
            }
        };

        // Cache de dados do SQL Azure
        let sqlColaboradoresCache = {};

        // função para buscar colaborador por CPF no SQL Azure
        async function getColaboradorByCPF(cpf) {
            try {
                // Verificar se já esté no cache
                const cpfLimpo = cpf.replace(/[^\d]/g, '');
                if (sqlColaboradoresCache[cpfLimpo]) {
                    return sqlColaboradoresCache[cpfLimpo];
                }

                const response = await fetch(`${SQL_API.baseURL}${SQL_API.endpoints.colaboradorByCPF}/${cpfLimpo}`);
                
                if (response.ok) {
                    const data = await response.json();
                    sqlColaboradoresCache[cpfLimpo] = data;
                    return data;
                }
                
                return null;
            } catch (error) {
                console.warn(`⚠️ Erro ao buscar colaborador CPF ${cpf}:`, error.message);
                return null;
            }
        }

        // função para buscar múltiplos colaboradores por CPFs (batch - mais rápido)
        async function getColaboradoresBatchCPF(cpfs) {
            try {
                const response = await fetch(`${SQL_API.baseURL}${SQL_API.endpoints.colaboradoresBatchCPF}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ cpfs })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // Adicionar ao cache
                    data.forEach(colab => {
                        const cpfLimpo = colab.CPF.replace(/[^\d]/g, '');
                        sqlColaboradoresCache[cpfLimpo] = colab;
                    });
                    
                    console.log(`? ${data.length} colaboradores carregados do SQL Azure`);
                    return data;
                }
                
                return [];
            } catch (error) {
                console.warn('⚠️ Erro ao buscar colaboradores em batch:', error.message);
                return [];
            }
        }

        // função para autenticar na API Secullum
        async function authenticateAPI() {
            try {
                const body = new URLSearchParams({
                    grant_type: API_CONFIG.credentials.grant_type,
                    username: API_CONFIG.credentials.username,
                    password: API_CONFIG.credentials.password,
                    client_id: API_CONFIG.credentials.client_id
                });

                const response = await fetch(API_CONFIG.authURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    body: body.toString()
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Falha na autenticação: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                API_CONFIG.token = data.access_token;
                
                // 🔑 SALVAR TOKEN SECULLUM
                localStorage.setItem('secullum_token', data.access_token);
                localStorage.setItem('secullum_token_expiry', Date.now() + (data.expires_in * 1000));
                
                console.log('✅ Secullum autenticado com sucesso!');
                console.log('🔑 Token Secullum:', API_CONFIG.token.substring(0, 50) + '...');
                
                // 🔐 AUTENTICAR NO BACKEND (Railway) para obter JWT
                try {
                    const backendResponse = await fetch('https://justificativas.up.railway.app/api/auth/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            username: API_CONFIG.credentials.username,
                            password: API_CONFIG.credentials.password
                        })
                    });
                    
                    if (backendResponse.ok) {
                        const backendData = await backendResponse.json();
                        // Salvar token JWT do backend (usado para /api/anexos/upload, etc)
                        localStorage.setItem('token', backendData.token);
                        console.log('✅ Backend autenticado com sucesso!');
                        console.log('🔑 Token JWT:', backendData.token.substring(0, 50) + '...');
                    } else {
                        console.warn('⚠️ Falha ao autenticar no backend, mas Secullum OK');
                    }
                } catch (err) {
                    console.warn('⚠️ Erro ao autenticar no backend:', err.message);
                }
                
                // Buscar empresas disponíveis após autenticação
                await loadCompanies();
                
                // Buscar justificativas
                await fetchJustificativas();
                
                return true;
            } catch (error) {
                console.error('? Erro na autenticação:', error);
                showAlert('Erro', `Erro ao conectar com a API Secullum: ${error.message}`, 'error');
                return false;
            }
        }

        // função para buscar empresas (bancos) disponíveis
        async function loadCompanies() {
            try {
                
                const response = await fetch('https://autenticador.secullum.com.br/ContasSecullumExterno/ListarBancos', {
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Erro ao buscar empresas: ${response.status}`);
                }

                const bancos = await response.json();
                console.log(`? ${bancos.length} empresas encontradas`);
                
                // Cores para os botées
                const cores = ['#7c3aed', '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#ec4899', '#8b5cf6', '#14b8a6'];
                
                API_CONFIG.companies = bancos.map((banco, index) => ({
                    id: banco.id.toString(),
                    name: banco.nome || banco.razaoSocial || `Empresa ${banco.id}`,
                    color: cores[index % cores.length],
                    documento: banco.documento
                }));
                
                // Atualizar botées de empresas
                initCompanyButtons();
                
                
                
            } catch (error) {
                console.error('? Erro ao buscar empresas:', error);
                // Fallback para empresas padrão
                API_CONFIG.companies = [
                    { id: '3', name: 'LARSIL SERVICOS FLORESTAIS LTDA', color: '#7c3aed' }
                ];
                initCompanyButtons();
            }
        }

        // ==========================================
        // 📋 BUSCAR JUSTIFICATIVAS DA SECULLUM
        // ==========================================
        async function fetchJustificativas() {
            try {
                console.log('📋 Buscando justificativas...');
                
                // Buscar justificativas Secullum
                const response = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/Justificativas`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`,
                        'secullumidbancoselecionado': API_CONFIG.companies[0]?.id || '3',
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    justificativasSecullum = await response.json();
                    console.log(`✅ ${justificativasSecullum.length} justificativas Secullum carregadas`);
                } else {
                    console.warn('⚠️ Erro ao buscar justificativas Secullum:', response.status);
                }

                // Justificativas Folha (hardcoded por enquanto)
                justificativasFolha = [
                    { id: 'atestado_medico', nome: 'Atestado Médico' },
                    { id: 'falta_justificada', nome: 'Falta Justificada' },
                    { id: 'ferias', nome: 'Férias' },
                    { id: 'licenca', nome: 'Licença' },
                    { id: 'compensacao', nome: 'Compensação' },
                    { id: 'trabalho_remoto', nome: 'Trabalho Remoto' },
                    { id: 'ajuste_ponto', nome: 'Ajuste de Ponto' }
                ];
                console.log(`✅ ${justificativasFolha.length} justificativas Folha carregadas`);

                // Popular dropdowns
                populateJustificativasDropdowns();

            } catch (error) {
                console.error('❌ Erro ao buscar justificativas:', error);
            }
        }

        // ==========================================
        // 📋 POPULAR DROPDOWN DE JUSTIFICATIVAS SECULLUM
        // ==========================================
        function populateJustificativasDropdowns() {
            const selectSecullum = document.getElementById('selectJustificativaSecullum');

            if (!selectSecullum) {
                console.warn('⚠️ Dropdown de justificativas não encontrado no DOM (modal ainda não aberto)');
                return false;
            }

            // Popular Secullum
            selectSecullum.innerHTML = '<option value="">Selecione...</option>';
            justificativasSecullum.forEach(just => {
                const option = document.createElement('option');
                const nomeAbreviado = just.NomeAbreviado || '';
                const nomeCompleto = just.NomeCompleto || '';
                
                // Limpar 'null' dos nomes
                const abreviadoLimpo = nomeAbreviado === 'null' ? '' : nomeAbreviado;
                const completoLimpo = nomeCompleto === 'null' ? '' : nomeCompleto;
                
                option.value = abreviadoLimpo || completoLimpo;
                option.textContent = abreviadoLimpo ? `${abreviadoLimpo} - ${completoLimpo}` : completoLimpo;
                option.dataset.justificativa = JSON.stringify(just);
                selectSecullum.appendChild(option);
            });

            console.log(`✅ Dropdown de justificativas Secullum populado com ${justificativasSecullum.length} itens`);
            return true;
        }
        
        // ==========================================
        // 🔄 AUTO-PREENCHER BATIDAS POR JUSTIFICATIVA
        // ==========================================
        function autoPreencherBatidas(valorSelecionado) {
            if (!valorSelecionado) return;
            
            console.log('📋 Justificativa selecionada:', valorSelecionado);
            
            // Justificativas que preenchem 4 batidas
            const justificativasComBatidas = [
                'FOLGA', 'FERIADO', 'DOM', 'FALTA', 'ATESTADO', 'ATESTAD',
                'A. INSS', 'AT. OBT', 'DECLARAÇÃO JUDICIAL', 'D.JUDIC',
                'DECL.', 'FOLGABH', 'H P', 'L.MATER'
            ];
            
            // Verificar se a justificativa preenche batidas
            const devePreencherBatidas = justificativasComBatidas.some(just => 
                valorSelecionado.toUpperCase().includes(just)
            );
            
            if (devePreencherBatidas) {
                // Preencher as 4 primeiras batidas com o valor da justificativa
                const campos = ['ocrEnt1', 'ocrSai1', 'ocrEnt2', 'ocrSai2'];
                
                campos.forEach(campoId => {
                    const campo = document.getElementById(campoId);
                    if (campo && !campo.disabled) {
                        // IMPORTANTE: Mudar tipo de input para "text" para aceitar justificativas
                        if (campo.type === 'time') {
                            campo.type = 'text';
                        }
                        campo.value = valorSelecionado.toUpperCase();
                        // Adicionar estilo para indicar que é justificativa, não horário
                        campo.style.textAlign = 'center';
                        campo.style.fontWeight = 'bold';
                        campo.style.color = '#3b82f6';
                        console.log(`✅ ${campoId} preenchido com: ${valorSelecionado}`);
                    }
                });
                
                console.log(`✅ 4 batidas preenchidas com: ${valorSelecionado}`);
            }
        }

        // função para enriquecer batidas com nomes dos funcionários
        async function enrichWithEmployeeNames(batidas, companies) {
            // Enriquecer com nomes dos funcionários
            
            const funcionariosCache = new Map();
            const funcionariosAtivosSet = new Set(); // ? REGISTRAR APENAS FUNCIONÁRIOS ATIVOS
            
            for (const company of companies) {
                try {
                    const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Funcionarios`;
                    
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${API_CONFIG.token}`,
                            'secullumidbancoselecionado': company.id,
                            'Content-Type': 'application/json'
                        }
                    });

                    if (response.ok) {
                        const funcionarios = await response.json();
                        
                        // FILTRAR: Apenas funcionários ATIVOS (sem data de demissão)
                        const funcionariosAtivos = funcionarios.filter(func => {
                            // ? CAMPO CORRETO: "Demissao" (conforme documentação Secullum)
                            const dataDemissao = func.Demissao || null;
                            
                            // Se tem data de demissão preenchida, EXCLUIR (não mostrar)
                            if (dataDemissao && dataDemissao !== '0001-01-01T00:00:00' && dataDemissao !== null) {
                                return false; // Demitido - não mostrar
                            }
                            
                            // Se não tem demissão, ã ATIVO
                            return true;
                        });
                        
                        console.log(`? ${company.name}: ${funcionariosAtivos.length} funcionários ativos (total: ${funcionarios.length})`);
                        
                        funcionariosAtivos.forEach(func => {
                            const reg = func.NumeroIdentificador || func.NumeroFolha;
                            const key = `${company.id}_${reg}`;
                            
                            // Debug removido para performance
                            
                            // ? EXTRAIR DEPARTAMENTO (pode ser string ou objeto)
                            let departamento = null;
                            if (func.Departamento) {
                                if (typeof func.Departamento === 'string') {
                                    departamento = func.Departamento;
                                } else if (typeof func.Departamento === 'object') {
                                    // Se for objeto, tentar pegar Nome, Descricao, Codigo ou Id
                                    departamento = func.Departamento.Nome || 
                                                  func.Departamento.Descricao || 
                                                  func.Departamento.Codigo || 
                                                  func.Departamento.Id || 
                                                  null;
                                }
                            }
                            
                            funcionariosCache.set(key, {
                                nome: func.Nome || func.NomeCompleto || 'Nome não informado',
                                cpf: func.Cpf || func.CPF || '',
                                pis: func.NumeroPis || func.PIS || '',
                                // ? DEPARTAMENTO DA API SECULLUM
                                projetoSecullum: departamento
                            });
                            
                            // ? MARCAR como ATIVO
                            funcionariosAtivosSet.add(key);
                        });
                    }
                } catch (error) {
                    console.warn(`⚠️ Erro ao buscar funcionários de ${company.name}`);
                }
            }
            
            // ? FILTRAR batidas: mostrar APENAS funcionários ATIVOS (silencioso)
            const batidasFiltradas = batidas.filter(batida => {
                const reg = batida.Funcionario?.NumeroIdentificador || batida.Funcionario?.NumeroFolha;
                const key = `${batida._empresaId}_${reg}`;
                
                // Se não esté no Set de ativos, não mostrar (demitido/inativo)
                if (!funcionariosAtivosSet.has(key)) {
                    return false;
                }
                
                // Enriquecer com nome se estiver no cache
                const funcInfo = funcionariosCache.get(key);
                if (funcInfo) {
                    batida._funcionarioNome = funcInfo.nome;
                    batida._funcionarioCpf = funcInfo.cpf;
                    batida._projetoSecullum = funcInfo.projetoSecullum; // ? PROJETO DA API SECULLUM
                }
                
                return true;
            });
            
            console.log(`? Nomes carregados! ${batidasFiltradas.length} registros (apenas funcionários ativos)`);
            
            // ? SUBSTITUIR array original
            batidas.length = 0;
            batidas.push(...batidasFiltradas);
        }

        // 🚀 BUSCAR DADOS DE 1 DIA (micro-request para cache)
        async function fetchDayData(company, date) {
            try {
                const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Batidas?dataInicio=${date}&dataFim=${date}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`,
                        'secullumidbancoselecionado': company.id,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) return [];
                
                const result = await response.json();
                
                if (Array.isArray(result)) {
                    result.forEach(batida => {
                        batida._empresa = company.name;
                        batida._empresaId = company.id;
                    });
                    return result;
                }
                
                return [];
            } catch (err) {
                return [];
            }
        }

        // ==========================================
        // ✅ FUNÇÃO OTIMIZADA - USA RANGE DE DATAS
        // ==========================================
        async function loadFullHistoricalCache(dateStart, dateEnd) {
            console.log('🚀 [OTIMIZADO] Iniciando carga com date range...');
            showLoading('⚡ Carregando dados otimizados...');
            
            let dataInicio, dataFim;
            
            // Se recebeu datas específicas, usar elas
            if (dateStart && dateEnd) {
                dataInicio = dateStart;
                dataFim = dateEnd;
                
                // Calcular diferença em dias
                const start = new Date(dateStart);
                const end = new Date(dateEnd);
                const diffTime = Math.abs(end - start);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
                
                console.log(`📅 Range solicitado (usuário): ${dataInicio} até ${dataFim} (${diffDays} dias)`);
            } else {
                // Fallback: usar CACHE_CONFIG.daysToLoad
                const now = new Date();
                const startDate = new Date(now);
                startDate.setDate(startDate.getDate() - parseInt(CACHE_CONFIG.daysToLoad) + 1);
                
                dataInicio = formatDateForAPI(startDate);
                dataFim = formatDateForAPI(now);
                
                console.log(`📅 Range solicitado (padrão): ${dataInicio} até ${dataFim} (${CACHE_CONFIG.daysToLoad} dias)`);
            }
            
            // Buscar empresas selecionadas
            const empresas = API_CONFIG.selectedCompanies.includes('all')
                ? API_CONFIG.companies
                : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
            
            console.log(`🏢 Empresas selecionadas: ${empresas.map(e => e.name).join(', ')}`);
            
            if (empresas.length === 0) {
                hideLoading();
                showNotification('⚠️ Nenhuma empresa selecionada', 'warning');
                return false;
            }
            
            try {
                const startTime = Date.now();
                
                // ✅ OTIMIZAÇÃO: 1 request por empresa (PARALELO)
                const promises = empresas.map(async (empresa) => {
                    console.log(`🔄 Buscando dados da ${empresa.name}...`);
                    
                    try {
                        const url = `${API_CONFIG.baseURL}/IntegracaoExterna/Batidas?dataInicio=${dataInicio}&dataFim=${dataFim}`;
                        
                        const response = await fetch(url, {
                            method: 'GET',
                            headers: {
                                'Authorization': `Bearer ${API_CONFIG.token}`,
                                'secullumidbancoselecionado': empresa.id,
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error(`❌ Erro ${response.status} na empresa ${empresa.name}:`, errorText);
                            throw new Error(`Erro ${response.status} na empresa ${empresa.name}`);
                        }
                        
                        const data = await response.json();
                        console.log(`✅ ${empresa.name}: ${data.length} batidas recebidas`);
                        
                        // 🔍 DEBUG: Ver JOCELIA especificamente
                        const jocelia = data.find(b => b.Funcionario?.Nome?.includes('JOCELIA') || b.Nome?.includes('JOCELIA'));
                        if (jocelia) {
                            console.log(`🔍 JOCELIA encontrada:`, jocelia);
                        }
                        
                        // 🔍 DEBUG: Ver estrutura completa de uma batida
                        if (data.length > 0) {
                            console.log(`🔍 Estrutura da primeira batida:`, data[0]);
                        }
                        
                        // 🔍 DEBUG: Ver justificativas retornadas pela API
                        const batidasComJustificativa = data.filter(b => b.Justificativa || b.JustificativaAbreviacao || b.Entrada1Justificativa || b.Saida1Justificativa);
                        if (batidasComJustificativa.length > 0) {
                            console.log(`🔍 ${batidasComJustificativa.length} batidas com justificativa:`, batidasComJustificativa[0]);
                        }
                        
                        return {
                            empresaId: empresa.id,
                            empresaNome: empresa.name,
                            data: Array.isArray(data) ? data : [],
                            success: true
                        };
                        
                    } catch (error) {
                        console.error(`❌ Falha ao buscar ${empresa.name}:`, error);
                        return {
                            empresaId: empresa.id,
                            empresaNome: empresa.name,
                            data: [],
                            success: false,
                            error: error.message
                        };
                    }
                });
                
                // ✅ Aguardar TODAS as empresas em paralelo
                console.log(`⏳ Aguardando ${promises.length} requisições paralelas...`);
                const results = await Promise.all(promises);
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                console.log(`⚡ Tempo total de requisições: ${elapsed}s`);
                
                // Verificar falhas
                const failures = results.filter(r => !r.success);
                if (failures.length > 0) {
                    console.warn(`⚠️ ${failures.length} empresa(s) falharam:`, failures.map(f => f.empresaNome));
                }
                
                // ✅ Processar e cachear por funcionário
                let totalFuncionarios = 0;
                let totalBatidas = 0;
                
                results.forEach(result => {
                    if (!result.success || result.data.length === 0) {
                        console.log(`⏭️ Pulando ${result.empresaNome} (sem dados ou erro)`);
                        return;
                    }
                    
                    const { empresaId, empresaNome, data } = result;
                    totalBatidas += data.length;
                    
                    // Agrupar batidas por funcionário
                    const funcionariosMap = new Map();
                    
                    data.forEach(batida => {
                        // Extrair REG do funcionário
                        const reg = batida.Funcionario?.NumeroIdentificador || 
                                   batida.Funcionario?.NumeroFolha || 
                                   null;
                        
                        if (!reg) {
                            console.warn('⚠️ Batida sem REG:', batida);
                            return;
                        }
                        
                        if (!funcionariosMap.has(reg)) {
                            funcionariosMap.set(reg, {
                                reg: reg,
                                nome: batida.Funcionario?.Nome || 'Nome não disponível',
                                empresaId: empresaId,
                                empresaNome: empresaNome,
                                batidas: []
                            });
                        }
                        
                        funcionariosMap.get(reg).batidas.push(batida);
                    });
                    
                    console.log(`📊 ${empresaNome}: ${funcionariosMap.size} funcionários encontrados`);
                    
                    // Cachear cada funcionário individualmente
                    funcionariosMap.forEach((funcionario, reg) => {
                        const cacheKey = `${reg}_${empresaId}`;
                        
                        // Determinar TTL baseado na data mais recente
                        let ttl = CACHE_CONFIG.ttl.historical; // Padrão: 24h
                        
                        const hoje = new Date().toISOString().split('T')[0];
                        const temBatidasHoje = funcionario.batidas.some(b => {
                            const dataBatida = b.Data ? b.Data.split('T')[0] : null;
                            return dataBatida === hoje;
                        });
                        
                        if (temBatidasHoje) {
                            ttl = CACHE_CONFIG.ttl.today; // 30s
                        }
                        
                        SMART_CACHE.employees.set(cacheKey, {
                            data: funcionario,
                            timestamp: Date.now(),
                            ttl: ttl
                        });
                        
                        totalFuncionarios++;
                    });
                });
                
                hideLoading();
                
                console.log(`✅ Cache populado com sucesso!`);
                console.log(`📊 Estatísticas:`);
                console.log(`   - Funcionários: ${totalFuncionarios}`);
                console.log(`   - Batidas totais: ${totalBatidas}`);
                console.log(`   - Tempo total: ${elapsed}s`);
                console.log(`   - Performance: ${(totalBatidas / parseFloat(elapsed)).toFixed(0)} batidas/segundo`);
                
                showNotification(`✅ Dados carregados em ${elapsed}s! (${totalFuncionarios} funcionários)`, 'success');
                
                return true;
                
            } catch (error) {
                console.error('❌ Erro crítico ao carregar dados:', error);
                hideLoading();
                showNotification(`❌ Erro: ${error.message}`, 'error');
                return false;
            }
        }

        // ==========================================
        // ✅ FUNÇÃO AUXILIAR - FORMATAR DATA PARA API
        // ==========================================
        function formatDateForAPI(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`; // Retorna "2025-11-30"
        }

        // ==========================================
        // ✅ NORMALIZAR DATAS DE DIFERENTES FORMATOS
        // ==========================================
        function normalizeDate(dateStr) {
            if (!dateStr) return null;
            
            // Já está no formato correto (YYYY-MM-DD)
            if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                return dateStr;
            }
            
            // Formato DD/MM/YYYY
            if (/^\d{2}\/\d{2}\/\d{4}$/.test(dateStr)) {
                const [day, month, year] = dateStr.split('/');
                return `${year}-${month}-${day}`;
            }
            
            // Formato estranho: 27T00:00:00/10/2025
            const strangeMatch = dateStr.match(/^(\d{2})T\d{2}:\d{2}:\d{2}\/(\d{2})\/(\d{4})$/);
            if (strangeMatch) {
                const [, day, month, year] = strangeMatch;
                return `${year}-${month}-${day}`;
            }
            
            // Tentar parsear como Date
            const parsed = new Date(dateStr);
            if (!isNaN(parsed.getTime())) {
                return formatDateForAPI(parsed);
            }
            
            console.warn('⚠️ Formato de data não reconhecido:', dateStr);
            return null;
        }

        // 🔄 ATUALIZAR APENAS HOJE E ONTEM (30s)
        async function updateRecentData() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const yesterday = new Date(now - 24*60*60*1000).toISOString().split('T')[0];
            
            console.log('⚡ Atualizando apenas hoje e ontem...');
            
            const companies = API_CONFIG.companies;
            const dates = [yesterday, today];
            const promises = [];
            
            dates.forEach(date => {
                companies.forEach(company => {
                    promises.push(
                        fetchDayData(company, date).then(data => ({
                            date,
                            companyId: company.id,
                            data
                        }))
                    );
                });
            });
            
            const results = await Promise.allSettled(promises);
            
            results.forEach(result => {
                if (result.status === 'fulfilled') {
                    const { date, companyId, data } = result.value;
                    const key = `${date}_${companyId}`;
                    SMART_CACHE.today.set(key, data);
                }
            });
            
            SMART_CACHE.metadata.lastUpdate = Date.now();
            console.log('✅ Dados recentes atualizados');
        }

        // 📊 PEGAR DADOS DO CACHE (INSTANTÂNEO)
        // função para buscar batidas de todas as empresas selecionadas
        // 📅 PREENCHER DIAS FALTANTES NO PERÍODO
        // Se um funcionário tem batidas no período mas falta um dia específico,
        // criar registro vazio para esse dia aparecer na tabela
        function fillMissingDays(employees, dateStart, dateEnd, companies) {
            console.log('📅 Verificando dias faltantes no período...');
            
            const start = new Date(dateStart);
            const end = new Date(dateEnd);
            const allDates = [];
            
            // Gerar lista de todas as datas do período
            for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                allDates.push(new Date(d));
            }
            
            console.log(`📅 Período completo: ${allDates.length} dias (${formatDateBR(dateStart)} a ${formatDateBR(dateEnd)})`);
            console.log(`📋 Funcionários recebidos: ${employees.length} registros`);
            
            // Agrupar funcionários por REG + Empresa
            const employeesByRegAndCompany = new Map();
            
            employees.forEach(emp => {
                const key = `${emp.reg}_${emp.empresaId}`;
                if (!employeesByRegAndCompany.has(key)) {
                    employeesByRegAndCompany.set(key, []);
                }
                employeesByRegAndCompany.get(key).push(emp);
            });
            
            console.log(`👥 Funcionários únicos: ${employeesByRegAndCompany.size}`);
            
            const result = [...employees]; // Começar com todos os registros existentes
            let addedDays = 0;
            
            // Para cada funcionário, verificar se tem registro em todos os dias do período
            employeesByRegAndCompany.forEach((empRecords, key) => {
                if (empRecords.length === 0) return;
                
                const [reg, empresaId] = key.split('_');
                const firstRecord = empRecords[0]; // Pegar informações base do primeiro registro
                
                // Verificar quais datas esse funcionário tem
                const existingDates = new Set(
                    empRecords.map(emp => {
                        // Normalizar data (pode vir em vários formatos)
                        if (emp.rawData?.Data) {
                            return new Date(emp.rawData.Data.split('T')[0]).toISOString().split('T')[0];
                        } else if (emp.date) {
                            // Converter DD/MM/YYYY para YYYY-MM-DD
                            const parts = emp.date.split('/');
                            if (parts.length === 3) {
                                return `${parts[2]}-${parts[1].padStart(2,'0')}-${parts[0].padStart(2,'0')}`;
                            }
                        }
                        return null;
                    }).filter(d => d)
                );
                
                // Para cada dia do período, verificar se falta
                allDates.forEach(date => {
                    const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
                    
                    if (!existingDates.has(dateStr)) {
                        // Dia faltando! Criar registro vazio
                        console.log(`➕ Preenchendo dia faltante: ${firstRecord.name} - ${formatDateBR(dateStr)} (${dateStr})`);
                        
                        const emptyRecord = {
                            reg: reg,
                            pis: firstRecord.pis || '',
                            cpf: firstRecord.cpf || '',
                            name: firstRecord.name,
                            city: firstRecord.city,
                            project: firstRecord.project || 'N/A',
                            projetoSecullum: firstRecord.projetoSecullum || null,
                            departamentoSecullum: firstRecord.departamentoSecullum || null,
                            date: formatDateBR(dateStr),
                            day: getDayOfWeek(dateStr),
                            punches: {
                                ent1: '',
                                sai1: '',
                                ent2: '',
                                sai2: '',
                                ent3: '',
                                sai3: '',
                                ent4: '',
                                sai4: '',
                                ent5: '',
                                sai5: ''
                            },
                            motivo: '',
                            attachments: [],
                            hasInconsistency: true, // Marcar como inconsistência (sem batidas)
                            empresa: firstRecord.empresa,
                            empresaId: empresaId,
                            rawData: {
                                Data: `${dateStr}T00:00:00`,
                                _empresa: firstRecord.empresa,
                                _empresaId: empresaId,
                                _funcionarioNome: firstRecord.name,
                                _funcionarioCpf: firstRecord.cpf,
                                // Copiar FuncionarioId e Funcionario do primeiro registro (necessário para envio Secullum)
                                FuncionarioId: firstRecord.rawData?.FuncionarioId || null,
                                Funcionario: firstRecord.rawData?.Funcionario || null
                            },
                            nomeLider: firstRecord.nomeLider || null,
                            projeto: firstRecord.projeto || null
                        };
                        
                        result.push(emptyRecord);
                        addedDays++;
                    }
                });
            });
            
            if (addedDays > 0) {
                console.log(`✅ ${addedDays} dias faltantes preenchidos (registros vazios criados)`);
            } else {
                console.log(`✅ Nenhum dia faltante detectado`);
            }
            
            return result;
        }

        async function fetchEmployeesFromAPI(dateStart, dateEnd) {
            try {
                console.log('🔍 Iniciando busca inteligente...');
                
                // 📦 STEP 1: Carregar cache histórico (se não existir)
                if (!SMART_CACHE.metadata.lastFullLoad) {
                    console.log('📥 PRIMEIRA CARGA: Buscando período selecionado...');
                    await loadFullHistoricalCache(dateStart, dateEnd);
                }
                
                // 🔄 STEP 2: Atualizar APENAS os dados recentes
                const now = Date.now();
                const needsUpdate = !SMART_CACHE.metadata.lastUpdate || 
                                   (now - SMART_CACHE.metadata.lastUpdate) > CACHE_STRATEGY.TTL.today;
                
                if (needsUpdate) {
                    console.log('⚡ Atualizando dados recentes...');
                    await updateRecentData();
                }
                
                // 📊 STEP 3: Montar resultado do cache POR FUNCIONÁRIO
                const startTime = performance.now();
                let allBatidas = getCachedDataByEmployee(dateStart, dateEnd);
                const elapsed = ((performance.now() - startTime)).toFixed(2);
                
                console.log(`✅ ${allBatidas.length} registros prontos em ${elapsed}ms do cache`);
                
                // Validar se há dados no período solicitado
                if (allBatidas.length === 0) {
                    console.warn('⚠️ Nenhum registro encontrado no período selecionado');
                    showAlert('Sem Dados', 'Nenhum registro encontrado no período selecionado. Verifique se o período está dentro dos últimos 60 dias.', 'warning');
                    return [];
                }
                
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                await enrichWithEmployeeNames(allBatidas, companies);
                
                // Auto-refresh: iniciar se não estiver rodando
                if (!autoRefreshInterval) {
                    console.log('🔄 Iniciando auto-refresh (30s)');
                    autoRefreshInterval = setInterval(updateRecentData, CACHE_STRATEGY.TTL.today);
                }
                
                const parsedData = parseSecullumData(allBatidas, dateStart);
                
                // 🔍 PREENCHER DIAS FALTANTES: Se funcionário tem batidas no período, 
                // mas falta algum dia específico, criar registro vazio
                const filledData = fillMissingDays(parsedData, dateStart, dateEnd, companies);
                
                return filledData;
            } catch (error) {
                console.error('❌ Erro ao buscar colaboradores:', error);
                
                // Limpar cache se houver erro crítico
                if (error.message.includes('fetch') || error.message.includes('network')) {
                    console.warn('⚠️ Erro de rede detectado - mantendo cache local');
                } else {
                    console.error('❌ Erro crítico - resetando cache');
                    SMART_CACHE.metadata.lastFullLoad = null;
                }
                
                showAlert('Erro', `Erro ao buscar dados da API: ${error.message}`, 'error');
                return [];
            }
        }
        
        // 🧹 CLEANUP: Parar auto-refresh quando necessário
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('🛑 Auto-refresh parado');
            }
        }
        
        // 🗑️ LIMPAR CACHE: Útil para forçar recarga completa
        function clearCache() {
            SMART_CACHE.employees.clear();
            SMART_CACHE.historical.clear();
            SMART_CACHE.recent.clear();
            SMART_CACHE.today.clear();
            SMART_CACHE.metadata.lastFullLoad = null;
            SMART_CACHE.metadata.lastUpdate = null;
            SMART_CACHE.metadata.totalRequests = 0;
            stopAutoRefresh();
            console.log('🗑️ Cache limpo - próxima busca fará carga completa');
        }
        
        // 🔄 ATUALIZAR FUNCIONÁRIO INDIVIDUAL
        async function refreshEmployee(reg, date, empresaId) {
            try {
                console.log(`🔄 refreshEmployee chamado:`, { reg, date, empresaId });
                showLoading(`⚡ Atualizando ${reg}...`);
                
                // Invalidar e recarregar
                const newData = await invalidateSingleEmployee(reg, date, empresaId);
                console.log(`📦 Dados recebidos:`, newData);
                
                // Atualizar objeto em allEmployees
                const employee = allEmployees.find(e => 
                    e.reg === reg && e.date === date && e.empresaId === empresaId
                );
                console.log(`👤 Funcionário encontrado:`, employee ? 'SIM' : 'NÃO');
                
                if (employee && newData) {
                    // Atualizar punches com dados da API
                    Object.assign(employee.punches, {
                        ent1: newData.Entrada1 || '',
                        sai1: newData.Saida1 || '',
                        ent2: newData.Entrada2 || '',
                        sai2: newData.Saida2 || '',
                        ent3: newData.Entrada3 || '',
                        sai3: newData.Saida3 || '',
                        ent4: newData.Entrada4 || '',
                        sai4: newData.Saida4 || '',
                        ent5: newData.Entrada5 || '',
                        sai5: newData.Saida5 || ''
                    });
                    
                    // Atualizar rawData
                    employee.rawData = newData;
                    
                    // Recalcular status
                    updateEmployeeStatus(employee);
                    
                    // 🔄 RECARREGAR DADOS E RECALCULAR
                    await carregarDadosCompletos().catch(err => console.error('⚠️ Erro ao recarregar dados:', err));
                    recalcularInconsistenciasComAprovacoes();
                    
                    // Re-renderizar tabela
                    renderTable();
                    
                    hideLoading();
                    console.log(`✅ ${reg} atualizado com sucesso!`);
                    
                } else {
                    hideLoading();
                    console.warn(`⚠️ Funcionário ${reg} não encontrado após atualização`);
                    showAlert('Aviso', `Não foi possível atualizar os dados de ${reg}`, 'warning');
                }
                
            } catch (err) {
                hideLoading();
                console.error(`❌ Erro ao atualizar ${reg}:`, err);
                showAlert('Erro', `Erro ao atualizar funcionário: ${err.message}`, 'error');
            }
        }
        
        // Expor função globalmente para debug
        window.clearCache = clearCache;
        window.refreshEmployee = refreshEmployee;
        window.cacheStats = () => {
            console.log('📊 CACHE STATS:');
            console.log(`  Historical: ${SMART_CACHE.historical.size} registros`);
            console.log(`  Recent: ${SMART_CACHE.recent.size} registros`);
            console.log(`  Today: ${SMART_CACHE.today.size} registros`);
            console.log(`  Last Full Load: ${SMART_CACHE.metadata.lastFullLoad ? new Date(SMART_CACHE.metadata.lastFullLoad).toLocaleString() : 'Nunca'}`);
            console.log(`  Last Update: ${SMART_CACHE.metadata.lastUpdate ? new Date(SMART_CACHE.metadata.lastUpdate).toLocaleString() : 'Nunca'}`);
            return {
                historical: SMART_CACHE.historical.size,
                recent: SMART_CACHE.recent.size,
                today: SMART_CACHE.today.size,
                lastFullLoad: SMART_CACHE.metadata.lastFullLoad,
                lastUpdate: SMART_CACHE.metadata.lastUpdate
            };
        };
        
        // Limpar ao sair da página
        window.addEventListener('beforeunload', stopAutoRefresh);

        // função para converter dados da Secullum para formato interno
        function parseSecullumData(batidas, dataRef) {
            // Agrupar batidas por FUNCIONÁRIO + data
            const funcionariosMap = new Map();

            batidas.forEach(batida => {
                // Pegar informaçõeses do FUNCIONÁRIO
                const reg = batida.Funcionario?.NumeroIdentificador || batida.Funcionario?.NumeroFolha || batida.FuncionarioId || 'N/A';
                const pis = batida.Funcionario?.NumeroPis || '';
                const dataFormatada = batida.Data || dataRef;
                const key = `${reg}_${dataFormatada}`;
                
                if (!funcionariosMap.has(key)) {
                    funcionariosMap.set(key, {
                        reg: reg,
                        pis: pis,
                        cpf: batida._funcionarioCpf || '',
                        name: batida._funcionarioNome || `FUNCIONÁRIO ${reg}`,
                        city: batida._empresa || 'N/A',
                        project: 'N/A',
                        projetoSecullum: batida._projetoSecullum || null, // ? PROJETO DA API SECULLUM
                        departamentoSecullum: batida._projetoSecullum ? String(batida._projetoSecullum) : null, // ? DEPTO SECULLUM
                        date: formatDateBR(dataFormatada),
                        day: getDayOfWeek(dataFormatada),
                        punches: {
                            ent1: '',
                            sai1: '',
                            ent2: '',
                            sai2: '',
                            ent3: '',
                            sai3: '',
                            ent4: '',
                            sai4: '',
                            ent5: '',
                            sai5: ''
                        },
                        motivo: batida.Observacoes || '',
                        attachments: [],
                        hasInconsistency: false,
                        empresa: batida._empresa || 'N/A',
                        empresaId: batida._empresaId || '',
                        rawData: batida
                    });
                }

                const func = funcionariosMap.get(key);
                
                // DEBUG: Log para investigar afastamentos
                if (batida.Entrada1 === 'A. INSS' || batida.Entrada1 === 'AFASTAMENTO INSS') {
                    console.log('🏥 AFASTAMENTO DETECTADO:', {
                        nome: batida._funcionarioNome,
                        reg: reg,
                        data: dataFormatada,
                        entrada1: batida.Entrada1,
                        saida1: batida.Saida1,
                        entrada2: batida.Entrada2,
                        saida2: batida.Saida2,
                        entrada3: batida.Entrada3,
                        saida3: batida.Saida3,
                        entrada4: batida.Entrada4,
                        saida4: batida.Saida4,
                        entrada5: batida.Entrada5,
                        saida5: batida.Saida5,
                        observacoes: batida.Observacoes,
                        dadosCompletos: batida
                    });
                }
                
                // Pegar Horários das entradas/SAÍdas
                // funçãoo auxiliar para verificar se ã Horário válido (HH:MM)
                const isValidTime = (val) => {
                    if (!val) return false;
                    // Verifica se ã formato de Horário (ex: 08:00, 12:30)
                    return /^\d{1,2}:\d{2}$/.test(val);
                };
                
                // Pegar Horários válidos (HH:mm) OU texto de justificativa (FOLGA, FALTA, etc)
                func.punches.ent1 = batida.Entrada1 || '';
                func.punches.sai1 = batida.Saida1 || '';
                func.punches.ent2 = batida.Entrada2 || '';
                func.punches.sai2 = batida.Saida2 || '';
                func.punches.ent3 = batida.Entrada3 || '';
                func.punches.sai3 = batida.Saida3 || '';
                func.punches.ent4 = batida.Entrada4 || '';
                func.punches.sai4 = batida.Saida4 || '';
                func.punches.ent5 = batida.Entrada5 || '';
                func.punches.sai5 = batida.Saida5 || '';
                
                // Detectar motivos especiais para marcar como FALTA ou AFASTAMENTO
                const statusEspeciais = ['FALTA', 'FERIAS', 'A. INSS', 'AFASTAMENTO INSS', 'A.INSS', 'L.MATER', 'L. MATER', 'LIC.MATERNIDADE'];
                
                // Detectar motivos especiais em qualquer entrada
                const todasEntradas = [
                    batida.Entrada1, batida.Saida1, batida.Entrada2, batida.Saida2,
                    batida.Entrada3, batida.Saida3, batida.Entrada4, batida.Saida4,
                    batida.Entrada5, batida.Saida5
                ];
                
                // Procurar por status especial
                for (const entrada of todasEntradas) {
                    if (entrada && statusEspeciais.includes(entrada)) {
                        if (entrada === 'FALTA') {
                            func.motivo = 'FALTA';
                        } else if (entrada === 'FERIAS') {
                            func.motivo = 'FÉRIAS';
                        } else if (entrada === 'A. INSS' || entrada === 'AFASTAMENTO INSS' || entrada === 'A.INSS') {
                            func.motivo = 'AFASTAMENTO INSS';
                        } else if (entrada === 'L.MATER' || entrada === 'L. MATER' || entrada === 'LIC.MATERNIDADE') {
                            func.motivo = 'LICENÇA MATERNIDADE';
                        }
                        break; // já encontrou o motivo, não precisa continuar
                    }
                }

                // Verificar inconsistências
                // REGRAS ATUALIZADAS:
                // - Pontos ímpares (entrada sem saída) = inconsistência
                // - Horários trocados (ordem errada) = inconsistência
                // - 6 batidas = NORMAL (não é inconsistência)
                // - Dept 400: 2 batidas OK
                // - Domingos: ignorar para departamentos específicos
                
                const batidas = [
                    func.punches.ent1, func.punches.sai1,
                    func.punches.ent2, func.punches.sai2,
                    func.punches.ent3, func.punches.sai3,
                    func.punches.ent4, func.punches.sai4,
                    func.punches.ent5, func.punches.sai5
                ].filter(h => h && h !== '--:--');
                
                const totalBatidas = batidas.length;
                
                // ❌ SEM BATIDA NENHUMA = INCONSISTÊNCIA (exceto se tiver motivo especial)
                // Se tem motivo especial (férias, afastamento, falta justificada, etc), NÃO é inconsistência
                const motivosEspeciais = ['FALTA', 'FÉRIAS', 'AFASTAMENTO INSS', 'LICENÇA MATERNIDADE', 'FOLGA'];
                const temMotivoEspecial = motivosEspeciais.includes(func.motivo);
                
                const semBatidaNenhuma = totalBatidas === 0 && !temMotivoEspecial;
                
                // TAREFA 8: Departamento 400 permite apenas 2 batidas (ent1 + sai1)
                const isDept400 = String(func.Departamento || '').includes('400') || String(func.projetoSecullum || '').includes('400');
                
                // TAREFA 9: Verificar se é domingo e se deve ignorar
                const dataBatida = new Date(func.rawData?.Data || func.date);
                const diaSemana = dataBatida.getDay(); // 0 = Domingo, 6 = Sábado
                const isDomingo = diaSemana === 0;
                const isSegundaASabado = diaSemana >= 1 && diaSemana <= 6;
                
                // 🏢 REGRA ALR: Segunda a Sábado = 4 batidas obrigatórias
                const empresaNome = func.rawData?.['Empresa Nome'] || func.empresaNome || func.empresa || '';
                const isALR = empresaNome.includes('ALR');
                
                // Departamentos que não contabilizam domingos como inconsistência
                const deptsSemDomingo = {
                    'LARSIL': ['202', '207', '209', '400', '706', '961'],
                    'S5 FLORESTAL': ['400'],
                    'ALR EMPREENDIMENTOS': ['400'],
                    'DS3': ['400']
                };
                
                let ignorarDomingo = false;
                if (isDomingo) {
                    const empresaNome = func.rawData?.['Empresa Nome'] || func.empresaNome || '';
                    const dept = String(func.Departamento || func.projetoSecullum || '');
                    
                    for (const [empresa, depts] of Object.entries(deptsSemDomingo)) {
                        if (empresaNome.includes(empresa)) {
                            if (depts.some(d => dept.includes(d))) {
                                ignorarDomingo = true;
                                break;
                            }
                        }
                    }
                }
                
                // função para converter HH:MM em minutos
                const timeToMinutes = (time) => {
                    if (!time) return 0;
                    const [h, m] = time.split(':').map(Number);
                    return h * 60 + m;
                };
                
                // VALIDAR ORDEM DOS HORÁRIOS (tarefa 6: continuar destacando em vermelho)
                let ordemIncorreta = false;
                const horariosOrdenados = [
                    { nome: 'Entrada 1', hora: func.punches.ent1 },
                    { nome: 'Saída 1', hora: func.punches.sai1 },
                    { nome: 'Entrada 2', hora: func.punches.ent2 },
                    { nome: 'Saída 2', hora: func.punches.sai2 },
                    { nome: 'Entrada 3', hora: func.punches.ent3 },
                    { nome: 'Saída 3', hora: func.punches.sai3 },
                    { nome: 'Entrada 4', hora: func.punches.ent4 },
                    { nome: 'Saída 4', hora: func.punches.sai4 },
                    { nome: 'Entrada 5', hora: func.punches.ent5 },
                    { nome: 'Saída 5', hora: func.punches.sai5 }
                ].filter(h => h.hora && h.hora !== '--:--');
                
                for (let i = 1; i < horariosOrdenados.length; i++) {
                    const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                    const atual = timeToMinutes(horariosOrdenados[i].hora);
                    
                    if (atual <= anterior) {
                        ordemIncorreta = true;
                        console.log(` Ordem incorreta: ${func.name} - ${horariosOrdenados[i - 1].nome} (${horariosOrdenados[i - 1].hora}) >= ${horariosOrdenados[i].nome} (${horariosOrdenados[i].hora})`);
                        break;
                    }
                }
                
                // ✅ VERIFICAR SE ORDEM INCORRETA FOI APROVADA PELO RH
                const ordemAprovada = func.approved && func.approved['ordem_horarios'] === true;
                if (ordemIncorreta) {
                    console.log(`🔍 ${func.name} - Ordem incorreta detectada. Verificando aprovação:`, {
                        hasApproved: !!func.approved,
                        approvedKeys: func.approved ? Object.keys(func.approved) : [],
                        ordemHorarios: func.approved?.ordem_horarios,
                        ordemAprovada: ordemAprovada
                    });
                }
                if (ordemAprovada) {
                    console.log(`✅ ${func.name}: Ordem de horários APROVADA, removendo inconsistência`);
                    ordemIncorreta = false; // Se foi aprovado, não é mais inconsistência
                }
                
                // TAREFA 6: Verificar pontos ímpares (entrada sem saída)
                const pontosImpares = totalBatidas % 2 !== 0; // Ímpar = falta entrada ou saída
                
                // REGRAS DE INCONSISTÊNCIA:
                let batidaIncorreta = false;
                
                if (isDept400) {
                    // Dept 400: aceita 2 batidas (ent1 + sai1) OU 4 batidas (horário normal com intervalo)
                    batidaIncorreta = (totalBatidas !== 2 && totalBatidas !== 4);
                } else if (ignorarDomingo) {
                    // Domingo nos departamentos especificados: não é inconsistência
                    batidaIncorreta = false;
                } else if (isALR && isSegundaASabado) {
                    // 🏢 ALR: Segunda a Sábado = EXATAMENTE 4 batidas (menos ou mais é inconsistência)
                    batidaIncorreta = totalBatidas !== 4 || ordemIncorreta;
                    if (batidaIncorreta && totalBatidas !== 4) {
                        console.log(`⚠️ ALR ${func.name}: ${totalBatidas} batidas (esperado: 4)`);
                    }
                } else {
                    // Regra geral:
                    // - SEM BATIDA = inconsistência
                    // - Pontos ímpares = inconsistência
                    // - Ordem incorreta = inconsistência  
                    // - 6 batidas = OK (não é inconsistência)
                    // - 4 batidas = OK (não é inconsistência)
                    // - Outros números pares >= 2 = OK
                    batidaIncorreta = semBatidaNenhuma || pontosImpares || ordemIncorreta;
                }
                
                if (batidaIncorreta && !temMotivoEspecial) {
                    console.log(`❌ ${func.name} marcado como INCONSISTÊNCIA:`, {
                        pontosImpares,
                        ordemIncorreta,
                        batidaIncorreta,
                        temMotivoEspecial,
                        totalBatidas,
                        ordemAprovada: func.approved?.ordem_horarios
                    });
                    func.hasInconsistency = true;
                }
            });

            return Array.from(funcionariosMap.values());
        }

        // funções auxiliares
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('pt-BR');
        }

        function getDayOfWeek(dateString) {
            const days = ['domingo', 'segunda-feira', 'terça-feira', 'quarta-feira', 'quinta-feira', 'sexta-feira', 'sábado'];
            
            let date;
            
            // Formato estranho: 27T00:00:00/10/2025
            const strangeMatch = dateString.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
            if (strangeMatch) {
                const [_, dia, mes, ano] = strangeMatch;
                date = new Date(ano, parseInt(mes) - 1, parseInt(dia));
            }
            // Se esté no formato dd/mm/yyyy
            else if (dateString.includes('/') && !dateString.includes('T')) {
                const parts = dateString.split('/');
                date = new Date(parts[2], parts[1] - 1, parts[0]);
            } 
            // Se esté no formato ISO (YYYY-MM-DD)
            else if (dateString.includes('-')) {
                date = new Date(dateString.split('T')[0] + 'T00:00:00');
            } 
            // Outro formato
            else {
                date = new Date(dateString);
            }
            
            return days[date.getDay()];
        }

        function formatDateBR(dateString) {
            if (!dateString) return '';
            
            // Formato estranho: 27T00:00:00/10/2025 ou similar
            // Precisamos extrair: dia, més, ano
            
            // Tentar extrair padrão: DDT00:00:00/MM/YYYY
            const strangeMatch = dateString.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
            if (strangeMatch) {
                const [_, dia, mes, ano] = strangeMatch;
                return `${dia.padStart(2, '0')}/${mes.padStart(2, '0')}/${ano}`;
            }
            
            // Se já esté em formato brasileiro (DD/MM/YYYY)
            if (/^\d{1,2}\/\d{1,2}\/\d{4}$/.test(dateString)) {
                const parts = dateString.split('/');
                return `${parts[0].padStart(2, '0')}/${parts[1].padStart(2, '0')}/${parts[2]}`;
            }
            
            // Se esté em formato ISO (YYYY-MM-DD)
            if (/^\d{4}-\d{1,2}-\d{1,2}/.test(dateString)) {
                const [year, month, day] = dateString.split('-').map(p => p.split('T')[0]);
                return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
            }
            
            // Retornar original se não conseguir formatar
            return dateString;
        }

        // ==========================================
        // DADOS REAIS DA API
        // ==========================================
        let allEmployees = [];

        let showOnlyInconsistencies = false;
        let selectedEmployees = [];
        let useDigitalSignature = false;
        let isAPIConnected = false;
        
        // 🔧 CORREÇÃO: Flags de controle para evitar race conditions
        let renderingTable = false;
        let loadingAnexos = false;

        // � PAGINAÇÃO: Controles de página
        let currentPage = 1;
        const ITEMS_PER_PAGE = 100; // Mostrar 100 linhas por página

        // �🔧 CORREÇÃO: Event delegation - executar apenas UMA VEZ
        (function initEventListeners() {
            const tableBody = document.getElementById('employeeTable');
            
            // Checkboxes
            tableBody.addEventListener('change', (e) => {
                if (!e.target.classList.contains('employee-checkbox')) return;
                handleCheckboxChange(e);
            });
            
            // Clique simples: Abrir modal de perguntas/aprovação
            tableBody.addEventListener('click', (e) => {
                console.log('🖱️ CLICK detectado:', e.target);
                
                // Verificar se é uma célula de horário
                const cell = e.target.closest('td[data-punch]');
                if (!cell) {
                    console.log('❌ Não é uma célula de horário');
                    return;
                }
                
                console.log('✅ É uma célula de horário:', cell.dataset.punch);
                
                // Ignorar se clicou em um ícone ou botão dentro da célula
                if (e.target.closest('.question-icon, .approve-icon, .delete-question-icon, button, .arrow')) {
                    console.log('❌ Clicou em ícone/botão, ignorando');
                    return;
                }
                
                const reg = cell.dataset.reg;
                const date = cell.dataset.date;
                const punchType = cell.dataset.punch;
                
                // Buscar funcionário
                const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                if (!employee) {
                    console.log('❌ Funcionário não encontrado');
                    return;
                }
                
                console.log(`🖱️ Clique na célula: ${employee.name} - ${punchType} - ${employee.punches[punchType]}`);
                
                // Se a célula tem class 'swapped', abrir modal de aprovação
                if (cell.classList.contains('swapped')) {
                    console.log('✅ Abrindo modal de aprovação (horário trocado)');
                    approveSwappedTime(e, reg, date, punchType, employee.name);
                } else if (employee.punches[punchType] && employee.punches[punchType] !== '--:--') {
                    // Se tem horário, abrir modal de pergunta
                    console.log('✅ Abrindo modal de pergunta');
                    askQuestion(e, reg, date, punchType, employee.name);
                } else {
                    console.log('❌ Célula vazia, não fazer nada');
                }
            }, true); // USE CAPTURE PHASE para capturar antes do drag
            
            // Edição inline (duplo clique)
            tableBody.addEventListener('dblclick', (e) => {
                const cell = e.target.closest('td[data-punch]');
                if (cell && !cell.classList.contains('editing')) {
                    startInlineEdit(cell);
                }
            });
            
            console.log('? Event listeners inicializados (event delegation)');
        })();

        function handleCheckboxChange(e) {
            e.stopPropagation();
            const uniqueId = e.target.dataset.id;
            
            if (e.target.checked) {
                if (!selectedEmployees.includes(uniqueId)) {
                    selectedEmployees.push(uniqueId);
                }
            } else {
                selectedEmployees = selectedEmployees.filter(id => id !== uniqueId);
            }
            
            const row = e.target.closest('tr');
            if (row) row.classList.toggle('selected', e.target.checked);
            
            updateSelectionCounter();
        }

        // Conectar ã API (apenas autenticação)
        async function connectToAPI() {
            const apiStatus = document.getElementById('apiStatus');
            
            apiStatus.innerHTML = '? Autenticando...';
            
            const authenticated = await authenticateAPI();
            
            if (authenticated) {
                isAPIConnected = true;
                
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; display: inline-block;"></span> API Conectada';
                
                console.log(`? API conectada com ${API_CONFIG.companies.length} empresa(s)`);
                
                return true;
            } else {
                apiStatus.className = 'api-status disconnected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span> Erro na conexão';
                return false;
            }
        }

        // Buscar dados do Período
        async function searchPeriod() {
            const dateStart = document.getElementById('dateStart').value;
            const dateEnd = document.getElementById('dateEnd').value;
            const apiStatus = document.getElementById('apiStatus');
            
            if (!dateStart || !dateEnd) {
                showAlert('Atenção', 'Por favor, selecione as datas de Início e fim!', 'warning');
                return;
            }
            
            // Calcular dias do Período
            const start = new Date(dateStart);
            const end = new Date(dateEnd);
            const diffTime = Math.abs(end - start);
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            
            // Avisar se o Período for muito longo
            if (diffDays > 365) {
                showAlert(
                    'Período Muito Longo!',
                    `você está buscando ${diffDays} dias de dados!\n\nIsso pode:\n• Demorar muito tempo (vários minutos)\n• Sobrecarregar a API\n• Causar erros de timeout\n\n💡 Sugestão: Busque Períodos menores (1 mês por vez)`,
                    'warning'
                );
                return;
            } else if (diffDays > 90) {
                console.warn(`⚠️ Período longo: ${diffDays} dias. Pode demorar...`);
            }
            
            showLoading(`Buscando ${diffDays} dias de dados...`);
            apiStatus.innerHTML = `? Buscando ${diffDays} dias de dados...`;
            const startTime = performance.now();
            
            const apiData = await fetchEmployeesFromAPI(dateStart, dateEnd);
            
            const endTime = performance.now();
            const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
            
            if (apiData && apiData.length > 0) {
                allEmployees.length = 0;
                allEmployees.push(...apiData);
                
                // Ordenar alfabeticamente ao carregar
                allEmployees.sort((a, b) => a.name.localeCompare(b.name));
                
                // FAZER MATCH COM SQL AZURE (buscar Líder e PROJETO)
                const cpfs = [...new Set(allEmployees.map(emp => emp.cpf).filter(cpf => cpf))];
                const sqlData = await getColaboradoresBatchCPF(cpfs);
                
                // Fazer match por CPF
                allEmployees.forEach(emp => {
                    if (emp.cpf) {
                        const cpfLimpo = emp.cpf.replace(/[^\d]/g, '');
                        const sqlColab = sqlColaboradoresCache[cpfLimpo];
                        if (sqlColab) {
                            emp.nomeLider = sqlColab.NOME_LIDER || sqlColab.Lider || null;
                            emp.projeto = sqlColab.PROJETO || sqlColab.Projeto || null;
                        } else {
                            emp.nomeLider = null;
                            emp.projeto = null;
                        }
                    }
                    
                    // Adicionar departamento Secullum (DEPTO SEC) - buscar sempre
                    if (emp.projetoSecullum) {
                        // Usar o projetoSecullum que já vem enriquecido das batidas
                        emp.departamentoSecullum = String(emp.projetoSecullum);
                    } else if (emp.rawData?.Departamento) {
                        // Fallback: extrair do rawData.Departamento
                        const dept = emp.rawData.Departamento;
                        if (typeof dept === 'object' && dept.Codigo) {
                            emp.departamentoSecullum = String(dept.Codigo);
                        } else if (typeof dept === 'string') {
                            emp.departamentoSecullum = dept;
                        } else {
                            emp.departamentoSecullum = null;
                        }
                    } else {
                        emp.departamentoSecullum = null;
                    }
                });
                
                // 🚀 CARREGAR TODOS OS DADOS EM BATCH (1 request ao invés de 180+)
                await carregarDadosCompletos().catch(err => console.error('❌ Erro ao carregar dados:', err));
                await carregarIDs().catch(err => console.error('? Erro ao carregar IDs:', err));
                
                hideLoading();
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = `📊 ${apiData.length} registros (${timeElapsed}s)`;
                
                renderTable();
                
                // 🔧 WORKAROUND: Garantir renderização após processamento
                setTimeout(() => {
                    console.log('🔄 [FORÇADO] Chamando renderTable() novamente...');
                    console.log('🔄 allEmployees.length:', allEmployees.length);
                    renderTable();
                }, 100);
                
                showAlert(
                    'Dados Carregados!',
                    `${apiData.length} registros carregados em ${timeElapsed}s`,
                    'success'
                );
            } else {
                hideLoading();
                showAlert('Sem Dados', 'Nenhum registro encontrado neste Período!', 'warning');
                apiStatus.className = 'api-status connected';
                apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #f59e0b; border-radius: 50%; display: inline-block;"></span> API Conectada';
            }
        }
        
        // 📎 CARREGAR ANEXOS DIRETO DO AZURE SQL (TABELA ANEXOS)
        // 🚀 FUNÇÃO UNIFICADA: Carregar todos os dados em BATCH (1 request ao invés de 180+)
        async function carregarDadosCompletos() {
            loadingAnexos = true;
            
            try {
                const dataInicio = document.getElementById('dateStart').value;
                const dataFim = document.getElementById('dateEnd').value;
                
                // Buscar empresas selecionadas
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                const empresaIds = companies.map(c => c.id);
                
                console.log('🚀 Carregando dados em BATCH:', { dataInicio, dataFim, empresaIds });
                
                // 🎯 1 ÚNICO REQUEST ao backend
                const response = await fetch(`${API_BASE_URL}/api/anexos/batch-period`, {
                    method: 'POST',
                    headers: {
                        ...getAuthHeaders(),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        dateStart: dataInicio,
                        dateEnd: dataFim,
                        empresaIds: empresaIds
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Erro desconhecido' }));
                    console.error('❌ Erro do servidor:', errorData);
                    throw new Error(errorData.error || 'Erro ao carregar dados em batch');
                }
                
                const { anexos, perguntas, aprovacoes, totalRecords } = await response.json();
                
                console.log(`✅ Dados carregados: ${totalRecords} registros no banco`);
                
                // 📋 Aplicar dados aos funcionários
                allEmployees.forEach(emp => {
                    // Normalizar data do funcionário
                    let dataEmp = '';
                    if (emp.rawData?.Data) {
                        // Formato estranho: 27T00:00:00/10/2025 -> 2025-10-27
                        const partsStrange = emp.rawData.Data.match(/(\d+)T\d{2}:\d{2}:\d{2}\/(\d+)\/(\d{4})/);
                        if (partsStrange) {
                            const dia = partsStrange[1].padStart(2, '0');
                            const mes = partsStrange[2].padStart(2, '0');
                            const ano = partsStrange[3];
                            dataEmp = `${ano}-${mes}-${dia}`;
                        } else {
                            dataEmp = emp.rawData.Data.split('T')[0];
                        }
                    } else if (emp.date) {
                        // Formato brasileiro: DD/MM/YYYY -> YYYY-MM-DD
                        const partsBR = emp.date.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
                        if (partsBR) {
                            dataEmp = `${partsBR[3]}-${partsBR[2]}-${partsBR[1]}`;
                        } else {
                            dataEmp = emp.date.split('T')[0];
                        }
                    }
                    
                    const cpfEmp = String(emp.cpf || '').replace(/[.\-]/g, '').trim();
                    const empresaId = emp.empresaId || emp.companyId;
                    
                    // 🔍 Buscar anexos para este funcionário
                    if (anexos[dataEmp] && anexos[dataEmp][empresaId]) {
                        const anexosFuncionario = anexos[dataEmp][empresaId].filter(a => {
                            const cpfAnexo = String(a.cpf || '').replace(/[.\-]/g, '').trim();
                            return cpfAnexo === cpfEmp;
                        });
                        
                        if (anexosFuncionario.length > 0) {
                            const anexo = anexosFuncionario[0];
                            emp.anexoId = anexo.id;
                            emp.anexoUrl = anexo.blob_url;
                            emp.anexoDate = dataEmp;
                            emp.attachments = anexo.blob_filename ? [anexo.blob_filename] : [];
                            emp.id = anexo.id; // ID para impressão
                        }
                    }
                    
                    // 💬 Buscar perguntas para este funcionário
                    const perguntaKey = `${emp.reg}_${dataEmp}`;
                    if (perguntas[perguntaKey]) {
                        emp.questions = emp.questions || {};
                        emp.approved = emp.approved || {};
                        
                        for (const [key, value] of Object.entries(perguntas[perguntaKey])) {
                            if (key.endsWith('_approved')) {
                                const punchType = key.replace('_approved', '');
                                emp.approved[punchType] = value;
                            } else if (key === 'ordem_horarios') {
                                emp.ordemHorariosAprovada = true;
                            } else {
                                emp.questions[key] = value;
                            }
                        }
                    }
                    
                    // ✅ Buscar aprovações para este funcionário
                    if (aprovacoes[perguntaKey]) {
                        emp.approved = emp.approved || {};
                        Object.assign(emp.approved, aprovacoes[perguntaKey]);
                    }
                });
                
                console.log('✅ Dados aplicados aos funcionários');
                loadingAnexos = false;
                
            } catch (err) {
                console.error('❌ Erro ao carregar dados completos:', err);
                loadingAnexos = false;
                showAlert('❌ Erro', `Erro ao carregar dados:\n${err.message}`, 'error');
            }
        }

        // 🗑️ FUNÇÃO ANTIGA: carregarAnexos (DESCONTINUADA - usar carregarDadosCompletos)
        async function carregarAnexos() {
            loadingAnexos = true;
            
            try {
                const dataInicio = document.getElementById('dateStart').value;
                const dataFim = document.getElementById('dateEnd').value;
                
                // Buscar empresas selecionadas corretamente
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                const empresasSelecionadas = companies.map(c => c.id);
                
                for (let empresaId of empresasSelecionadas) {
                    // Buscar anexos de cada dia do Período
                    const inicio = new Date(dataInicio);
                    const fim = new Date(dataFim);
                    
                    for (let d = new Date(inicio); d <= fim; d.setDate(d.getDate() + 1)) {
                        const dataStr = d.toISOString().split('T')[0];
                        
                        try {
                            const response = await fetch(`${API_BASE_URL}/api/anexos/${dataStr}/${empresaId}`);
                            
                            if (!response.ok) {
                                continue; // Nenhum anexo nesta data
                            }
                            
                            const anexos = await response.json();
                            
                            if (Array.isArray(anexos) && anexos.length > 0) {
                                
                                
                                // ? FAZER MATCH COM FUNCIONÁRIOS USANDO CPF + DATA (identificador único)
                                anexos.forEach(anexo => {
                                    
                                    
                                    // Normalizar data do anexo (pode vir como 2025-10-24T00:00:00.000Z ou 2025-10-24)
                                    const dataAnexo = anexo.data.split('T')[0];
                                    
                                    // ? BUSCAR FUNCIONÁRIO POR CPF + DATA (exato, não parcial!)
                                    const emp = allEmployees.find(e => {
                                        // Match CPF exato (remover pontos e traãos para comparar apenas nçãmeros)
                                        const cpfEmp = String(e.cpf || '').replace(/[.\-]/g, '').trim();
                                        const cpfAnexo = String(anexo.cpf || '').replace(/[.\-]/g, '').trim();
                                        
                                        if (cpfEmp !== cpfAnexo || !cpfEmp) return false;
                                        
                                        // Normalizar data do FUNCIONÁRIO
                                        let dataEmp = '';
                                        if (e.rawData?.Data) {
                                            // Tentar formato estranho da API: 27T00:00:00/10/2025 -> 2025-10-27
                                            const partsStrange = e.rawData.Data.match(/(\d+)T\d{2}:\d{2}:\d{2}\/(\d+)\/(\d{4})/);
                                            if (partsStrange) {
                                                const dia = partsStrange[1].padStart(2, '0');
                                                const mes = partsStrange[2].padStart(2, '0');
                                                const ano = partsStrange[3];
                                                dataEmp = `${ano}-${mes}-${dia}`;
                                            } else {
                                                // Formato ISO normal: 2025-10-24T00:00:00
                                                dataEmp = e.rawData.Data.split('T')[0];
                                            }
                                        } else if (e.date) {
                                            dataEmp = e.date.split('T')[0];
                                        }
                                        
                                        // Match DATA exata
                                        const match = dataEmp === dataAnexo;
                                        
                                        if (match) {
                                            
                                        }
                                        
                                        return match;
                                    });
                                    
                                    if (emp) {
                                        emp.anexoId = anexo.id; // 🆔 ID da tabela ANEXOS
                                        emp.anexoUrl = anexo.blob_url;
                                        emp.anexoDate = dataAnexo; // 📅 Guardar data do anexo
                                        emp.motivo = anexo.motivo_detectado || emp.motivo;
                                        emp.attachments = [anexo.blob_filename];
                                        
                                        
                                        
                                        // 💬 CARREGAR PERGUNTAS E APROVAÇÕES DO RH DO BANCO DE DADOS
                                        if (anexo.perguntas_rh && anexo.perguntas_rh !== '{}') {
                                            try {
                                                const allData = JSON.parse(anexo.perguntas_rh);
                                                
                                                // Separar perguntas de aprovações
                                                emp.questions = {};
                                                emp.approved = {};
                                                
                                                for (const [key, value] of Object.entries(allData)) {
                                                    if (key.endsWith('_approved')) {
                                                        // ã uma aprovação (ex: "ent1_approved")
                                                        const punchType = key.replace('_approved', '');
                                                        emp.approved[punchType] = value;
                                                    } else if (key === 'ordem_horarios') {
                                                        // ✅ Flag especial: ordem_horarios aprovada
                                                        emp.approved['ordem_horarios'] = value;
                                                    } else {
                                                        // ã uma pergunta normal
                                                        emp.questions[key] = value;
                                                    }
                                                }
                                                
                                                const numPerguntas = Object.keys(emp.questions).length;
                                                const numAprovacoes = Object.keys(emp.approved).length;
                                                
                                                if (numPerguntas > 0) {
                                                    
                                                }
                                                if (numAprovacoes > 0) {
                                                    
                                                }
                                            } catch (err) {
                                                console.warn(`⚠️ Erro ao parsear perguntas_rh para ${emp.name}:`, err);
                                                emp.questions = {};
                                                emp.approved = {};
                                            }
                                        } else {
                                            emp.questions = {};
                                            emp.approved = {};
                                        }
                                        
                                        // ? não PREENCHER BATIDAS DO SQL!
                                        // A tabela deve mostrar APENAS dados da Secullum
                                        // Os Horários salvos no anexo Sóo apenas backup/histórico
                                        
                                        
                                    } else {
                                        console.warn(`⚠️ Anexo não vinculado: REG ${anexo.reg} - ${dataAnexo} (FUNCIONÁRIO não encontrado)`);
                                    }
                                });
                            }
                        } catch (err) {
                            console.warn(`ℹ Erro ao buscar anexos de ${dataStr}:`, err.message);
                        }
                    }
                }
                
                console.log('? Carregamento de anexos concluído!');
                
            } catch (err) {
                console.error('? Erro ao carregar anexos:', err);
            } finally {
                loadingAnexos = false;
            }
        }

        // Carregar perguntas e aprovações de TODOS os funcionários (mesmo sem anexo)
        async function carregarPerguntasEAprovacoes() {
            try {
                const dataInicio = document.getElementById('dateStart').value;
                const dataFim = document.getElementById('dateEnd').value;
                
                const companies = API_CONFIG.selectedCompanies.includes('all') 
                    ? API_CONFIG.companies 
                    : API_CONFIG.companies.filter(c => API_CONFIG.selectedCompanies.includes(c.id));
                
                const empresasSelecionadas = companies.map(c => c.id);
                
                // ? ADICIONAR empresa_id = 0 (registros sem empresa específica)
                if (!empresasSelecionadas.includes('0')) {
                    empresasSelecionadas.push('0');
                }
                
                console.log('🏢 Empresas a consultar (incluindo 0):', empresasSelecionadas);
                
                for (let empresaId of empresasSelecionadas) {
                    const inicio = new Date(dataInicio);
                    const fim = new Date(dataFim);
                    
                    for (let d = new Date(inicio); d <= fim; d.setDate(d.getDate() + 1)) {
                        const dataStr = d.toISOString().split('T')[0];
                        
                        try {
                            const response = await fetch(`${API_BASE_URL}/api/anexos/${dataStr}/${empresaId}`, {
                                headers: getAuthHeaders()
                            });
                            
                            if (!response.ok) continue;
                            
                            const anexos = await response.json();
                            
                            if (Array.isArray(anexos) && anexos.length > 0) {
                                
                                anexos.forEach(anexo => {
                                    if (!anexo.perguntas_rh) return;
                                    
                                    // ? IGNORAR se perguntas_rh for "{}" vazio
                                    if (anexo.perguntas_rh === '{}') return;
                                    
                                    // ? MATCH APENAS POR CPF + DATA (não filtrar por empresa)
                                    // Comentérios Sóo do CPF, não da empresa!
                                    
                                    // Buscar FUNCIONÁRIO por CPF e DATA
                                    const cpfAnexo = (anexo.cpf || '').replace(/\D/g, '');
                                    const dataAnexo = dataStr;
                                    
                                    // DEBUG: Log de busca
                                    if (anexo.perguntas_rh && anexo.perguntas_rh !== '{}') {
                                    
                                        
                                    }
                                    
                                    const emp = allEmployees.find(e => {
                                        const cpfEmp = (e.cpf || '').replace(/\D/g, '');
                                        if (cpfEmp !== cpfAnexo || !cpfEmp) return false;
                                        
                                        let dataEmp = null;
                                        if (e.rawData?.Data) {
                                            const partsStrange = e.rawData.Data.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
                                            if (partsStrange) {
                                                const dia = partsStrange[1].padStart(2, '0');
                                                const mes = partsStrange[2].padStart(2, '0');
                                                const ano = partsStrange[3];
                                                dataEmp = `${ano}-${mes}-${dia}`;
                                            } else {
                                                dataEmp = e.rawData.Data.split('T')[0];
                                            }
                                        } else if (e.date) {
                                            // Converter formato brasileiro DD/MM/YYYY para ISO YYYY-MM-DD
                                            const partsBR = e.date.match(/^(\d{2})\/(\d{2})\/(\d{4})/);
                                            if (partsBR) {
                                                dataEmp = `${partsBR[3]}-${partsBR[2]}-${partsBR[1]}`;
                                            } else {
                                                dataEmp = e.date.split('T')[0];
                                            }
                                        }
                                        
                                        return dataEmp === dataAnexo;
                                    });
                                    
                                    if (emp) {
                                        try {
                                            const allData = JSON.parse(anexo.perguntas_rh);
                                            
                                            emp.questions = emp.questions || {};
                                            emp.approved = emp.approved || {};
                                            
                                            for (const [key, value] of Object.entries(allData)) {
                                                if (key.endsWith('_approved')) {
                                                    const punchType = key.replace('_approved', '');
                                                    emp.approved[punchType] = value;
                                                } else if (key === 'ordem_horarios') {
                                                    // ✅ Flag especial: ordem_horarios aprovada
                                                    emp.approved['ordem_horarios'] = value;
                                                    console.log(`✅ ${emp.name}: ordem_horarios carregado = ${value}`);
                                                } else {
                                                    emp.questions[key] = value;
                                                }
                                            }
                                            
                                            console.log(`? ${emp.name}: aprovações carregadas:`, emp.approved);
                                            
                                        } catch (err) {
                                            console.warn(`ℹ Erro ao parsear perguntas_rh:`, err);
                                        }
                                    } else {
                                        // DEBUG: FUNCIONÁRIO não encontrado
                                        console.warn(`ℹ Anexo não vinculado: CPF=${cpfAnexo}, Data=${dataAnexo}, Perguntas:`, anexo.perguntas_rh);
                                    }
                                });
                            }
                        } catch (err) {
                            // Silenciar erros de dias sem dados
                        }
                    }
                }
                
                console.log('? Perguntas e aprovações carregadas!');
                
                // 🔄 RECALCULAR inconsistências após carregar aprovações
                recalcularInconsistenciasComAprovacoes();
            } catch (err) {
                console.error('? Erro ao carregar perguntas/aprovações:', err);
            }
        }
        
        // 🔄 Recalcular inconsistências considerando aprovações carregadas
        function recalcularInconsistenciasComAprovacoes() {
            console.log('🔄 Recalculando inconsistências após carregar aprovações...');
            
            let removidos = 0;
            allEmployees.forEach(emp => {
                // ✅ LÓGICA SIMPLES: Se tem ordem_horarios aprovada, NÃO É INCONSISTÊNCIA
                if (emp.approved && emp.approved.ordem_horarios === true) {
                    const tinhaInconsistencia = emp.hasInconsistency;
                    
                    // ✅ REMOVE A INCONSISTÊNCIA COMPLETAMENTE
                    emp.hasInconsistency = false;
                    
                    if (tinhaInconsistencia) {
                        console.log(`✅ ${emp.name}: Inconsistência REMOVIDA (ordem_horarios aprovada)`);
                        removidos++;
                    }
                }
            });
            
            console.log(`✅ Recálculo concluído! ${removidos} inconsistências removidas por aprovação`);
        }

        // ℹ Carregar IDs de impressão (alias para carregarIdsImpressao)
        async function carregarIDs() {
            return await carregarIdsImpressao();
        }
        
        // ℹ Carregar IDs de impressão de TODOS os funcionários
        async function carregarIdsImpressao() {
            try {
                // Carregar IDs do banco de dados
                
                // Montar array com todos os registros (REG + DATA + EMPRESA_ID)
                const registros = allEmployees.map(emp => ({
                    reg: emp.reg,
                    data: emp.date,
                    empresa_id: emp.empresaId || emp.companyId || 0
                }));
                
                if (registros.length === 0) return;
                
                const response = await fetch(`${API_BASE_URL}/api/justificativa/buscar-ids`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ registros })
                });
                
                if (!response.ok) {
                    console.warn('⚠️ Erro ao buscar IDs do banco');
                    return;
                }
                
                const { ids } = await response.json();
                
                // Atribuir IDs aos funcionários
                allEmployees.forEach(emp => {
                    // Normalizar data
                    let dataNormalizada = emp.date;
                    if (emp.date.includes('/')) {
                        const [dia, mes, ano] = emp.date.split('/');
                        dataNormalizada = `${ano}-${mes}-${dia}`;
                    } else if (emp.date.includes('T')) {
                        dataNormalizada = emp.date.split('T')[0];
                    }
                    
                    const empresaId = emp.empresaId || emp.companyId || 0;
                    const key = `${emp.reg}_${dataNormalizada}_${empresaId}`;
                    if (ids[key]) {
                        emp.id = ids[key];
                    }
                });
                
                console.log(`? IDs carregados! ${Object.keys(ids).length} encontrado(s)`);
                
            } catch (err) {
                console.error('? Erro ao carregar IDs do banco:', err);
            }
        }

        // Desconectar da API
        function disconnectFromAPI() {
            allEmployees.length = 0;
            isAPIConnected = false;
            
            const apiStatus = document.getElementById('apiStatus');
            
            apiStatus.className = 'api-status disconnected';
            apiStatus.innerHTML = '<span style="width: 8px; height: 8px; background: #ef4444; border-radius: 50%; display: inline-block;"></span> API Desconectada';
            
            renderTable();
        }

        // Configurar credenciais
        function configureAPI() {
            const currentBaseURL = API_CONFIG.baseURL || '';
            
            const message = '⚙️ CONFIGURAÇÃO DA URL BASE DA API\n\n' +
                '📝 Digite a URL base do SmartPoint:\n\n' +
                '💡 Exemplos comuns:\n' +
                '1️⃣  https://api.secullum.com.br/SmartPoint\n' +
                '2️⃣  https://prd.secullum.com.br/SmartPoint\n' +
                '3️⃣  https://sistema.secullum.com.br/SmartPoint\n' +
                '4️⃣  https://app.secullum.com.br/SmartPoint\n' +
                '5️⃣  https://cliente.secullum.com.br/SmartPoint\n\n' +
                `ℹ️ URL Atual: ${currentBaseURL || '(não configurada)'}\n\n` +
                'ℹ️ IMPORTANTE: não inclua "/IntegracaoExterna"\n' +
                'ℹ️ Entre em contato com o suporte Secullum se não souber a URL';
            
            const newBaseURL = prompt(message, currentBaseURL || 'https://');
            
            if (newBaseURL && newBaseURL.trim() && newBaseURL !== 'https://') {
                API_CONFIG.baseURL = newBaseURL.trim().replace(/\/$/, ''); // Remove barra final
                showAlert('Sucesso', `URL Base configurada: ${API_CONFIG.baseURL}`, 'success');
            } else if (newBaseURL === '' || newBaseURL === 'https://') {
                showAlert('Atenção', 'Por favor, digite uma URL válida!', 'warning');
            }
        }

        // ==========================================
        // funções DE seleçãoãO DE EMPRESA
        // ==========================================
        function selectCompany(companyId, button) {
            if (companyId === 'all') {
                API_CONFIG.selectedCompanies = ['all'];
                document.querySelectorAll('.btn-company').forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
            } else {
                // Remove 'all' se existir
                if (API_CONFIG.selectedCompanies.includes('all')) {
                    API_CONFIG.selectedCompanies = [];
                    document.querySelector('.btn-company[data-company="all"]').classList.remove('active');
                }

                // Toggle empresa específica
                const index = API_CONFIG.selectedCompanies.indexOf(companyId);
                if (index > -1) {
                    API_CONFIG.selectedCompanies.splice(index, 1);
                    button.classList.remove('active');
                } else {
                    API_CONFIG.selectedCompanies.push(companyId);
                    button.classList.add('active');
                }

                // Se nenhuma empresa selecionada, volta para 'all'
                if (API_CONFIG.selectedCompanies.length === 0) {
                    API_CONFIG.selectedCompanies = ['all'];
                    document.querySelector('.btn-company[data-company="all"]').classList.add('active');
                }
            }

            
        }

        function initCompanyButtons() {
            const container = document.getElementById('companyButtons');
            
            // Limpar botões existentes (exceto o botão "TODAS")
            const allButton = container.querySelector('[data-company="all"]');
            container.innerHTML = '';
            if (allButton) {
                container.appendChild(allButton);
            }
            
            // Adicionar botões das empresas
            API_CONFIG.companies.forEach(company => {
                const btn = document.createElement('button');
                btn.className = 'btn-company';
                btn.setAttribute('data-company', company.id);
                btn.onclick = () => selectCompany(company.id, btn);
                btn.innerHTML = `🏢 ${company.name}`;
                btn.style.borderColor = company.color;
                btn.style.color = company.color;
                container.appendChild(btn);
            });
        }

        // Recarregar dados com as empresas selecionadas
        async function reloadData() {
            const dateStart = document.getElementById('dateStart').value;
            const dateEnd = document.getElementById('dateEnd').value;
            
            if (!dateStart || !dateEnd) {
                showAlert('Atenção', 'Por favor, selecione as datas de Início e fim!', 'warning');
                return;
            }
            
            document.getElementById('apiStatus').innerHTML = '? Carregando...';
            const startTime = performance.now();
            
            const apiData = await fetchEmployeesFromAPI(dateStart, dateEnd);
            
            const endTime = performance.now();
            const timeElapsed = ((endTime - startTime) / 1000).toFixed(2);
            
            if (apiData && apiData.length > 0) {
                allEmployees.length = 0;
                allEmployees.push(...apiData);
                
                // Ordenar alfabeticamente ao carregar
                allEmployees.sort((a, b) => a.name.localeCompare(b.name));
                
                // FAZER MATCH COM SQL AZURE (buscar Líder e PROJETO)
                console.log('🔍 Buscando dados complementares do SQL Azure...');
                const cpfs = [...new Set(allEmployees.map(emp => emp.cpf).filter(cpf => cpf))];
                const sqlData = await getColaboradoresBatchCPF(cpfs);
                
                // Fazer match por CPF
                allEmployees.forEach(emp => {
                    if (emp.cpf) {
                        const cpfLimpo = emp.cpf.replace(/[^\d]/g, '');
                        const sqlColab = sqlColaboradoresCache[cpfLimpo];
                        if (sqlColab) {
                            emp.nomeLider = sqlColab.NOME_LIDER || sqlColab.Lider || null;
                            emp.projeto = sqlColab.PROJETO || sqlColab.Projeto || null;
                        } else {
                            emp.nomeLider = null;
                            emp.projeto = null;
                        }
                    }
                    
                    // Adicionar departamento Secullum (DEPTO SEC) - buscar sempre
                    if (emp.projetoSecullum) {
                        // Usar o projetoSecullum que já vem enriquecido das batidas
                        emp.departamentoSecullum = String(emp.projetoSecullum);
                    } else if (emp.rawData?.Departamento) {
                        // Fallback: extrair do rawData.Departamento
                        const dept = emp.rawData.Departamento;
                        if (typeof dept === 'object' && dept.Codigo) {
                            emp.departamentoSecullum = String(dept.Codigo);
                        } else if (typeof dept === 'string') {
                            emp.departamentoSecullum = dept;
                        } else {
                            emp.departamentoSecullum = null;
                        }
                    } else {
                        emp.departamentoSecullum = null;
                    }
                });
                
                // � CARREGAR TODOS OS DADOS EM BATCH
                try {
                    await carregarDadosCompletos();
                } catch (err) {
                    console.error('❌ Erro ao carregar dados:', err);
                }
                
                renderTable();
                showAlert('Sucesso', `${apiData.length} registros carregados em ${timeElapsed}s`, 'success');
            } else {
                showAlert('Sem Dados', 'Nenhum registro encontrado neste Período!', 'warning');
            }
            
            document.getElementById('apiStatus').innerHTML = `<span style="width: 8px; height: 8px; background: #10b981; border-radius: 50%; display: inline-block;"></span> API Conectada (${timeElapsed}s)`;
        }

        // ==========================================
        // RENDERIZaçãO DA TABELA
        // ==========================================
        // Renderizar tabela
        function renderTable() {
            // 📝 CORREçããO: Evitar renderizaçães simulténeas
            if (renderingTable) {
                console.warn('? já esté renderizando, ignorando chamada duplicada');
                return;
            }
            renderingTable = true;
            
            try {
                console.log('🎨 [renderTable] Iniciando renderização...');
                console.log(`📊 allEmployees.length: ${allEmployees.length}`);
                
                const tbody = document.getElementById('employeeTable');
                const searchName = document.getElementById('searchName')?.value.toLowerCase().trim() || '';
                const searchLider = document.getElementById('searchLider')?.value.toLowerCase().trim() || '';
                const searchProject = document.getElementById('searchProject')?.value.trim() || '';
                const searchDepartamento = document.getElementById('searchDepartamento')?.value.trim() || '';
                
                console.log(`🔍 Filtros: nome="${searchName}", lider="${searchLider}", projeto="${searchProject}", departamento="${searchDepartamento}", inconsistências=${showOnlyInconsistencies}`);
                
                // Filtrar por Inconsistências
                let displayedEmployees = showOnlyInconsistencies 
                    ? allEmployees.filter(emp => emp.hasInconsistency)
                    : allEmployees;
                
                console.log(`✅ Após filtro de inconsistências: ${displayedEmployees.length} funcionários`);
                
                // Filtrar por nome (se houver busca)
                if (searchName) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.name.toLowerCase().includes(searchName)
                    );
                }
                
                // Filtrar por Líder (se houver busca)
                if (searchLider) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.nomeLider && emp.nomeLider.toLowerCase().includes(searchLider)
                    );
                }
                
                // Filtrar por Projeto BDO (Azure)
                if (searchProject) {
                    displayedEmployees = displayedEmployees.filter(emp => 
                        emp.projeto && String(emp.projeto).toLowerCase().includes(searchProject.toLowerCase())
                    );
                }
                
                // Filtrar por Departamento Secullum
                if (searchDepartamento) {
                    console.log(`🔍 Filtrando por departamento: "${searchDepartamento}"`);
                    console.log(`🔍 Exemplo de emp[0]:`, displayedEmployees[0]);
                    console.log(`🔍 emp[0].departamentoSecullum:`, displayedEmployees[0]?.departamentoSecullum);
                    console.log(`🔍 emp[0].projetoSecullum:`, displayedEmployees[0]?.projetoSecullum);
                    const antes = displayedEmployees.length;
                    displayedEmployees = displayedEmployees.filter(emp => {
                        const match = emp.departamentoSecullum && String(emp.departamentoSecullum).toLowerCase().includes(searchDepartamento.toLowerCase());
                        if (match) {
                            console.log(`✅ Match: ${emp.name} | Depto: ${emp.departamentoSecullum}`);
                        }
                        return match;
                    });
                    console.log(`🔍 Resultado filtro depto: ${antes} → ${displayedEmployees.length}`);
                }
                
                // ORDENAR ALFABETICAMENTE POR NOME
                displayedEmployees.sort((a, b) => a.name.localeCompare(b.name));

                // 📄 PAGINAÇÃO: Calcular total de páginas e slice de dados
                const totalPages = Math.ceil(displayedEmployees.length / ITEMS_PER_PAGE);
                const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
                const endIndex = startIndex + ITEMS_PER_PAGE;
                const paginatedEmployees = displayedEmployees.slice(startIndex, endIndex);

                console.log(`📄 Paginação: Página ${currentPage}/${totalPages} | Mostrando ${paginatedEmployees.length} de ${displayedEmployees.length} registros`);

                // Atualizar controles de paginação
                updatePaginationControls(currentPage, totalPages, displayedEmployees.length);

            tbody.innerHTML = paginatedEmployees.map((emp, index) => {
                // ? COMPARAR PROJETOS: Extrair 3 primeiros nçãmeros
                const extrairNumeros = (str) => {
                    if (!str) return '';
                    const numeros = String(str).match(/\d+/);
                    if (numeros && numeros[0]) {
                        return numeros[0].substring(0, 3);
                    }
                    return '';
                };
                
                const projetoBDO = extrairNumeros(emp.projeto);
                const projetoSEC = extrairNumeros(emp.projetoSecullum);
                
                // Se ambos existem e Sóo diferentes, destacar em amarelo
                const projetoDiferente = projetoBDO && projetoSEC && projetoBDO !== projetoSEC;
                const corDestaque = projetoDiferente ? 'background: #fef3c7; font-weight: 700;' : '';
                
                // VALIDAR ORDEM cronológica PARA DESTACAR células ERRADAS
                const timeToMinutes = (time) => {
                    if (!time || time === '--:--') return -1;
                    const [h, m] = time.split(':').map(Number);
                    return h * 60 + m;
                };
                
                // função helper: retorna motivo se existir, senão retorna Horário
                const getMotivoOuHorario = (horario, motivo) => {
                    const motivosEspeciais = ['FALTA', 'FÉRIAS', 'AFASTAMENTO INSS', 'LICENÇA MATERNIDADE', 'FOLGA'];
                    if (motivosEspeciais.includes(motivo)) {
                        return motivo;
                    }
                    return horario || '--:--';
                };
                
                const horariosOrdenados = [
                    { col: 'ent1', hora: emp.punches.ent1 },
                    { col: 'sai1', hora: emp.punches.sai1 },
                    { col: 'ent2', hora: emp.punches.ent2 },
                    { col: 'sai2', hora: emp.punches.sai2 },
                    { col: 'ent3', hora: emp.punches.ent3 },
                    { col: 'sai3', hora: emp.punches.sai3 },
                    { col: 'ent4', hora: emp.punches.ent4 },
                    { col: 'sai4', hora: emp.punches.sai4 },
                    { col: 'ent5', hora: emp.punches.ent5 },
                    { col: 'sai5', hora: emp.punches.sai5 }
                ].filter(h => h.hora && h.hora !== '--:--');
                
                // Marcar quais colunas estéo fora de ordem
                const colunasErradas = new Set();
                
                for (let i = 1; i < horariosOrdenados.length; i++) {
                    const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                    const atual = timeToMinutes(horariosOrdenados[i].hora);
                    
                    if (atual <= anterior) {
                        colunasErradas.add(horariosOrdenados[i].col);
                        colunasErradas.add(horariosOrdenados[i - 1].col);
                    }
                }
                
                // função para retornar classe correta
                const getTimeClass = (punchType, value) => {
                    if (colunasErradas.has(punchType)) {
                        return 'error-time'; // VERMELHO ESCURO
                    } else if (value) {
                        return 'present'; // VERDE
                    } else if (punchType === 'ent1' || punchType === 'sai1' || punchType === 'ent2' || punchType === 'sai2') {
                        return 'missing'; // VERMELHO CLARO (obrigatério)
                    } else {
                        return 'optional'; // CINZA (opcional)
                    }
                };
                
                // ? ID único: REG + DATA (para selecionar dia especçãfico, não todos os dias do colaborador)
                const uniqueId = `${emp.reg}_${emp.date}`;
                
                return `
                <tr class="${emp.hasInconsistency ? 'inconsistency' : ''} ${selectedEmployees.includes(uniqueId) ? 'selected' : ''}">
                    <td style="width: 40px;">
                        <input type="checkbox" 
                               class="employee-checkbox" 
                               data-reg="${emp.reg}"
                               data-date="${emp.date}"
                               data-id="${uniqueId}"
                               ${selectedEmployees.includes(uniqueId) ? 'checked' : ''}
                               style="width: 18px; height: 18px; cursor: pointer;">
                    </td>
                    <td class="center" style="font-weight: bold; color: #6b7280; width: 50px;">
                        ${emp.id ? `#${emp.id}` : '-'}
                    </td>
                    <td style="font-family: 'Courier New', monospace; font-weight: 600; font-size: 12px; width: 80px;">
                        ${emp.reg}
                        <button onclick="refreshEmployee('${emp.reg}', '${emp.date}', ${emp.empresaId})" 
                                style="background: none; border: none; cursor: pointer; font-size: 14px; margin-left: 4px; opacity: 0.6; transition: all 0.2s;"
                                onmouseover="this.style.opacity='1'; this.style.transform='rotate(180deg)'"
                                onmouseout="this.style.opacity='0.6'; this.style.transform='rotate(0deg)'"
                                title="Atualizar este funcionário">
                            🔄
                        </button>
                    </td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 150px; max-width: 180px; color: #7c3aed;">${emp.nomeLider || '-'}</td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 100px; max-width: 120px; color: #000; ${corDestaque}">${emp.projeto || '-'}</td>
                    <td style="font-weight: 600; font-size: 11px; min-width: 120px; max-width: 140px; color: #000; ${corDestaque}">${emp.projetoSecullum || '-'}</td>
                    <td style="font-weight: 600; font-size: 12px; min-width: 180px; max-width: 220px;">${emp.name}</td>
                    <td style="font-family: 'Courier New', monospace; font-size: 12px; width: 140px;">${emp.cpf ? emp.cpf.replace(/(\d{3})(\d{3})(\d{3})(\d{2})/, '$1.$2.$3-$4') : 'N/A'}</td>
                    <td style="font-weight: 600; font-size: 12px; min-width: 140px;">${emp.city}</td>
                    <td class="center" style="font-size: 12px; width: 100px;">${emp.date}</td>
                    <td class="center punch-cell" style="width: 100px; position: relative;" 
                        data-reg="${emp.reg}" 
                        data-date="${emp.date}" 
                        data-punch="ent1"
                        data-name="${emp.name}">
                        ${colunasErradas.has('ent1') && !emp.approved?.ent1 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent1\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.ent1 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent1\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.ent1 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent1\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.ent1 ? 'approved' : getTimeClass('ent1', emp.punches.ent1)}" style="font-size: 13px; font-family: 'Courier New', monospace;">
                            ${getMotivoOuHorario(emp.punches.ent1, emp.motivo)}
                        </span>
                        ${emp.questions?.ent1 ? '<span class="has-question" title="' + emp.questions.ent1 + '">💬</span>' : ''}
                        ${emp.approved?.ent1 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent1 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai1" data-name="${emp.name}">
                        ${colunasErradas.has('sai1') && !emp.approved?.sai1 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai1\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.sai1 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai1\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.sai1 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai1\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.sai1 ? 'approved' : getTimeClass('sai1', emp.punches.sai1)}">${getMotivoOuHorario(emp.punches.sai1, emp.motivo)}</span>
                        ${emp.questions?.sai1 ? '<span class="has-question" title="' + emp.questions.sai1 + '">💬</span>' : ''}
                        ${emp.approved?.sai1 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai1 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent2" data-name="${emp.name}">
                        ${colunasErradas.has('ent2') && !emp.approved?.ent2 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent2\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.ent2 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent2\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.ent2 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent2\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.ent2 ? 'approved' : getTimeClass('ent2', emp.punches.ent2)}">${getMotivoOuHorario(emp.punches.ent2, emp.motivo)}</span>
                        ${emp.questions?.ent2 ? '<span class="has-question" title="' + emp.questions.ent2 + '">💬</span>' : ''}
                        ${emp.approved?.ent2 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent2 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai2" data-name="${emp.name}">
                        ${colunasErradas.has('sai2') && !emp.approved?.sai2 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai2\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.sai2 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai2\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.sai2 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai2\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.sai2 ? 'approved' : getTimeClass('sai2', emp.punches.sai2)}">${getMotivoOuHorario(emp.punches.sai2, emp.motivo)}</span>
                        ${emp.questions?.sai2 ? '<span class="has-question" title="' + emp.questions.sai2 + '">💬</span>' : ''}
                        ${emp.approved?.sai2 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai2 + '">✅</span>' : ''}
                    </td>
                    <td style="width: 28px; min-width: 28px; max-width: 28px; padding: 0; border: none;"></td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent3" data-name="${emp.name}">
                        ${colunasErradas.has('ent3') && !emp.approved?.ent3 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent3\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.ent3 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent3\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.ent3 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent3\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.ent3 ? 'approved' : getTimeClass('ent3', emp.punches.ent3)}">${getMotivoOuHorario(emp.punches.ent3, emp.motivo)}</span>
                        ${emp.questions?.ent3 ? '<span class="has-question" title="' + emp.questions.ent3 + '">💬</span>' : ''}
                        ${emp.approved?.ent3 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent3 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai3" data-name="${emp.name}">
                        ${colunasErradas.has('sai3') && !emp.approved?.sai3 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai3\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.sai3 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai3\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.sai3 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai3\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.sai3 ? 'approved' : getTimeClass('sai3', emp.punches.sai3)}">${getMotivoOuHorario(emp.punches.sai3, emp.motivo)}</span>
                        ${emp.questions?.sai3 ? '<span class="has-question" title="' + emp.questions.sai3 + '">💬</span>' : ''}
                        ${emp.approved?.sai3 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai3 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent4" data-name="${emp.name}">
                        ${colunasErradas.has('ent4') && !emp.approved?.ent4 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent4\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.ent4 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent4\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.ent4 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent4\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.ent4 ? 'approved' : getTimeClass('ent4', emp.punches.ent4)}">${getMotivoOuHorario(emp.punches.ent4, emp.motivo)}</span>
                        ${emp.questions?.ent4 ? '<span class="has-question" title="' + emp.questions.ent4 + '">💬</span>' : ''}
                        ${emp.approved?.ent4 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent4 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai4" data-name="${emp.name}">
                        ${colunasErradas.has('sai4') && !emp.approved?.sai4 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai4\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.sai4 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai4\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.sai4 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai4\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.sai4 ? 'approved' : getTimeClass('sai4', emp.punches.sai4)}">${getMotivoOuHorario(emp.punches.sai4, emp.motivo)}</span>
                        ${emp.questions?.sai4 ? '<span class="has-question" title="' + emp.questions.sai4 + '">💬</span>' : ''}
                        ${emp.approved?.sai4 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai4 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="ent5" data-name="${emp.name}">
                        ${colunasErradas.has('ent5') && !emp.approved?.ent5 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent5\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.ent5 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent5\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.ent5 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'ent5\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.ent5 ? 'approved' : getTimeClass('ent5', emp.punches.ent5)}">${getMotivoOuHorario(emp.punches.ent5, emp.motivo)}</span>
                        ${emp.questions?.ent5 ? '<span class="has-question" title="' + emp.questions.ent5 + '">💬</span>' : ''}
                        ${emp.approved?.ent5 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.ent5 + '">✅</span>' : ''}
                    </td>
                    <td class="center punch-cell col-extra" style="width: 100px; position: relative;" data-reg="${emp.reg}" data-date="${emp.date}" data-punch="sai5" data-name="${emp.name}">
                        ${colunasErradas.has('sai5') && !emp.approved?.sai5 ? '<span class="approve-icon" onclick="approveSwappedTime(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai5\', \'' + emp.name + '\')" title="Aprovar Horário trocado"></span>' : ''}
                        ${emp.questions?.sai5 ? '<span class="delete-question-icon" onclick="deleteQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai5\')" title="Excluir pergunta"></span>' : ''}
                        ${emp.punches.sai5 ? '<span class="question-icon" onclick="askQuestion(event, \'' + emp.reg + '\', \'' + emp.date + '\', \'sai5\', \'' + emp.name + '\')" title="Adicionar pergunta"></span>' : ''}
                        <span class="punch-time ${emp.approved?.sai5 ? 'approved' : getTimeClass('sai5', emp.punches.sai5)}">${getMotivoOuHorario(emp.punches.sai5, emp.motivo)}</span>
                        ${emp.questions?.sai5 ? '<span class="has-question" title="' + emp.questions.sai5 + '">💬</span>' : ''}
                        ${emp.approved?.sai5 ? '<span class="approved-badge" title="Aprovado por RH: ' + emp.approved.sai5 + '">✅</span>' : ''}
                    </td>
                    <td class="center" style="width: 70px; font-weight: bold; color: #7c3aed; font-size: 14px;">
                        ${emp.anexoId ? `#${emp.anexoId}` : '-'}
                    </td>
                    <td style="font-size: 12px; min-width: 150px; max-width: 200px;">
                        ${emp.motivo || '-'}
                    </td>
                    <td class="center" style="width: 100px;">
                        ${emp.anexoUrl ? `
                            <div style="display: flex; flex-direction: column; gap: 4px; align-items: center;">
                                <a href="${emp.anexoUrl}" target="_blank" style="font-size: 11px; color: #3b82f6; text-decoration: none; font-weight: 600;">
                                    🖼️ Ver imagem
                                </a>
                                <button class="upload-btn" style="font-size: 10px; padding: 2px 8px; background: #10b981; color: white; border: none; border-radius: 4px; cursor: pointer;" onclick="handleFileUpload(event, '${emp.reg}', '${emp.date}')">
                                    🔄 Substituir
                                </button>
                            </div>
                        ` : `
                            <button class="upload-btn" style="font-size: 11px; padding: 5px 10px;" onclick="handleFileUpload(event, '${emp.reg}', '${emp.date}')">
                                📎 Anexar
                            </button>
                        `}
                    </td>
                    <td class="center" style="width: 90px;">
                        <span class="status-badge ${emp.hasInconsistency ? 'error' : 'ok'}" style="font-size: 11px; padding: 5px 10px;">
                            ${emp.hasInconsistency ? 'INCONS.' : 'OK'}
                        </span>
                    </td>
                </tr>
                `;
            }).join('');

            // 📝 CORREÇÃO: Restaurar checkboxes selecionados (apenas para registros visíveis nesta página)
            paginatedEmployees.forEach(emp => {
                const uniqueId = `${emp.reg}_${emp.date}`;
                if (selectedEmployees.includes(uniqueId)) {
                    const checkbox = tbody.querySelector(`.employee-checkbox[data-id="${uniqueId}"]`);
                    const row = checkbox?.closest('tr');
                    if (checkbox) checkbox.checked = true;
                    if (row) row.classList.add('selected');
                }
            });

            // TAREFA 7: Configurar drag-and-drop após renderizar tabela
            setupDragAndDrop();
            
            } finally {
                renderingTable = false;
            }
        }

        // 📄 PAGINAÇÃO: Atualizar controles de navegação
        function updatePaginationControls(currentPage, totalPages, totalRecords) {
            const paginationDiv = document.getElementById('paginationControls');
            if (!paginationDiv) return;

            if (totalPages <= 1) {
                paginationDiv.style.display = 'none';
                return;
            }

            paginationDiv.style.display = 'flex';
            paginationDiv.innerHTML = `
                <div style="display: flex; align-items: center; gap: 10px; justify-content: center; padding: 15px;">
                    <button onclick="goToPage(1)" ${currentPage === 1 ? 'disabled' : ''} style="padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                        ⏮️ Primeira
                    </button>
                    <button onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''} style="padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                        ⬅️ Anterior
                    </button>
                    <span style="padding: 8px 16px; font-weight: 600;">
                        Página ${currentPage} de ${totalPages} | ${totalRecords} registros
                    </span>
                    <button onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''} style="padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                        Próxima ➡️
                    </button>
                    <button onclick="goToPage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''} style="padding: 8px 12px; border-radius: 4px; cursor: pointer;">
                        Última ⏭️
                    </button>
                </div>
            `;
        }

        // 📄 PAGINAÇÃO: Navegar para página específica
        function goToPage(page) {
            currentPage = page;
            renderTable();
            // Scroll para o topo da tabela
            document.getElementById('employeeTable')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        // Simular OCR - Extrair Horários e justificativa da imagem
        function simulateOCR(fileName) {
            // Simulação de extração de dados
            const possibleTimes = ['07:30', '11:30', '12:30', '17:30', '18:00', '19:00'];
            const possibleReasons = [
                'Esquecimento do cartéo',
                'méquina do ponto quebrada',
                'Atendimento emergencial',
                'Reunião externa',
                'Visita ao cliente',
                'Problema no sistema'
            ];
            
            // Simula que extraiu um Horário aleatério e uma justificativa
            const extractedTime = possibleTimes[Math.floor(Math.random() * possibleTimes.length)];
            const extractedReason = possibleReasons[Math.floor(Math.random() * possibleReasons.length)];
            
            return {
                time: extractedTime,
                reason: extractedReason
            };
        }

        // Upload de arquivo
        // ==========================================
        // SISTEMA DE ANEXOS (CTRL+V + OCR + Azure Blob)
        // ==========================================
        
        let currentAnexoEmployee = null;
        let currentAnexoImage = null;
        let currentOCRData = null;
        
        // Abrir modal de anexo
        function handleFileUpload(event, reg, date) {
            
            
            // Normalizar data para comparação (pode vir 2025-10-25 ou 25/10/2025)
            let dataComparacao = date;
            if (date.includes('/')) {
                // Converter DD/MM/YYYY ? YYYY-MM-DD
                const [dia, mes, ano] = date.split('/');
                dataComparacao = `${ano}-${mes}-${dia}`;
            }
            
            // Buscar FUNCIONÁRIO por REG E DATA
            const employee = allEmployees.find(emp => {
                // Normalizar data do employee também
                let empData = emp.date;
                if (emp.rawData?.Data) {
                    empData = emp.rawData.Data.split('T')[0]; // 2025-10-25T00:00:00 ? 2025-10-25
                }
                
                const match = emp.reg === reg && empData === dataComparacao;
                if (match) {
                    
                }
                return match;
            });
            
            if (!employee) {
                console.error(`? FUNCIONÁRIO não encontrado: REG=${reg}, Data=${dataComparacao}`);
                showAlert('Erro', 'Funcionário não encontrado!', 'error');
                return;
            }
            
            abrirModalAnexo(employee);
        }
        
        async function abrirModalAnexo(employee) {
            currentAnexoEmployee = employee;
            currentAnexoImage = null;
            currentOCRData = null;
            
            // ✅ RESETAR ESTADO DO BOTÃO (evitar ficar travado)
            const btn = document.getElementById('btnConfirmarAnexo');
            btn.disabled = false;
            btn.textContent = 'Confirmar Anexo';
            
            document.getElementById('modalAnexoInfo').textContent = `REG: ${employee.reg} | ${employee.name} | Data: ${employee.date}`;
            document.getElementById('previewArea').style.display = 'none';
            document.getElementById('ocrStatus').style.display = 'none';
            document.getElementById('ocrResult').style.display = 'none';
            document.getElementById('btnConfirmarAnexo').style.display = 'none';
            
            // VERIFICAR SE já EXISTE ANEXO (Só para avisar Usuário)
            let anexoExistenteId = null;
            try {
                const dataFormatada = employee.rawData?.Data?.split('T')[0] || employee.date;
                const empresaId = employee.empresaId || employee.companyId;
                
                const response = await fetch(`${API_BASE_URL}/api/anexos/${dataFormatada}/${employee.reg}`, {
                    headers: getAuthHeaders()
                });
                
                // Se retornou 404, não existe anexo (normal)
                if (response.status === 404) {
                    
                } else if (response.ok) {
                    const anexo = await response.json();
                    
                    if (anexo && anexo.blob_url) {
                        // já EXISTE ANEXO - Mostrar aviso e abrir para visualização
                        showAlert('Anexo Existente', `Já existe um anexo para ${employee.name} nesta data. Abrindo para visualização...`, 'info');
                        setTimeout(() => {
                            window.open(anexo.blob_url, '_blank');
                        }, 1500);
                        return;
                    }
                } else {
                    console.warn(`ℹ Erro ao verificar anexo existente: ${response.status}`);
                }
            } catch (err) {
                console.warn('⚠️ Erro ao verificar anexo:', err.message);
            }
            
            document.getElementById('modalAnexo').style.display = 'flex';
            
            // Ativar área de drop
            setupDropZone();
        }
        
        function fecharModalAnexo() {
            document.getElementById('modalAnexo').style.display = 'none';
            currentAnexoEmployee = null;
            currentAnexoImage = null;
            currentOCRData = null;
            
            // ✅ RESETAR ESTADO DO BOTÃO ao fechar
            const btn = document.getElementById('btnConfirmarAnexo');
            btn.disabled = false;
            btn.textContent = 'Confirmar Anexo';
        }
        
        function setupDropZone() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('fileInput');
            
            // Click para selecionar arquivo
            dropZone.onclick = () => fileInput.click();
            
            // Arquivo selecionado
            fileInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) processarImagem(file);
            };
            
            // CTRL+V (Colar)
            document.addEventListener('paste', handlePaste);
            
            // Drag & Drop
            dropZone.ondragover = (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            };
            
            dropZone.ondragleave = () => {
                dropZone.classList.remove('dragover');
            };
            
            dropZone.ondrop = (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    processarImagem(file);
                }
            };
        }
        
        // CTRL+V - Colar imagem
        function handlePaste(e) {
            // Só processar se modal estiver aberto
            if (document.getElementById('modalAnexo').style.display !== 'flex') return;
            
            const items = e.clipboardData.items;
            for (let item of items) {
                if (item.type.indexOf('image') !== -1) {
                    const blob = item.getAsFile();
                    processarImagem(blob);
                    break;
                }
            }
        }
        
        // PRçã-PROCESSAMENTO DE IMAGEM para melhorar OCR (VERSóO OTIMIZADA)
        async function preprocessarImagem(file) {
            return new Promise((resolve) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // Escala 4x para melhor resoluçãão
                        const scale = 4;
                        canvas.width = img.width * scale;
                        canvas.height = img.height * scale;
                        
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // ConverSóo para escala de cinza + contraste extremo
                        for (let i = 0; i < data.length; i += 4) {
                            const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                            const contrast = 4.0; // Aumentado de 3.5 para 4.0
                            let adjusted = ((gray - 128) * contrast) + 128;
                            adjusted = Math.max(0, Math.min(255, adjusted));
                            
                            // Binarização com threshold 140 (reduzido para pegar manuscrito)
                            const binary = adjusted > 140 ? 255 : 0;
                            data[i] = data[i + 1] = data[i + 2] = binary;
                        }
                        
                        ctx.putImageData(imageData, 0, 0);
                        
                        console.log(`ℹ Prçã-processamento: escala ${scale}x, contraste 4.0, threshold 140`);
                        
                        canvas.toBlob((blob) => resolve(blob), 'image/png');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }
        
        // ==========================================
        // AZURE COMPUTER VISION API - OCR Manuscrito
        // ==========================================
        
        // Cache da chave Azure Vision
        let azureVisionConfig = null;
        
        async function getAzureVisionConfig() {
            if (azureVisionConfig) return azureVisionConfig;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/azure-vision-config`);
                if (response.ok) {
                    azureVisionConfig = await response.json();
                    return azureVisionConfig;
                }
            } catch (err) {
                console.warn('⚠️ não foi posSóvel obter config Azure Vision do servidor');
            }
            
            // Fallback: valores vazios (vai falhar mas não expée credenciais)
            return { apiKey: '', endpoint: 'https://testedeocr123.cognitiveservices.azure.com/' };
        }
        
        async function extrairDadosComGoogleVision(imageBase64) {
            const config = await getAzureVisionConfig();
            const API_KEY = config.apiKey;
            const ENDPOINT = config.endpoint;
            
            if (!API_KEY) {
                throw new Error('Chave Azure Vision não configurada no servidor');
            }
            
            
            
            try {
                // 📝 REDIMENSIONAR imagem se muito grande
                let base64Content = imageBase64.split(',')[1];
                
                // Verificar tamanho
                const tamanhoMB = (base64Content.length * 3 / 4) / (1024 * 1024);
                
                if (tamanhoMB > 4) {
                    console.log('🛠️ Imagem muito grande, redimensionando...');
                    
                    const img = await new Promise((resolve, reject) => {
                        const image = new Image();
                        image.onload = () => resolve(image);
                        image.onerror = reject;
                        image.src = imageBase64;
                    });
                    
                    const maxSize = 1500;
                    let newWidth = img.width;
                    let newHeight = img.height;
                    
                    if (img.width > maxSize || img.height > maxSize) {
                        if (img.width > img.height) {
                            newWidth = maxSize;
                            newHeight = (img.height * maxSize) / img.width;
                        } else {
                            newHeight = maxSize;
                            newWidth = (img.width * maxSize) / img.height;
                        }
                    }
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, newWidth, newHeight);
                    
                    imageBase64 = canvas.toDataURL('image/jpeg', 0.85);
                    base64Content = imageBase64.split(',')[1];
                    
                    const novoTamanho = (base64Content.length * 3 / 4) / (1024 * 1024);
                    console.log(`? Imagem redimensionada: ${novoTamanho.toFixed(2)} MB (${newWidth}x${newHeight})`);
                }
                
                // Converter base64 para blob binçãrio
                const byteCharacters = atob(base64Content);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray], { type: 'application/octet-stream' });
                
                // Azure Computer Vision - Read API (OCR para manuscrito)
                const analyzeUrl = `${ENDPOINT}vision/v3.2/read/analyze?language=pt`;
                
                
                
                const response = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: {
                        'Ocp-Apim-Subscription-Key': API_KEY,
                        'Content-Type': 'application/octet-stream'
                    },
                    body: blob
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('? Resposta da API:', errorText);
                    throw new Error(`Azure Vision API error: ${response.status} - ${errorText}`);
                }
                
                // Azure retorna URL para buscar o resultado
                const operationLocation = response.headers.get('Operation-Location');
                
                
                // Poll até resultado estar pronto
                let result;
                let attempts = 0;
                const maxAttempts = 10;
                
                while (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 1000)); // Esperar 1 segundo
                    
                    const resultResponse = await fetch(operationLocation, {
                        headers: {
                            'Ocp-Apim-Subscription-Key': API_KEY
                        }
                    });
                    
                    result = await resultResponse.json();
                    
                    
                    
                    if (result.status === 'succeeded') {
                        console.log('? OCR concluído pelo Azure Computer Vision!');
                        break;
                    } else if (result.status === 'failed') {
                        console.error('? Azure OCR falhou:', result);
                        throw new Error('Azure OCR falhou');
                    }
                    
                    attempts++;
                }
                
                if (result.status !== 'succeeded') {
                    throw new Error('Timeout ao processar OCR');
                }
                
                // Extrair texto de todas as linhas
                const analyzeResult = result.analyzeResult;
                let fullText = '';
                
                if (analyzeResult && analyzeResult.readResults) {
                    console.log(`ℹ Azure retornou ${analyzeResult.readResults.length} página(s)`);
                    for (const page of analyzeResult.readResults) {
                        
                        for (const line of page.lines) {
                            fullText += line.text + '\n';
                        }
                    }
                } else {
                    console.warn('⚠️ analyzeResult esté vazio ou não tem readResults');
                }
                
                console.log('');
                console.log('📄 TEXTO COMPLETO DETECTADO PELO AZURE:');
                console.log('');
                console.log(fullText);
                console.log('');
                console.log(`📊 Total de caracteres: ${fullText.length}`);
                
                // ? DETECTAR CHECKBOX MARCADO PELO TEXTO DO AZURE (antes da análise de pixels)
                let motivoDetectado = 'Esqueceu de registrar o Ponto'; // Default
                let motivoDetectadoPorTexto = false;
                
                
                
                const motivosPossiveis = [
                    'Esqueceu de registrar o Ponto',
                    'Falha no App',
                    'Falta',
                    'Folga',
                    'Hora Parada',
                    'Maquina Ponto com defeito',
                    'Registro em duplicidade',
                    'Registro indevido'
                ];
                
                // 📝 NOVA ESTRATÉGIA: Bolinha marcada ã a que não tem "O" antes do texto
                // Azure lé "O Motivo" para bolinhas vazias, e apenas "Motivo" para marcada
                const linhasTexto = fullText.split('\n');
                const motivosSemBolinha = [];
                
                for (const motivo of motivosPossiveis) {
                    // Procurar se existe linha com "O Motivo" (bolinha vazia)
                    const temBolinhaVazia = linhasTexto.some(linha => {
                        const linhaNormalizada = linha.trim().toLowerCase();
                        const motivoNormalizado = motivo.toLowerCase();
                        // Verifica se linha ã exatamente "O Motivo" ou "o Motivo"
                        return linhaNormalizada === `o ${motivoNormalizado}` || 
                               linhaNormalizada.startsWith(`o ${motivoNormalizado}`);
                    });
                    
                    if (!temBolinhaVazia) {
                        // Este motivo não tem "O" antes = bolinha esté MARCADA
                        const existeTexto = linhasTexto.some(linha => {
                            const linhaNormalizada = linha.trim().toLowerCase();
                            const motivoNormalizado = motivo.toLowerCase();
                            return linhaNormalizada === motivoNormalizado || 
                                   linhaNormalizada.includes(motivoNormalizado);
                        });
                        
                        if (existeTexto) {
                            motivosSemBolinha.push(motivo);
                            
                        }
                    } else {
                        console.log(`   ? "${motivo}" tem "O" antes ? vazio`);
                    }
                }
                
                if (motivosSemBolinha.length === 1) {
                    motivoDetectado = motivosSemBolinha[0];
                    motivoDetectadoPorTexto = true;
                    console.log(`   ℹ DETECTADO: ${motivoDetectado}`);
                } else if (motivosSemBolinha.length > 1) {
                    console.log(`   ℹ múltiplos motivos sem "O": ${motivosSemBolinha.join(', ')}`);
                    motivoDetectado = motivosSemBolinha[0]; // Pega o primeiro
                    motivoDetectadoPorTexto = true;
                } else {
                    console.log('   ℹ Nenhum motivo sem "O" detectado, usando análise visual...');
                }
                
                // 📝 ESTRATÉGIA FINAL: DETECTAR HorárioS ApéS "BATIDO"
                // Layout do formulério:
                // - Horários preenchidos aparecem primeiro (07:05, 12:40, 07:05)
                // - Depois aparecem as palavras "BATIDO BATIDO BATIDO"
                // - Depois aparecem Horários manuscritos (17:25)
                // - Depois aparece "ANULAR BATIDA ANULAR BATIDA"
                
                const horarios = [];
                const linhas = fullText.split('\n');
                let dentroSecaoHorarios = false;
                let encontrouBatido = false; // Nova flag
                
                
                
                // ? PRIMEIRA PASSADA: Contar quantos "BATIDO" existem
                let contadorBatido = 0;
                let dentroSecaoTemp = false;
                for (let i = 0; i < linhas.length; i++) {
                    const linha = linhas[i].trim();
                    if (linha.includes('HorárioS') || linha.includes('preencher somente')) {
                        dentroSecaoTemp = true;
                    }
                    if (linha.includes('JUSTIFICATIVA')) {
                        dentroSecaoTemp = false;
                        break;
                    }
                    if (dentroSecaoTemp && linha === 'BATIDO') {
                        contadorBatido++;
                    }
                }
                
                
                // ? SEGUNDA PASSADA: Ler Horários e pular os primeiros N (que Sóo batidos)
                let horariosEncontrados = [];
                
                for (let i = 0; i < linhas.length; i++) {
                    const linha = linhas[i].trim();
                    
                    // Detectar Início da seçãão de Horários
                    if (linha.includes('HorárioS') || linha.includes('preencher somente')) {
                        dentroSecaoHorarios = true;
                        console.log(`   ? Linha ${i}: Início da seçãão de Horários`);
                        continue;
                    }
                    
                    // Detectar fim da seçãão (JUSTIFICATIVA ou Assinatura)
                    if (linha.includes('JUSTIFICATIVA') || linha.includes('Assinatura')) {
                        if (dentroSecaoHorarios) {
                            console.log(`   ℹ Linha ${i}: Fim da seçãão (${linha.substring(0, 30)}...)`);
                            break;
                        }
                    }
                    
                    // Se estamos na seçãão de Horários
                    if (dentroSecaoHorarios) {
                        // Ignorar linhas com palavras-chave de layout
                        if (linha === 'Horário' || linha === 'BATIDO' || linha.includes('ANULAR')) {
                            console.log(`   ℹ Linha ${i}: Ignorado (palavra-chave): ${linha}`);
                            continue;
                        }
                        
                        // ? NORMALIZAR Horário: aceitar "07: 50", "11,20", "12:30"
                        const linhaNormalizada = linha.replace(/\s+/g, '').replace(',', ':');
                        const matchHorario = linhaNormalizada.match(/^(\d{1,2}):(\d{2})$/);
                        
                        if (matchHorario) {
                            const h = parseInt(matchHorario[1]);
                            const m = parseInt(matchHorario[2]);
                            
                            // Validar se ã Horário válido
                            if (h >= 0 && h <= 23 && m >= 0 && m <= 59) {
                                const horario = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                                horariosEncontrados.push({ horario, linhaOriginal: linha, indice: i });
                            }
                        }
                    }
                }
                
                // ? REGRA: Os primeiros N Horários Sóo BATIDOS, os demais Sóo MANUSCRITOS
                horariosEncontrados.forEach((item, idx) => {
                    if (idx < contadorBatido) {
                        console.log(`   ? Linha ${item.indice}: Horário IGNORADO (já batido): ${item.horario}`);
                    } else {
                        if (!horarios.includes(item.horario)) {
                            horarios.push(item.horario);
                            console.log(`   ℹ Linha ${item.indice}: Horário MANUSCRITO: ${item.horario} (original: "${item.linhaOriginal}")`);
                        }
                    }
                });
                
                
                
                // EXTRAIR MOTIVO COM DETECÇÃO VISUAL DO CHECKBOX MARCADO
                // 📝 Se não foi detectado pelo texto, usar análise de pixels
                
                try {
                    // Só fazer análise visual se não detectou pelo texto
                    if (!motivoDetectadoPorTexto) {
                        console.log(`ℹ Criando canvas para análise de checkbox...`);
                    
                        // Criar canvas da imagem para análise de pixels
                        const canvas = document.createElement('canvas');
                        const img = new Image();
                        img.src = imageBase64; // ? USAR O PARÂMETRO DA função
                        
                        await new Promise((resolve, reject) => {
                            img.onload = () => {
                                
                                resolve();
                            };
                            img.onerror = (err) => {
                                console.error(`? Erro ao carregar imagem:`, err);
                                reject(err);
                            };
                        });
                        
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        
                        
                        // Detectar checkbox marcado visualmente (X preto)
                        const motivo = detectarCheckboxMarcado(canvas);
                        if (motivo) {
                            motivoDetectado = motivo;
                            console.log(`ℹ Motivo detectado VISUALMENTE: ${motivoDetectado}`);
                        } else {
                            console.log(`ℹ Motivo (padrão, nenhum X detectado): ${motivoDetectado}`);
                        }
                    } else {
                        console.log(`ℹ Motivo detectado pelo TEXTO do Azure: ${motivoDetectado}`);
                    }
                } catch (err) {
                    console.warn(`ℹ Erro ao detectar checkbox visual, usando padrão:`, err);
                    console.log(`ℹ Motivo (padrão): ${motivoDetectado}`);
                }
                
                // EXTRAIR ID
                let idDetectado = null;
                const idMatch = fullText.match(/ID\s*IMP\s*:\s*(\d{1,3})/i);
                if (idMatch) {
                    idDetectado = idMatch[1];
                    console.log(`ℹ ID detectado: #${idDetectado}`);
                }
                
                // 📝 DETECTAR ASSINATURAS (FUNCIONÁRIO E Líder)
                let assinaturaFuncionarioDetectada = false;
                let assinaturaLiderDetectada = false;
                try {
                    const canvas = document.createElement('canvas');
                    const img = new Image();
                    img.src = imageBase64;
                    
                    await new Promise((resolve, reject) => {
                        img.onload = () => resolve();
                        img.onerror = reject;
                    });
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Detectar ambas as assinaturas e mostrar debug
                    const resultados = detectarAssinaturas(canvas);
                    assinaturaFuncionarioDetectada = resultados.funcionario;
                    assinaturaLiderDetectada = resultados.lider;
                    
                    console.log('');
                    console.log('📋 RESULTADO DETECÇÃO DE ASSINATURAS');
                    console.log('');
                    console.log(`ℹ FUNCIONÁRIO: ${assinaturaFuncionarioDetectada ? '? ASSINADO' : '? não ASSINADO'}`);
                console.log(`ℹ Líder: ${assinaturaLiderDetectada ? '? ASSINADO' : '? não ASSINADO'}`);
                console.log('');
                } catch (err) {
                    console.warn('ℹ Erro ao detectar assinaturas:', err);
                }
                
                // TAREFA 3: INTELIGÊNCIA NA ORDEM DOS HORÁRIOS
                // Detectar os Horários já BATIDOS no Secullum e preencher slots de forma inteligente
                // Se falta ent1 mas tem ent2 (por ex: falta, folga), deixar ent1 vazio e preencher ent2
                const horariosOrdenados = organizarHorariosPDF(horarios, currentAnexoEmployee);
                
                return {
                    id: idDetectado,
                    assinaturaFuncionario: assinaturaFuncionarioDetectada,
                    assinaturaLider: assinaturaLiderDetectada,
                    ent1: horariosOrdenados.ent1 || null,
                    sai1: horariosOrdenados.sai1 || null,
                    ent2: horariosOrdenados.ent2 || null,
                    sai2: horariosOrdenados.sai2 || null,
                    ent3: horariosOrdenados.ent3 || null,
                    sai3: horariosOrdenados.sai3 || null,
                    ent4: horariosOrdenados.ent4 || null,
                    sai4: horariosOrdenados.sai4 || null,
                    ent5: horariosOrdenados.ent5 || null,
                    sai5: horariosOrdenados.sai5 || null,
                    motivo: motivoDetectado,
                    confidence: {
                        ent1: horariosOrdenados.ent1 ? 95 : 0,
                        sai1: horariosOrdenados.sai1 ? 95 : 0,
                        ent2: horariosOrdenados.ent2 ? 95 : 0,
                        sai2: horariosOrdenados.sai2 ? 95 : 0,
                        ent3: horariosOrdenados.ent3 ? 95 : 0,
                        sai3: horariosOrdenados.sai3 ? 95 : 0,
                        ent4: horariosOrdenados.ent4 ? 95 : 0,
                        sai4: horariosOrdenados.sai4 ? 95 : 0,
                        ent5: horariosOrdenados.ent5 ? 95 : 0,
                        sai5: horariosOrdenados.sai5 ? 95 : 0,
                        motivo: motivoDetectado ? 90 : 0
                    },
                    fullText: fullText
                };
                
            } catch (error) {
                console.error('? Erro Azure Vision API:', error);
                throw error;
            }
        }

        // TAREFA 3: Organizar horários do PDF de forma inteligente
        // Comparar com horários já batidos para preencher os slots corretos
        function organizarHorariosPDF(horariosOCR, employee) {
            console.log('📋 TAREFA 3: Organizando horários do PDF...');
            console.log('   Horários OCR extraídos:', horariosOCR);
            
            if (!employee || !employee.punches) {
                console.log('   ⚠️ Sem dados do funcionário, usando lógica de pares');
                // Preencher em PARES: ent1+sai1, ent2+sai2, ent3+sai3
                return {
                    ent1: horariosOCR[0] || null,
                    sai1: horariosOCR[1] || null,
                    ent2: horariosOCR[2] || null,
                    sai2: horariosOCR[3] || null,
                    ent3: horariosOCR[4] || null,
                    sai3: horariosOCR[5] || null,
                    ent4: horariosOCR[6] || null,
                    sai4: horariosOCR[7] || null,
                    ent5: horariosOCR[8] || null,
                    sai5: horariosOCR[9] || null
                };
            }

            // Pegar horários já batidos no Secullum
            const batidosSecullum = [
                { slot: 'ent1', horario: employee.punches.ent1 },
                { slot: 'sai1', horario: employee.punches.sai1 },
                { slot: 'ent2', horario: employee.punches.ent2 },
                { slot: 'sai2', horario: employee.punches.sai2 },
                { slot: 'ent3', horario: employee.punches.ent3 },
                { slot: 'sai3', horario: employee.punches.sai3 },
                { slot: 'ent4', horario: employee.punches.ent4 },
                { slot: 'sai4', horario: employee.punches.sai4 },
                { slot: 'ent5', horario: employee.punches.ent5 },
                { slot: 'sai5', horario: employee.punches.sai5 }
            ];

            console.log('   Horários já batidos no Secullum:');
            batidosSecullum.forEach(b => {
                if (b.horario && b.horario !== '--:--') {
                    console.log(`   ✅ ${b.slot}: ${b.horario}`);
                }
            });

            // ESTRATÉGIA NOVA: 
            // 1. Identificar quais slots estão vazios no Secullum
            // 2. Ordenar horários do OCR cronologicamente
            // 3. Preencher mantendo PARES completos (ent1+sai1, ent2+sai2, etc)
            
            const slotsVazios = batidosSecullum
                .filter(b => !b.horario || b.horario === '--:--')
                .map(b => b.slot);

            console.log('   Slots vazios para preencher:', slotsVazios);

            // Se não há slots vazios, retornar os horários batidos
            if (slotsVazios.length === 0) {
                console.log('   ⚠️ Todos os slots já preenchidos, mantendo horários batidos');
                return {
                    ent1: employee.punches.ent1,
                    sai1: employee.punches.sai1,
                    ent2: employee.punches.ent2,
                    sai2: employee.punches.sai2,
                    ent3: employee.punches.ent3,
                    sai3: employee.punches.sai3,
                    ent4: employee.punches.ent4,
                    sai4: employee.punches.sai4,
                    ent5: employee.punches.ent5,
                    sai5: employee.punches.sai5
                };
            }

            // Ordenar horários do OCR cronologicamente
            const horariosOrdenados = [...horariosOCR].sort((a, b) => {
                const [ha, ma] = a.split(':').map(Number);
                const [hb, mb] = b.split(':').map(Number);
                return (ha * 60 + ma) - (hb * 60 + mb);
            });

            console.log('   Horários OCR ordenados:', horariosOrdenados);

            // Preencher resultado: manter batidos + adicionar OCR nos slots vazios
            const resultado = {
                ent1: employee.punches.ent1 || null,
                sai1: employee.punches.sai1 || null,
                ent2: employee.punches.ent2 || null,
                sai2: employee.punches.sai2 || null,
                ent3: employee.punches.ent3 || null,
                sai3: employee.punches.sai3 || null,
                ent4: employee.punches.ent4 || null,
                sai4: employee.punches.sai4 || null,
                ent5: employee.punches.ent5 || null,
                sai5: employee.punches.sai5 || null
            };

            // 🔧 LÓGICA CORRIGIDA: Preencher mantendo pares (ent+sai juntos)
            // Se tem ent1 mas não tem sai1 → preencher sai1 primeiro
            // Se tem ent1+sai1 mas não tem ent2 → preencher ent2 primeiro
            const ordemPreferencial = ['ent1', 'sai1', 'ent2', 'sai2', 'ent3', 'sai3', 'ent4', 'sai4', 'ent5', 'sai5'];
            const vaziosOrdenados = ordemPreferencial.filter(slot => slotsVazios.includes(slot));

            let indiceOCR = 0;
            for (const slot of vaziosOrdenados) {
                if (indiceOCR < horariosOrdenados.length) {
                    resultado[slot] = horariosOrdenados[indiceOCR];
                    console.log(`   📝 Preenchendo ${slot} com ${horariosOrdenados[indiceOCR]}`);
                    indiceOCR++;
                }
            }

            console.log('   ✅ Resultado final:', resultado);
            return resultado;
        }        // 📝 BUSCA DINçãMICA: Detecta TODAS as batidas (não Só 4 fixas)
        function detectarCaixasAmarelas(canvas) {
            
            
            // ℹ GRID AUTOméTICO: Detecta quantas colunas e linhas existem
            // Baseado na imagem: primeira linha Yçã300, segunda linha Yçã380, etc
            const regioes = [];
            
            const larguraCampo = 170;
            const alturaCampo = 75;
            const espacamentoX = 200; // Espaão entre colunas
            const espacamentoY = 95;  // Espaão entre linhas
            
            const inicioX = 160;
            const inicioY = 300; // Começãa mais alto para pegar primeira linha
            
            const maxColunas = 5; // máximo 5 por linha (como na imagem 1)
            const maxLinhas = 3;  // máximo 3 linhas (cobre até 15 batidas)
            
            let indice = 1;
            
            for (let linha = 0; linha < maxLinhas; linha++) {
                for (let coluna = 0; coluna < maxColunas; coluna++) {
                    const x = inicioX + (coluna * espacamentoX);
                    const y = inicioY + (linha * espacamentoY);
                    
                    regioes.push({
                        x: x,
                        y: y,
                        w: larguraCampo,
                        h: alturaCampo,
                        nome: `Batida ${indice}`,
                        linha: linha + 1,
                        coluna: coluna + 1
                    });
                    
                    indice++;
                }
            }
            
            
            
            // 📝 DEBUG VISUAL: Desenhar reténgulos nas regiçães buscadas
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            // Desenhar TODAS as regiões em azul (busca direta, sem detecção de cor)
            for (const regiao of regioes) {
                debugCtx.strokeStyle = 'blue';
                debugCtx.lineWidth = 3;
                debugCtx.strokeRect(regiao.x, regiao.y, regiao.w, regiao.h);
                
                // Label
                debugCtx.fillStyle = 'blue';
                debugCtx.font = 'bold 16px Arial';
                debugCtx.fillText(regiao.nome, regiao.x + 5, regiao.y - 5);
            }
            
            // Abrir janela com debug
            try {
                const debugUrl = debugCanvas.toDataURL();
                const debugWindow = window.open('', '_blank', 'width=1200,height=800');
                if (debugWindow) {
                    debugWindow.document.write(`
                        <html>
                        <head><title>Debug - Regiões de Busca</title></head>
                        <body style="margin:0;background:#000;display:flex;justify-content:center;align-items:center;">
                            <div style="text-align:center;">
                                <h2 style="color:white;">ℹ Regiões de Busca Fixas</h2>
                                <p style="color:cyan;">ã AZUL = Busca OCR direta (sem detecção de cor)</p>
                                <img src="${debugUrl}" style="border:2px solid white;max-width:100%;"/>
                                <p style="color:yellow;">Y atual: 460 | Ajuste se necesSório!</p>
                            </div>
                        </body>
                        </html>
                    `);
                }
            } catch (e) {
                console.warn('ℹ não foi posSóvel abrir janela de debug');
            }
            
            return regioes; // Retorna TODAS as regiões (busca direta)
        }
        
        // OCR em região específica (crop)
        async function ocrRegion(canvas, region) {
            const cropCanvas = document.createElement('canvas');
            const ctx = cropCanvas.getContext('2d');
            
            cropCanvas.width = region.w;
            cropCanvas.height = region.h;
            
            ctx.drawImage(canvas, 
                region.x, region.y, region.w, region.h,
                0, 0, region.w, region.h
            );
            
            // Prçã-processar crop
            const blob = await new Promise(resolve => {
                cropCanvas.toBlob(resolve, 'image/png');
            });
            
            const processedBlob = await preprocessarImagem(new File([blob], 'crop.png'));
            
            const result = await Tesseract.recognize(processedBlob, 'por', {
                tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                tessedit_char_whitelist: '0123456789:ENTRADASóRIO ',
                tessedit_min_orientation_margin: '7.0',
                classify_bln_numeric_mode: '1'
            });
            
            return result.data;
        }
        
        // Detectar checkbox marcado - ANÁLISE PERCENTUAL MELHORADA
        function detectarCheckboxMarcado(canvas) {
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            console.log(`📋 Análise de checkbox em imagem ${canvas.width}x${canvas.height}`);
            
            // ? COORDENADAS DOS CHECKBOXES (quadradinhos, não o texto)
            // Baseado na imagem 954x641:
            // - Checkboxes ficam ã ESQUERDA do texto
            // - Linha 1: Y ~ 385 (60% da altura)
            // - Linha 2: Y ~ 410 (64% da altura)
            // - Margem esquerda dos checkboxes: 5%, depois +20% entre cada um
            
            const largura = canvas.width;
            const altura = canvas.height;
            
            const checkboxes = [
                // Linha 1 (Y = 60%)
                // ? AJUSTE CRÍTICO: Quadradinhos ficam BEM à ESQUERDA, antes do texto
                // Baseado na imagem: checkbox tem ~15px, fica a ~50px da esquerda
                { x: Math.round(largura * 0.045), y: Math.round(altura * 0.601), label: 'Esqueceu de registrar o Ponto' },
                { x: Math.round(largura * 0.275), y: Math.round(altura * 0.601), label: 'Falha no App' },
                { x: Math.round(largura * 0.515), y: Math.round(altura * 0.601), label: 'Falta' },
                { x: Math.round(largura * 0.755), y: Math.round(altura * 0.601), label: 'Folga' },
                // Linha 2 (Y = 64%)
                { x: Math.round(largura * 0.045), y: Math.round(altura * 0.641), label: 'Hora Parada' },
                { x: Math.round(largura * 0.275), y: Math.round(altura * 0.641), label: 'Maquina Ponto com defeito' },
                { x: Math.round(largura * 0.515), y: Math.round(altura * 0.641), label: 'Registro em duplicidade' },
                { x: Math.round(largura * 0.655), y: Math.round(altura * 0.641), label: 'Registro indevido' }
            ];
            
            console.log(`ℹ Analisando ${checkboxes.length} checkboxes...`);
            
            // 📝 DEBUG VISUAL: Desenhar círculos vermelhos nas coordenadas
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            debugCtx.strokeStyle = 'red';
            debugCtx.lineWidth = 3;
            debugCtx.fillStyle = 'red';
            debugCtx.font = '14px Arial';
            
            // ? NOVA ESTRATÉGIA: Pegar o checkbox com MAIOR % de preto
            let maxPreto = 0;
            let checkboxMarcado = null;
            
            checkboxes.forEach((cb, index) => {
                // Desenhar círculo vermelho
                debugCtx.beginPath();
                debugCtx.arc(cb.x, cb.y, 10, 0, 2 * Math.PI);
                debugCtx.stroke();
                
                // Desenhar número
                debugCtx.fillText(`${index + 1}`, cb.x + 15, cb.y + 5);
                
                // Analisar área 18x18
                const tamanho = 18;
                const imageData = ctx.getImageData(cb.x - tamanho/2, cb.y - tamanho/2, tamanho, tamanho);
                const data = imageData.data;
                
                let pixelsPretos = 0;
                let pixelsTotal = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Contar pixels pretos/escuros
                    if (r + g + b < 350) {
                        pixelsPretos++;
                    }
                    pixelsTotal++;
                }
                
                const percentualPreto = (pixelsPretos / pixelsTotal) * 100;
                
                console.log(`ℹ ${cb.label} (${cb.x},${cb.y}): ${percentualPreto.toFixed(1)}% preto`);
                
                // Guardar o que tiver MAIS preto
                if (percentualPreto > maxPreto) {
                    maxPreto = percentualPreto;
                    checkboxMarcado = cb.label;
                }
            });
            
            // 📝 Abrir imagem de debug automaticamente em nova aba
            const debugUrl = debugCanvas.toDataURL('image/png');
            console.log('✅ IMAGEM DE DEBUG GERADA!');
            console.log('? Abrindo imagem com círculos vermelhos em nova aba...');
            console.log('📋 Legenda: 1=Esqueceu, 2=Falha no App, 3=Falta, 4=Folga, 5=Hora Parada, 6=Maquina defeito, 7=Duplicidade, 8=Indevido');
            
            // Abrir em nova aba automaticamente
            const debugWindow = window.open();
            if (debugWindow) {
                debugWindow.document.write(`<img src="${debugUrl}" style="max-width:100%; height:auto;">`);
                debugWindow.document.title = 'Debug - Posições dos Checkboxes';
            } else {
                console.log('⚠️ Pop-up bloqueado! Cole este link numa nova aba:');
                console.log(debugUrl);
            }
            
            // ✅ Retornar o checkbox com MAIOR concentração de preto (se > 8% - threshold mais sensível)
            if (maxPreto > 8) {
                console.log(`✅ Checkbox marcado detectado: "${checkboxMarcado}" (${maxPreto.toFixed(1)}% preto)`);
                return checkboxMarcado;
            }
            
            console.log(`⚠️ Nenhum checkbox com concentração suficiente de preto (máximo: ${maxPreto.toFixed(1)}%), usando padrão`);
            return 'Esqueceu de registrar o Ponto';
        }
        
        // ==========================================
        // DETECÇÃO DE ASSINATURAS (FUNCIONÁRIO E Líder)
        // ==========================================
        function detectarAssinaturas(canvas) {
            console.log('🔍 Iniciando detecção de assinaturas (FUNCIONÁRIO + Líder)...');
            
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            const largura = canvas.width;
            const altura = canvas.height;
            
            // 📝 REGIÕES DAS ASSINATURAS
            // Baseado na imagem fornecida:
            
            // FUNCIONÁRIO (lado esquerdo inferior)
            // Região focada ACIMA do nome impresso "ADEMIR QUEIROZ DE SOUSA"
            const regiaoFuncionario = {
                x: Math.round(largura * 0.05),  // 5% da largura
                y: Math.round(altura * 0.80),   // 80% da altura (área da assinatura manuscrita)
                w: Math.round(largura * 0.40),  // 40% da largura
                h: Math.round(altura * 0.10),   // 10% da altura (Só a área da assinatura, não o texto)
                nome: 'FUNCIONÁRIO',
                cor: '#3b82f6'  // Azul
            };
            
            // Líder (lado direito inferior)
            // Região focada ACIMA do nome impresso "JOãO CARLOS ALMEIDA LOPES"
            const regiaoLider = {
                x: Math.round(largura * 0.52),  // 52% da largura (metade direita)
                y: Math.round(altura * 0.80),   // 80% da altura (área da assinatura manuscrita)
                w: Math.round(largura * 0.43),  // 43% da largura
                h: Math.round(altura * 0.10),   // 10% da altura (Só a área da assinatura)
                nome: 'Líder',
                cor: '#10b981'  // Verde
            };
            
            const regioes = [regiaoFuncionario, regiaoLider];
            
            // 📝 DEBUG VISUAL: Criar canvas com reténgulos coloridos
            const debugCanvas = document.createElement('canvas');
            const debugCtx = debugCanvas.getContext('2d');
            debugCanvas.width = canvas.width;
            debugCanvas.height = canvas.height;
            debugCtx.drawImage(canvas, 0, 0);
            
            // Analisar cada região
            const resultados = {};
            
            regioes.forEach(regiao => {
                console.log(`\nℹ Analisando ${regiao.nome}:`);
                console.log(`   Região: X=${regiao.x}, Y=${regiao.y}, W=${regiao.w}, H=${regiao.h}`);
                
                // Extrair dados da região
                const imageData = ctx.getImageData(regiao.x, regiao.y, regiao.w, regiao.h);
                const data = imageData.data;
                
                // Análise de pixels
                let pixelsEscuros = 0;
                let pixelsTotal = 0;
                let pixelsMuitoEscuros = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const luminosidade = (r + g + b) / 3;
                    
                    pixelsTotal++;
                    
                    if (luminosidade < 180) {
                        pixelsEscuros++;
                    }
                    
                    if (luminosidade < 100) {
                        pixelsMuitoEscuros++;
                    }
                }
                
                const percentualEscuros = (pixelsEscuros / pixelsTotal) * 100;
                const percentualMuitoEscuros = (pixelsMuitoEscuros / pixelsTotal) * 100;
                
                console.log(`   ℹ Pixels escuros (<180): ${percentualEscuros.toFixed(2)}%`);
                console.log(`   ℹ Pixels muito escuros (<100): ${percentualMuitoEscuros.toFixed(2)}%`);
                
                // Critério de detecçãão (threshold ajustado para distinguir assinatura manuscrita de texto impresso)
                // Texto impresso: ~1-2% pixels escuros
                // Assinatura manuscrita: ~5-10% pixels escuros
                const temAssinatura = percentualMuitoEscuros > 3 || percentualEscuros > 5;
                
                console.log(`   ${temAssinatura ? '? ASSINADO' : '? não ASSINADO'}`);
                
                // Guardar resultado (usar chaves fixas para evitar problemas)
                if (regiao.nome === 'FUNCIONÁRIO') {
                    resultados.funcionario = temAssinatura;
                } else if (regiao.nome === 'Líder') {
                    resultados.lider = temAssinatura;
                }
                
                // Desenhar reténgulo colorido
                debugCtx.strokeStyle = temAssinatura ? regiao.cor : '#ef4444'; // Verde/Azul se assinado, Vermelho se não
                debugCtx.lineWidth = 4;
                debugCtx.strokeRect(regiao.x, regiao.y, regiao.w, regiao.h);
                
                // Desenhar label
                debugCtx.fillStyle = temAssinatura ? regiao.cor : '#ef4444';
                debugCtx.font = 'bold 24px Arial';
                const label = `${temAssinatura ? '?' : '?'} ${regiao.nome.toUpperCase()}`;
                const textMetrics = debugCtx.measureText(label);
                const padding = 10;
                
                // Fundo do texto
                debugCtx.fillRect(
                    regiao.x, 
                    regiao.y - 40, 
                    textMetrics.width + padding * 2, 
                    35
                );
                
                // Texto
                debugCtx.fillStyle = 'white';
                debugCtx.fillText(label, regiao.x + padding, regiao.y - 12);
                
                // Adicionar percentuais
                debugCtx.font = '14px Arial';
                debugCtx.fillStyle = temAssinatura ? regiao.cor : '#ef4444';
                const stats = `${percentualMuitoEscuros.toFixed(1)}% preto | ${percentualEscuros.toFixed(1)}% escuro`;
                debugCtx.fillText(stats, regiao.x + 10, regiao.y + 25);
            });
            
            // 📝 Mostrar imagem de debug
            const debugUrl = debugCanvas.toDataURL('image/png');
            const debugWindow = window.open('', '_blank', 'width=1000,height=800');
            if (debugWindow) {
                debugWindow.document.write(`
                    <html>
                        <head>
                            <title>ℹ Detecçãão de Assinaturas</title>
                            <style>
                                body { 
                                    margin: 0; 
                                    padding: 20px; 
                                    background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%);
                                    font-family: Arial, sans-serif;
                                }
                                .container {
                                    background: rgba(30, 41, 59, 0.95);
                                    border-radius: 15px;
                                    padding: 20px;
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                                }
                                h1 { 
                                    color: #e2e8f0; 
                                    margin: 0 0 15px 0;
                                    font-size: 28px;
                                }
                                .stats {
                                    display: grid;
                                    grid-template-columns: 1fr 1fr;
                                    gap: 15px;
                                    margin-bottom: 20px;
                                }
                                .stat-box {
                                    padding: 15px;
                                    border-radius: 10px;
                                    text-align: center;
                                }
                                .stat-box.funcionario { background: #dbeafe; border: 3px solid #3b82f6; }
                                .stat-box.lider { background: #d1fae5; border: 3px solid #10b981; }
                                .stat-box.unsigned { background: #fee2e2; border: 3px solid #ef4444; }
                                .stat-box h3 { margin: 0 0 5px 0; font-size: 18px; }
                                .stat-box .status { font-size: 32px; margin: 5px 0; }
                                .stat-box .label { font-size: 14px; color: #64748b; }
                                img { 
                                    max-width: 100%; 
                                    border: 3px solid #cbd5e1; 
                                    border-radius: 10px;
                                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                                }
                                .info {
                                    margin-top: 15px;
                                    padding: 15px;
                                    background: #f1f5f9;
                                    border-left: 4px solid #3b82f6;
                                    border-radius: 5px;
                                    font-size: 13px;
                                    color: #475569;
                                }
                            </style>
                        </head>
                        <body>
                            <div class="container">
                                <h1>ℹ Detecçãão de Assinaturas</h1>
                                <div class="stats">
                                    <div class="stat-box ${resultados.funcionario ? 'funcionario' : 'unsigned'}">
                                        <h3>ℹ FUNCIONÁRIO</h3>
                                        <div class="status">${resultados.funcionario ? '?' : '?'}</div>
                                        <div class="label">${resultados.funcionario ? 'ASSINADO' : 'não ASSINADO'}</div>
                                    </div>
                                    <div class="stat-box ${resultados.lider ? 'lider' : 'unsigned'}">
                                        <h3>ℹ Líder</h3>
                                        <div class="status">${resultados.lider ? '?' : '?'}</div>
                                        <div class="label">${resultados.lider ? 'ASSINADO' : 'não ASSINADO'}</div>
                                    </div>
                                </div>
                                <img src="${debugUrl}">
                                <div class="info">
                                    <strong>ℹ Legenda:</strong><br>
                                    ℹ Reténgulo AZUL = Região do FUNCIONÁRIO<br>
                                    ℹ Reténgulo VERDE = Região do Líder<br>
                                    ℹ Reténgulo VERMELHO = Assinatura não detectada<br><br>
                                    <strong>Limiar de detecçãão:</strong> =2% pixels muito escuros OU =6% pixels escuros
                                </div>
                            </div>
                        </body>
                    </html>
                `);
            }
            
            return resultados;
        }
        
        // ==========================================
        // EXTRAÇÃO DE ID DO PDF (VERSóO CORRIGIDA FINAL)
        // ==========================================
        async function extrairIdDoPDF(canvas) {
            console.log('🔍 Iniciando extração de ID (posiçãoo: ID IMP)...');
            console.log('📊 DimenSóes do canvas original:', canvas.width + 'x' + canvas.height);
            
            try {
                // ? REGIãO CORRETA: "ID IMP: XX" na SEGUNDA linha do cabeçãalho
                // Layout: [Nome/Cidade/Data] na linha 1, [REG/Projeto/ID IMP] na linha 2
                // ID IMP esté no canto direito da segunda linha do cabeçãalho
                const idRegion = { 
                    x: 700,  // Mais ã esquerda para capturar "ID IMP:" completo
                    y: 175,  // Ajustado para linha 2 do cabeçãalho
                    w: 150,  // Largura maior para capturar "ID IMP: XX" completo
                    h: 40    // Altura maior para garantir captura
                };
                
                console.log(`ℹ Buscando na região: X=${idRegion.x}, Y=${idRegion.y}, W=${idRegion.w}, H=${idRegion.h}`);
                
                // Crop da região
                const cropCanvas = document.createElement('canvas');
                const ctx = cropCanvas.getContext('2d');
                
                // Ampliar 4x para melhor leitura
                const scale = 4;
                cropCanvas.width = idRegion.w * scale;
                cropCanvas.height = idRegion.h * scale;
                
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(canvas, 
                    idRegion.x, idRegion.y, idRegion.w, idRegion.h,
                    0, 0, cropCanvas.width, cropCanvas.height
                );
                
                // Processamento de imagem: binarização forte
                const imageData = ctx.getImageData(0, 0, cropCanvas.width, cropCanvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Converter para escala de cinza
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    
                    // Binarização AGRESSIVA: texto preto vs fundo branco
                    // Threshold mais alto para melhor contraste
                    const binary = gray < 180 ? 0 : 255;
                    data[i] = data[i + 1] = data[i + 2] = binary;
                }
                
                ctx.putImageData(imageData, 0, 0);
                
                // OCR otimizado
                const blob = await new Promise(resolve => cropCanvas.toBlob(resolve, 'image/png'));
                
                const result = await Tesseract.recognize(blob, 'por', {
                    tessedit_char_whitelist: '0123456789IDIMP: ',
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
                    preserve_interword_spaces: '1'
                });
                
                // 📝 DEBUG VISUAL: Mostrar imagem processada e abrir em nova aba
                const debugUrl = cropCanvas.toDataURL();
                console.log('? Região processada (copie o link abaixo e cole em nova aba):');
                console.log(debugUrl);
                console.log('📊 Tamanho da região: ' + cropCanvas.width + 'x' + cropCanvas.height + 'px');
                
                // Abrir automaticamente em nova janela para visualização
                try {
                    const debugWindow = window.open();
                    if (debugWindow) {
                        debugWindow.document.write(`<img src="${debugUrl}" style="border: 2px solid red;"/>`);
                        debugWindow.document.write(`<p>Região: X=${idRegion.x}, Y=${idRegion.y}, W=${idRegion.w}, H=${idRegion.h}</p>`);
                    }
                } catch (e) {
                    console.warn('ℹ não foi posSóvel abrir janela de debug (popup bloqueado?)');
                }
                
                // ? verificaçãoO SEGURA: checar se result existe antes de acessar propriedades
                if (!result || !result.data) {
                    console.error('? OCR não retornou dados válidos:', result);
                    return null;
                }
                
                const textoExtraido = result.data.text || '';
                const confidence = result.data.confidence || 0;
                
                console.log(`   ℹ Texto extraído: "${textoExtraido.trim()}"`);
                console.log(`   ℹ Confiança: ${Math.round(confidence)}%`);
                
                if (!textoExtraido) {
                    console.warn('   ℹ OCR não retornou texto');
                    return null;
                }
                
                // ? EXTRAIR ID: APENAS se tiver "ID IMP" próximo ao nçãmero
                // Padrão 1: "ID IMP: 22" ou "ID IMP 22" ou "IDIMP:22"
                let match = textoExtraido.match(/ID\s*IMP\s*:?\s*(\d{1,3})/i);
                
                // Padrão 2: Número ISOLADO de 1-2 dígitos (ID IMP geralmente ã < 100)
                // IMPORTANTE: não capturar números de data (evita "17" de "17/11")
                if (!match) {
                    // Procurar número que não esté próximo de barra (/)
                    const textoLimpo = textoExtraido.replace(/\d{1,2}\/\d{1,2}(\/\d{2,4})?/g, ''); // Remove datas
                    match = textoLimpo.match(/\b(\d{1,2})\b/); // Números de 1-2 dígitos SOMENTE
                }
                
                if (match && match[1]) {
                    const id = parseInt(match[1]);
                    
                    // Validar se esté em range válido (1-99, expandido para permitir até 200 se necesSório)
                    if (id > 0 && id <= 200) {
                        console.log(`? ID detectado: #${id} (confiança: ${Math.round(confidence)}%)`);
                        return id.toString();
                    } else {
                        console.warn(`   ℹ Nçãmero encontrado (${id}) mas fora do range válido (1-200)`);
                    }
                } else {
                    console.warn('   ℹ Nenhum padrão de ID encontrado no texto');
                }
                
                // 📝 FALLBACK: Tentar regiões alternativas
                console.log('🔍 Tentando regiões alternativas...');
                
                const alternativeRegions = [
                    { x: 650, y: 175, w: 200, h: 40, desc: 'Região ampla esquerda' },
                    { x: 680, y: 160, w: 160, h: 45, desc: 'Mais alto' },
                    { x: 720, y: 190, w: 140, h: 35, desc: 'Centro-direita' },
                    { x: 750, y: 175, w: 120, h: 40, desc: 'Extrema direita' },
                    { x: 600, y: 170, w: 250, h: 50, desc: 'Região MUITO ampla (Última tentativa)' }
                ];
                
                for (const altRegion of alternativeRegions) {
                    console.log(`   ℹ Tentando: ${altRegion.desc} (X=${altRegion.x}, Y=${altRegion.y})`);
                    
                    const altCanvas = document.createElement('canvas');
                    const altCtx = altCanvas.getContext('2d');
                    const altScale = 4;
                    
                    altCanvas.width = altRegion.w * altScale;
                    altCanvas.height = altRegion.h * altScale;
                    altCtx.imageSmoothingEnabled = false;
                    altCtx.drawImage(canvas, 
                        altRegion.x, altRegion.y, altRegion.w, altRegion.h,
                        0, 0, altCanvas.width, altCanvas.height
                    );
                    
                    // Prçã-processamento
                    const altImageData = altCtx.getImageData(0, 0, altCanvas.width, altCanvas.height);
                    const altData = altImageData.data;
                    for (let i = 0; i < altData.length; i += 4) {
                        const gray = 0.299 * altData[i] + 0.587 * altData[i + 1] + 0.114 * altData[i + 2];
                        const binary = gray < 160 ? 0 : 255;
                        altData[i] = altData[i + 1] = altData[i + 2] = binary;
                    }
                    altCtx.putImageData(altImageData, 0, 0);
                    
                    const altBlob = await new Promise(resolve => altCanvas.toBlob(resolve, 'image/png'));
                    
                    // Tentar com PSM.SINGLE_LINE primeiro
                    let altResult = await Tesseract.recognize(altBlob, 'por', {
                        tessedit_char_whitelist: '0123456789IDIMP: ',
                        tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE
                    });
                    
                    // Se falhar, tentar com PSM.AUTO
                    if (!altResult?.data?.text || altResult.data.text.trim() === '') {
                        console.log('      ℹ PSM.SINGLE_LINE falhou, tentando PSM.AUTO...');
                        altResult = await Tesseract.recognize(altBlob, 'por', {
                            tessedit_char_whitelist: '0123456789IDIMP: ',
                            tessedit_pageseg_mode: Tesseract.PSM.AUTO
                        });
                    }
                    
                    if (altResult?.data?.text) {
                        const altTexto = altResult.data.text.trim();
                        console.log(`      ℹ Texto alternativo: "${altTexto}"`);
                        
                        const altMatch = altTexto.match(/ID\s*IMP\s*:?\s*(\d{1,3})/i) || 
                                        altTexto.replace(/\d{1,2}\/\d{1,2}/g, '').match(/\b(\d{1,2})\b/);
                        
                        if (altMatch?.[1]) {
                            const altId = parseInt(altMatch[1]);
                            if (altId > 0 && altId <= 200) {
                                console.log(`? ID detectado na região alternativa: #${altId}`);
                                return altId.toString();
                            }
                        }
                    }
                }
                
            } catch (err) {
                console.error('? Erro ao extrair ID:', err);
                console.error('Stack trace:', err.stack);
            }
            
            console.warn('ℹ ID não encontrado no PDF (tentativas esgotadas)');
            return null;
        }

        
        // ==========================================
        // PROCESSAMENTO DE IMAGEM COM validaçãoO INTELIGENTE
        // ==========================================
        async function processarImagem(file) {
            console.log('🛠️ Processando imagem:', file.name || 'clipboard');
            
            // Mostrar preview
            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('previewImage').src = e.target.result;
                document.getElementById('previewArea').style.display = 'block';
                currentAnexoImage = e.target.result;
            };
            reader.readAsDataURL(file);
            
            // Mostrar status
            document.getElementById('ocrStatus').style.display = 'block';
            document.getElementById('ocrResult').style.display = 'none';
            document.getElementById('ocrStatusText').textContent = 'ℹ Analisando com Google Vision AI...';
            
            try {
                // Converter para base64
                const readerBase64 = new FileReader();
                const base64Image = await new Promise((resolve) => {
                    readerBase64.onload = (e) => resolve(e.target.result);
                    readerBase64.readAsDataURL(file);
                });
                
                // ======================================
                // ETAPA 1: VALIDAR ID (mantém légica existente)
                // ======================================
                document.getElementById('ocrStatusText').textContent = 'ℹ Verificando ID do formulério...';
                
                const dadosExtraidos = await extrairDadosComGoogleVision(base64Image);
                
                const idEncontrado = dadosExtraidos.id;
                const idEsperado = currentAnexoEmployee?.id;
                
                console.log('');
                
                console.log('');
                
                // 📝 CASO 1: IDs diferentes OU não detectado = AVISAR MAS CONTINUAR
                if (idEsperado && idEncontrado && parseInt(idEncontrado) !== parseInt(idEsperado)) {
                    console.warn(`⚠️ ID DIFERENTE! Esperado: #${idEsperado}, Detectado: #${idEncontrado}`);
                    showAlert('Atenção', `ID diferente! Esperado: #${idEsperado}, Detectado: #${idEncontrado}`, 'warning');
                }
                
                // 📝 CASO 2: não leu ID = AVISAR MAS CONTINUAR
                if (idEsperado && !idEncontrado) {
                    console.warn(`⚠️ ID não detectado. Esperado: #${idEsperado}`);
                    showAlert('Aviso', `ID não detectado. Esperado: #${idEsperado}`, 'info');
                }
                
                // ✅ CASO 3: IDs batem
                if (idEncontrado && idEsperado && parseInt(idEncontrado) === parseInt(idEsperado)) {
                    console.log(`✅ ID VALIDADO COM SUCESSO! ✅`);
                }
                
                // 📝 CASO 4: Primeiro formulário
                if (!idEsperado) {
                    console.log(`ℹ FUNCIONÁRIO ainda não possui ID no sistema`);
                }
                
                // ======================================
                // ETAPA 2: USAR DADOS DO GOOGLE VISION
                // ======================================
                
                currentOCRData = dadosExtraidos;
                
                // Esconder status e mostrar resultado
                document.getElementById('ocrStatus').style.display = 'none';
                mostrarResultadoOCR(dadosExtraidos);
                document.getElementById('btnConfirmarAnexo').style.display = 'block';
                
            } catch (err) {
                console.error('? Erro no OCR:', err);
                console.error('Stack:', err.stack);
                document.getElementById('ocrStatusText').textContent = 'ℹ Erro - você pode continuar manualmente';
                document.getElementById('btnConfirmarAnexo').style.display = 'block';
            }
        }

        
        // 📝 funçãoO ANTIGA - não MAIS USADA (substituçãda por extrairIdDoPDF(canvas))
        /*
        function extrairIdDoPDF_OLD(texto, palavrasComConfidencia = []) {
            console.log('🔍 Buscando ID no PDF...');
            
            // méTODO 1: Buscar padrão "ID #22" no texto completo
            const patterns = [
                /ID\s*#\s*(\d+)/i,
                /ID#(\d+)/i,
                /ID:(\d+)/i,
                /ID\s+(\d+)/i,
                /\bI\s*D\s*#?\s*(\d+)/i
            ];
            
            for (const pattern of patterns) {
                const match = texto.match(pattern);
                if (match) {
                    const id = match[1];
                    // Validar que não ã REG, Projeto ou Data
                    if (parseInt(id) < 200 && id.length <= 3) {
                        console.log(`ℹ ID encontrado (método 1 - texto): #${id}`);
                        return id;
                    }
                }
            }
            
            // méTODO 2: Buscar "#" seguido de nçãmero pequeno em qualquer lugar
            const hashMatch = texto.match(/#\s*(\d{1,3})\b/);
            if (hashMatch) {
                const id = hashMatch[1];
                if (parseInt(id) > 0 && parseInt(id) < 200) {
                    console.log(`ℹ ID encontrado (método 2 - hash): #${id}`);
                    return id;
                }
            }
            
            // MÉTODO 3: Buscar em palavras com alta confiança no CANTO SUPERIOR DIREITO
            if (palavrasComConfidencia && palavrasComConfidencia.length > 0) {
                console.log('📊 Analisando posiçãoes das palavras...');
                
                const candidatosID = [];
                
                palavrasComConfidencia.forEach((word, index) => {
                    // Procurar números de 1-3 dígitos no canto superior direito
                    const match = word.text.match(/^#?(\d{1,3})$/);
                    if (match && word.confidence > 80) {
                        const id = match[1];
                        const x = word.bbox.x0;
                        const y = word.bbox.y0;
                        const num = parseInt(id);
                        
                        // ID deve estar: TOPO (Y < 250) e DIREITA (X > 550)
                        // Nçãmero pequeno (< 200) para diferenciar de REG/Projeto
                        if (num > 0 && num < 200 && x > 550 && y < 250) {
                            candidatosID.push({
                                id: id,
                                confidence: word.confidence,
                                x: x,
                                y: y,
                                score: x - (y * 2) // Prioriza X alto e Y baixo (nçãmeros positivos)
                            });
                        }
                    }
                });
                
                // Ordenar por score (prioriza topo-direito)
                candidatosID.sort((a, b) => b.score - a.score);
                
                if (candidatosID.length > 0) {
                    const melhor = candidatosID[0];
                    console.log(`ℹ ID encontrado (método 3 - posiçãoo): #${melhor.id}`);
                    console.log(`   X=${Math.round(melhor.x)}, Y=${Math.round(melhor.y)}, Score=${Math.round(melhor.score)}, Confiança=${Math.round(melhor.confidence)}%`);
                    if (candidatosID.length > 1) {
                        console.log(`   Rejeitados: ${candidatosID.slice(1).map(c => `#${c.id} (X=${Math.round(c.x)}, Y=${Math.round(c.y)}, Score=${Math.round(c.score)})`).join(', ')}`);
                    }
                    return melhor.id;
                }
            }
            
            console.warn('ℹ ID não encontrado no PDF');
            return null;
        }
        */

        // 📝 função ANTIGA - não MAIS USADA (sistema hçãbrido agora detecta caixas automaticamente)
        /*
        // 📝 EXTRAÇÃO MELHORADA COM validação INTELIGENTE
        function extrairDadosOCRMelhorado(texto, palavrasFiltradas, ocrData) {
            console.log('🔍 Iniciando extração melhorada de dados...');
            
            const dados = {
                ent1: null,
                sai1: null,
                ent2: null,
                sai2: null,
                ent3: null,
                sai3: null,
                motivo: null,
                confidence: {
                    ent1: 0,
                    sai1: 0,
                    ent2: 0,
                    sai2: 0,
                    ent3: 0,
                    sai3: 0,
                    motivo: 0
                }
            };
            
            // EXTRaçãO DE HorárioS COM validaçãoO
            const horariosEncontrados = [];
            
            // Buscar Horários nas palavras filtradas (confiança > 70%)
            for (let i = 0; i < palavrasFiltradas.length; i++) {
                const word = palavrasFiltradas[i];
                
                // Padrão 1: HH:MM
                const match1 = word.text.match(/^(\d{1,2}):(\d{2})$/);
                if (match1) {
                    const hora = parseInt(match1[1]);
                    const min = parseInt(match1[2]);
                    
                    if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                        horariosEncontrados.push({
                            horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                            confidence: word.confidence,
                            posicao: word.bbox.x0
                        });
                        console.log(`? Horário detectado: ${hora}:${min} (confiança: ${Math.round(word.confidence)}%)`);
                    }
                }
                
                // Padrão 2: HHMM (4 dígitos)
                const match2 = word.text.match(/^(\d{4})$/);
                if (match2) {
                    const valor = match2[1];
                    const hora = parseInt(valor.substring(0, 2));
                    const min = parseInt(valor.substring(2, 4));
                    
                    if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                        if (parseInt(valor) < 2020 || parseInt(valor) > 2030) {
                            horariosEncontrados.push({
                                horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                                confidence: word.confidence,
                                posicao: word.bbox.x0
                            });
                            console.log(`? Horário detectado (4 dígitos): ${hora}:${min} (confiança: ${Math.round(word.confidence)}%)`);
                        }
                    }
                }
                
                // Padrão 3: HH MM (dois nçãmeros separados por espaão) - "07 10"
                const match3 = word.text.match(/^(\d{2})$/);
                if (match3 && i + 1 < palavrasFiltradas.length) {
                    const nextWord = palavrasFiltradas[i + 1];
                    const match4 = nextWord.text.match(/^(\d{2})$/);
                    
                    if (match4) {
                        const hora = parseInt(match3[1]);
                        const min = parseInt(match4[1]);
                        
                        // Verificar se prçãxima palavra esté prçãxima horizontalmente (mesmo Horário)
                        const distancia = Math.abs(nextWord.bbox.x0 - (word.bbox.x0 + 30));
                        const distanciaVertical = Math.abs(nextWord.bbox.y0 - word.bbox.y0);
                        
                        console.log(`ℹ Par "${word.text}" + "${nextWord.text}": X1=${Math.round(word.bbox.x0)}, X2=${Math.round(nextWord.bbox.x0)}, distH=${Math.round(distancia)}px, distV=${Math.round(distanciaVertical)}px`);
                        
                        if (distancia < 80 && distanciaVertical < 20 && hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                            horariosEncontrados.push({
                                horario: `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`,
                                confidence: (word.confidence + nextWord.confidence) / 2,
                                posicao: word.bbox.x0
                            });
                            console.log(`? Horário detectado (espaçado): ${hora}:${min} (confiança: ${Math.round((word.confidence + nextWord.confidence) / 2)}%)`);
                            i++; // Pular prçãxima palavra já processada
                        } else {
                            const motivos = [];
                            if (distancia >= 80) motivos.push('muito distante');
                            if (distanciaVertical >= 20) motivos.push('não alinhado');
                            if (hora < 0 || hora > 23 || min < 0 || min > 59) motivos.push('inválido');
                            console.log(`? Rejeitado: ${motivos.join(', ')}`);
                        }
                    }
                }
            }
            
            // Ordenar Horários por posiçãoo (esquerda ? direita, cima ? baixo)
            horariosEncontrados.sort((a, b) => a.posicao - b.posicao);
            
            console.log(`ℹ Total de Horários válidos encontrados: ${horariosEncontrados.length}`);
            
            // Atribuir Horários aos campos (máximo 6: ent1, sai1, ent2, sai2, ent3, sai3)
            const campos = ['ent1', 'sai1', 'ent2', 'sai2', 'ent3', 'sai3'];
            horariosEncontrados.slice(0, 6).forEach((h, index) => {
                if (campos[index]) {
                    dados[campos[index]] = h.horario;
                    dados.confidence[campos[index]] = Math.round(h.confidence);
                }
            });
            
            // EXTRaçãO DE MOTIVO COM DETECçããO DE CHECKBOX MARCADO
            const textoLower = texto.toLowerCase();
            const distanciaMax = 100;
            
            // Buscar marcaçães "X" com alta confiançãa
            const marcacoesX = palavrasFiltradas.filter(word => 
                /^[xX]$/.test(word.text) && word.confidence > 60
            );
            
            console.log(`? Marcaçães "X" encontradas (confiançãa > 60%): ${marcacoesX.length}`);
            
            // Lista de justificativas
            const justificativasMap = [
                { palavras: ['esquec', 'registr.*ponto'], motivo: 'Esqueceu de registrar o Ponto' },
                { palavras: ['falha.*app', 'app'], motivo: 'Falha no App' },
                { palavras: ['falta'], motivo: 'Falta' },
                { palavras: ['folga'], motivo: 'Folga' },
                { palavras: ['hora.*parada', 'parada'], motivo: 'Hora Parada' },
                { palavras: ['maquina.*defeito', 'méquina.*defeito', 'defeito'], motivo: 'Maquina Ponto com defeito' },
                { palavras: ['duplicidade', 'duplicado'], motivo: 'Registro em duplicidade' },
                { palavras: ['indevido'], motivo: 'Registro indevido' }
            ];
            
            let motivoDetectado = null;
            let menorDistancia = Infinity;
            let confidenciaMotivo = 0;
            
            justificativasMap.forEach(item => {
                item.palavras.forEach(palavra => {
                    const regex = new RegExp(palavra, 'i');
                    const match = textoLower.search(regex);
                    
                    if (match !== -1) {
                        // Procurar "X" próximo
                        marcacoesX.forEach(xWord => {
                            const dist = Math.abs(xWord.bbox.x0 - match);
                            if (dist < distanciaMax && dist < menorDistancia) {
                                menorDistancia = dist;
                                motivoDetectado = item.motivo;
                                confidenciaMotivo = Math.round(xWord.confidence);
                                console.log(`? Motivo detectado: "${item.motivo}" (confiança: ${confidenciaMotivo}%, distância: ${dist})`);
                            }
                        });
                    }
                });
            });
            
            dados.motivo = motivoDetectado;
            dados.confidence.motivo = confidenciaMotivo;
            
            console.log('✅ Extração finalizada:', dados);
            return dados;
        }
        */

        // Extrair Horários e motivo do texto OCR (funçãoO ANTIGA - MANTER COMO FALLBACK)
        function extrairDadosOCR(texto) {
            console.log('📄 Texto OCR completo:', texto);
            
            const dados = {
                ent1: null,
                sai1: null,
                ent2: null,
                sai2: null,
                ent3: null,
                sai3: null,
                ent4: null,
                sai4: null,
                ent5: null,
                sai5: null,
                motivo: null
            };
            
            // MELHORAR DETECÇÃO DE HorárioS
            // Procurar múltiplos padrões
            const horariosEncontrados = [];
            
            // Padrão 1: HH:MM ou HH MM (com separador)
            const regex1 = /\b(\d{1,2})\s*[:\s]\s*(\d{2})\b/g;
            let match;
            
            while ((match = regex1.exec(texto)) !== null) {
                let hora = parseInt(match[1]);
                let min = parseInt(match[2]);
                
                if (hora >= 0 && hora <= 23 && min >= 0 && min <= 59) {
                    horariosEncontrados.push({
                        hora: match[1].padStart(2, '0'),
                        min: match[2].padStart(2, '0'),
                        original: match[0],
                        posicao: match.index,
                        tipo: 'separado'
                    });
                }
            }
            
            // Padrão 2: HHMM (4 dígitos juntos) - NOVO!
            const regex2 = /\b(\d{4})\b/g;
            
            while ((match = regex2.exec(texto)) !== null) {
                const valor = match[1];
                const hora = parseInt(valor.substring(0, 2));
                const min = parseInt(valor.substring(2, 4));
                
                console.log(`ℹ Padrão2 encontrado: "${valor}" ? Hora=${hora}, Min=${min}`);
                
                // FILTROS DE validaçãoO
                // 1. Validar se pode ser Horário
                if (hora < 0 || hora > 23 || min < 0 || min > 59) {
                    console.log(`   ? Rejeitado: Horário inválido (hora ${hora}, min ${min})`);
                    continue;
                }
                
                // 2. Ignorar anos (2024, 2025, etc)
                if (parseInt(valor) >= 2000 && parseInt(valor) <= 2100) {
                    console.log(`   ? Rejeitado: parece ano (${valor})`);
                    continue;
                }
                
                // 3. Ignorar se vier depois de "Data:" ou "/" (contexto de data)
                const contextoAntes = texto.substring(Math.max(0, match.index - 20), match.index);
                if (/data:\s*\d+\/\d+\/$/i.test(contextoAntes)) {
                    console.log(`   ? Rejeitado: contexto de data (${contextoAntes})`);
                    continue;
                }
                if (/\/\d+\/$/i.test(contextoAntes)) {
                    console.log(`   ? Rejeitado: contexto de barra (${contextoAntes})`);
                    continue;
                }
                
                const horarioStr = `${hora.toString().padStart(2, '0')}:${min.toString().padStart(2, '0')}`;
                
                // não adicionar se já existe (evitar duplicata)
                const jaExiste = horariosEncontrados.find(h => `${h.hora}:${h.min}` === horarioStr);
                
                if (!jaExiste) {
                    console.log(`   ? Aceito: ${horarioStr}`);
                    horariosEncontrados.push({
                        hora: hora.toString().padStart(2, '0'),
                        min: min.toString().padStart(2, '0'),
                        original: match[0],
                        posicao: match.index,
                        tipo: '4digitos'
                    });
                } else {
                    console.log(`   ℹ Duplicado: ${horarioStr}`);
                }
            }
            
            // Ordenar por posiçãoo no texto
            horariosEncontrados.sort((a, b) => a.posicao - b.posicao);
            
            console.log('? Horários detectados:', horariosEncontrados);
            
            // Filtrar duplicatas por valor
            const horariosLimpos = [];
            horariosEncontrados.forEach(h => {
                const horarioStr = `${h.hora}:${h.min}`;
                if (!horariosLimpos.find(hl => hl === horarioStr)) {
                    horariosLimpos.push(horarioStr);
                }
            });
            
            console.log('? Horários únicos:', horariosLimpos);
            
            // Atribuir Horários detectados
            if (horariosLimpos.length >= 1) dados.ent1 = horariosLimpos[0];
            if (horariosLimpos.length >= 2) dados.sai1 = horariosLimpos[1];
            if (horariosLimpos.length >= 3) dados.ent2 = horariosLimpos[2];
            if (horariosLimpos.length >= 4) dados.sai2 = horariosLimpos[3];
            if (horariosLimpos.length >= 5) dados.ent3 = horariosLimpos[4];
            if (horariosLimpos.length >= 6) dados.sai3 = horariosLimpos[5];
            
            // DETECTAR MOTIVO com méltiplas estratégias
            const textoLower = texto.toLowerCase();
            
            // 1. Procurar por "X" ou marcaçães próximo ãs palavras-chave
            const distanciaMax = 100; // aumentado para captar melhor
            
            // Lista de palavras-chave para cada justificativa
            const justificativasMap = [
                { palavras: ['esquec', 'registr.*ponto'], motivo: 'Esqueceu de registrar o Ponto' },
                { palavras: ['falha.*app', 'app'], motivo: 'Falha no App' },
                { palavras: ['falta'], motivo: 'Falta' },
                { palavras: ['folga'], motivo: 'Folga' },
                { palavras: ['hora.*parada', 'parada'], motivo: 'Hora Parada' },
                { palavras: ['maquina.*defeito', 'méquina.*defeito', 'defeito'], motivo: 'Maquina Ponto com defeito' },
                { palavras: ['duplicidade', 'duplicado'], motivo: 'Registro em duplicidade' },
                { palavras: ['indevido'], motivo: 'Registro indevido' }
            ];
            
            // Procurar "X", checkboxes marcados, ou qualquer Sómbolo de marcação
            // Melhorado para captar mais variaçães
            const regexX = /\b[xX]\b|\\[xX\\]|\(\\s*[xX]\\s*\)|\[[xX]\]/g;
            const xMatches = [];
            let xMatch;
            while ((xMatch = regexX.exec(texto)) !== null) {
                xMatches.push(xMatch.index);
            }
            
            console.log('? Marcaçães "X" encontradas em:', xMatches);
            
            // Verificar qual opéão tem "X" mais próximo
            let motivoDetectado = null;
            let menorDistancia = Infinity;
            
            justificativasMap.forEach(item => {
                item.palavras.forEach(palavra => {
                    const regex = new RegExp(palavra, 'i');
                    const match = textoLower.search(regex);
                    
                    if (match !== -1) {
                        xMatches.forEach(xPos => {
                            const dist = Math.abs(xPos - match);
                            if (dist < distanciaMax && dist < menorDistancia) {
                                menorDistancia = dist;
                                motivoDetectado = item.motivo;
                                console.log(`? Motivo detectado: "${item.motivo}" (disténcia: ${dist} do "X")`);
                                console.log(`? Motivo detectado: "${item.motivo}" (disténcia: ${dist} do "X")`);
                            }
                        });
                    }
                });
            });
            
            dados.motivo = motivoDetectado;
            console.log('📋 Motivo detectado:', motivoDetectado);
            
            return dados;
        }
        
        // 📝 Mostrar resultado do OCR COM INDICADORES DE CONFIANÇA
        function mostrarResultadoOCR(dados) {
            // função auxiliar para cor do indicador baseado na confiança
            const getConfidenceColor = (confidence) => {
                if (confidence >= 80) return '#10b981'; // Verde
                if (confidence >= 60) return '#f59e0b'; // Amarelo
                return '#ef4444'; // Vermelho
            };
            
            const getConfidenceBadge = (confidence, label) => {
                if (!confidence || confidence === 0) return '';
                const color = getConfidenceColor(confidence);
                return `<span style="display: inline-block; margin-left: 8px; padding: 2px 8px; background: ${color}; color: white; border-radius: 12px; font-size: 10px; font-weight: 600;">${confidence}%</span>`;
            };
            
            // 📝 BUSCAR HorárioS já BATIDOS do FUNCIONÁRIO
            const horariosJaBatidos = {
                ent1: currentAnexoEmployee?.punches?.ent1 || currentAnexoEmployee?.ent1,
                sai1: currentAnexoEmployee?.punches?.sai1 || currentAnexoEmployee?.sai1,
                ent2: currentAnexoEmployee?.punches?.ent2 || currentAnexoEmployee?.ent2,
                sai2: currentAnexoEmployee?.punches?.sai2 || currentAnexoEmployee?.sai2,
                ent3: currentAnexoEmployee?.punches?.ent3 || currentAnexoEmployee?.ent3,
                sai3: currentAnexoEmployee?.punches?.sai3 || currentAnexoEmployee?.sai3
            };
            
            console.log('⏰ Horários já batidos:', horariosJaBatidos);
            
            // função para criar campo (bloqueado se já batido, editável se vazio)
            const criarCampo = (id, label, valorOCR, valorJaBatido, confidence) => {
                const jaBatido = valorJaBatido && valorJaBatido !== '--:--';
                const valor = jaBatido ? valorJaBatido : (valorOCR || '');
                const bloqueado = jaBatido ? 'disabled' : '';
                const corBorda = jaBatido ? '#94a3b8' : getConfidenceColor(confidence || 0);
                const bgColor = jaBatido ? '#f1f5f9' : 'white';
                const badge = jaBatido ? '<span style="display: inline-block; margin-left: 8px; padding: 2px 8px; background: #64748b; color: white; border-radius: 12px; font-size: 10px; font-weight: 600;">ℹ já BATIDO</span>' : getConfidenceBadge(confidence, label);
                
                return `
                    <div>
                        <label style="font-size: 12px; color: #065f46; font-weight: 500;">
                            ${label}: ${badge}
                        </label>
                        <input type="time" id="${id}" value="${valor}" ${bloqueado}
                               style="width: 100%; padding: 6px; border: 2px solid ${corBorda}; border-radius: 4px; background: ${bgColor}; cursor: ${jaBatido ? 'not-allowed' : 'text'};">
                    </div>
                `;
            };
            
            let html = `
                <div style="margin-bottom: 16px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    <div style="padding: 12px; background: ${dados.assinaturaFuncionario ? '#dbeafe' : '#fee2e2'}; border-left: 4px solid ${dados.assinaturaFuncionario ? '#3b82f6' : '#ef4444'}; border-radius: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;">${dados.assinaturaFuncionario ? '?' : '?'}</span>
                            <div>
                                <div style="font-weight: 600; color: ${dados.assinaturaFuncionario ? '#1e40af' : '#991b1b'}; font-size: 14px;">
                                    ℹ FUNCIONÁRIO
                                </div>
                                <div style="font-size: 11px; color: ${dados.assinaturaFuncionario ? '#1e40af' : '#b91c1c'}; margin-top: 2px;">
                                    ${dados.assinaturaFuncionario ? 'ASSINADO' : 'não ASSINADO'}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="padding: 12px; background: ${dados.assinaturaLider ? '#d1fae5' : '#fee2e2'}; border-left: 4px solid ${dados.assinaturaLider ? '#10b981' : '#ef4444'}; border-radius: 6px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-size: 24px;">${dados.assinaturaLider ? '?' : '?'}</span>
                            <div>
                                <div style="font-weight: 600; color: ${dados.assinaturaLider ? '#065f46' : '#991b1b'}; font-size: 14px;">
                                    ℹ Líder
                                </div>
                                <div style="font-size: 11px; color: ${dados.assinaturaLider ? '#047857' : '#b91c1c'}; margin-top: 2px;">
                                    ${dados.assinaturaLider ? 'ASSINADO' : 'não ASSINADO'}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Grid com Motivo e Justificativa Secullum lado a lado -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
                    <div>
                        <label style="display: block; font-weight: 600; color: #065f46; margin-bottom: 8px;">
                            ℹ Motivo: ${getConfidenceBadge(dados.confidence?.motivo, 'Motivo')}
                        </label>
                        <select id="ocrMotivo" style="width: 100%; padding: 8px; border: 2px solid ${getConfidenceColor(dados.confidence?.motivo || 0)}; border-radius: 6px; font-size: 14px;">
                            <option value="">-- Selecione --</option>
                            <option value="Esqueceu de registrar o Ponto" ${dados.motivo === 'Esqueceu de registrar o Ponto' ? 'selected' : ''}>Esqueceu de registrar o Ponto</option>
                            <option value="Falha no App" ${dados.motivo === 'Falha no App' ? 'selected' : ''}>Falha no App</option>
                            <option value="Falta" ${dados.motivo === 'Falta' ? 'selected' : ''}>Falta</option>
                            <option value="Folga" ${dados.motivo === 'Folga' ? 'selected' : ''}>Folga</option>
                            <option value="Hora Parada" ${dados.motivo === 'Hora Parada' ? 'selected' : ''}>Hora Parada</option>
                            <option value="Maquina Ponto com defeito" ${dados.motivo === 'Maquina Ponto com defeito' ? 'selected' : ''}>Maquina Ponto com defeito</option>
                            <option value="Registro em duplicidade" ${dados.motivo === 'Registro em duplicidade' ? 'selected' : ''}>Registro em duplicidade</option>
                            <option value="Registro indevido" ${dados.motivo === 'Registro indevido' ? 'selected' : ''}>Registro indevido</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; font-weight: 600; color: #065f46; margin-bottom: 8px;">📋 Justificativa Secullum</label>
                        <select id="selectJustificativaSecullum" onchange="autoPreencherBatidas(this.value)" style="width: 100%; padding: 8px; border: 2px solid rgba(148, 163, 184, 0.3); border-radius: 6px; font-size: 14px; background: rgba(15, 23, 42, 0.8); color: #e2e8f0; cursor: pointer;">
                            <option value="">Selecione...</option>
                        </select>
                    </div>
                </div>
                
                <div style="margin-bottom: 8px;">
                    <label style="display: block; font-weight: 600; color: #065f46; margin-bottom: 8px;">? Horários (corrija se necesSório):</label>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                    ${criarCampo('ocrEnt1', 'Entrada 1', dados.ent1, horariosJaBatidos.ent1, dados.confidence?.ent1)}
                    ${criarCampo('ocrSai1', 'SAÍda 1', dados.sai1, horariosJaBatidos.sai1, dados.confidence?.sai1)}
                    ${criarCampo('ocrEnt2', 'Entrada 2', dados.ent2, horariosJaBatidos.ent2, dados.confidence?.ent2)}
                    ${criarCampo('ocrSai2', 'SAÍda 2', dados.sai2, horariosJaBatidos.sai2, dados.confidence?.sai2)}
                    ${criarCampo('ocrEnt3', 'Entrada 3', dados.ent3, horariosJaBatidos.ent3, dados.confidence?.ent3)}
                    ${criarCampo('ocrSai3', 'SAÍda 3', dados.sai3, horariosJaBatidos.sai3, dados.confidence?.sai3)}
                </div>
                
                <div style="margin-top: 12px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 4px;">
                    <div style="font-size: 12px; color: #1e40af; line-height: 1.5;">
                        <strong>ℹ Indicadores:</strong><br>
                        <span style="color: #64748b;"></span> Cinza: Horário já batido (bloqueado)<br>
                        <span style="color: #10b981;">?</span> Verde (=80%): Alta confiança<br>
                        <span style="color: #f59e0b;">?</span> Amarelo (60-80%): média confiança - revisar<br>
                        <span style="color: #ef4444;">?</span> Vermelho (<60%): Baixa confiança - corrigir
                    </div>
                </div>
            `;
            
            document.getElementById('ocrResultContent').innerHTML = html;
            document.getElementById('ocrResult').style.display = 'block';
            
            // 📋 Popular dropdown de justificativas APÓS renderizar o HTML
            setTimeout(() => {
                populateJustificativasDropdowns();
            }, 50);
        }
        
        // Confirmar e enviar anexo
        async function confirmarAnexo() {
            if (!currentAnexoEmployee || !currentAnexoImage) {
                showAlert('Erro', 'Nenhuma imagem selecionada', 'error');
                return;
            }
            
            // 📝 VALIDAR ASSINATURAS ANTES DE ENVIAR - apenas aviso, não bloqueia
            if (currentOCRData && (currentOCRData.assinaturaFuncionario === false || currentOCRData.assinaturaLider === false)) {
                const faltantes = [];
                if (!currentOCRData.assinaturaFuncionario) faltantes.push('Funcionário');
                if (!currentOCRData.assinaturaLider) faltantes.push('Líder');
                
                console.log(`⚠️ Assinaturas faltando: ${faltantes.join(', ')} - prosseguindo mesmo assim`);
            }
            
            const btn = document.getElementById('btnConfirmarAnexo');
            btn.disabled = true;
            btn.textContent = 'Enviando...';
            
            try {
                // LER VALORES EDITADOS PELO Usuário
                const motivoEditado = document.getElementById('ocrMotivo')?.value || '';
                const ent1 = document.getElementById('ocrEnt1')?.value || '';
                const sai1 = document.getElementById('ocrSai1')?.value || '';
                const ent2 = document.getElementById('ocrEnt2')?.value || '';
                const sai2 = document.getElementById('ocrSai2')?.value || '';
                const ent3 = document.getElementById('ocrEnt3')?.value || '';
                const sai3 = document.getElementById('ocrSai3')?.value || '';
                
                // Atualizar currentOCRData com valores editados
                currentOCRData = {
                    motivo: motivoEditado,
                    ent1: ent1,
                    sai1: sai1,
                    ent2: ent2,
                    sai2: sai2,
                    ent3: ent3,
                    sai3: sai3
                };
                
                console.log('📊 Dados finais (editados pelo Usuário):', currentOCRData);
                
                // 📝 USAR SEMPRE A DATA DA TABELA, IGNORAR rawData.Data
                let dataFormatted = currentAnexoEmployee.date;
                
                console.log(`ℹ Data da TABELA (USANDO ESTA): ${currentAnexoEmployee.date}`);
                console.log(`ℹ Data da API rawData (IGNORANDO): ${currentAnexoEmployee.rawData?.Data}`);
                
                // Formato estranho da API: 28T00:00:00/10/2025 -> 2025-10-28
                const strangeMatch = dataFormatted.match(/^(\d{1,2})T\d{2}:\d{2}:\d{2}\/(\d{1,2})\/(\d{4})/);
                if (strangeMatch) {
                    const dia = strangeMatch[1].padStart(2, '0');
                    const mes = strangeMatch[2].padStart(2, '0');
                    const ano = strangeMatch[3];
                    dataFormatted = `${ano}-${mes}-${dia}`;
                    console.log(`? Formato estranho detectado, convertido para: ${dataFormatted}`);
                } else if (dataFormatted.includes('T')) {
                    // Formato ISO: 2025-10-28T00:00:00
                    dataFormatted = dataFormatted.split('T')[0];
                } else if (dataFormatted.includes('/')) {
                    // Formato BR: 28/10/2025 -> 2025-10-28
                    const parts = dataFormatted.split('/');
                    if (parts.length === 3) {
                        dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                        console.log(`ℹ Formato BR detectado, convertido para: ${dataFormatted}`);
                    }
                }
                
                console.log(`ℹ Data formatada final para envio: ${dataFormatted}`);
                
                // 📋 CAPTURAR JUSTIFICATIVA SECULLUM SELECIONADA
                const justificativaSecullum = document.getElementById('selectJustificativaSecullum')?.value || null;
                
                console.log('📋 Justificativa selecionada:', justificativaSecullum);
                
                // Preparar dados (usando CPF + DATA como chave ãnica)
                // 🏢 Obter nome da empresa da API_CONFIG (fonte mais confiável)
                const empresaId = currentAnexoEmployee.empresaId || currentAnexoEmployee.companyId;
                const empresaConfig = API_CONFIG.companies?.find(c => c.id == empresaId);
                const empresaNome = empresaConfig?.name || currentAnexoEmployee.city || currentAnexoEmployee.empresaNome || 'N/A';
                
                const payload = {
                    cpf: currentAnexoEmployee.cpf,  // ? CPF como identificador único
                    reg: currentAnexoEmployee.reg,
                    data: dataFormatted,
                    empresa_id: empresaId,
                    empresa_nome: empresaNome,
                    funcionario_nome: currentAnexoEmployee.name,
                    imageBase64: currentAnexoImage,
                    motivo: currentOCRData.motivo,
                    horarios: currentOCRData,
                    ocr_texto: JSON.stringify(currentOCRData),
                    perguntas_rh: JSON.stringify(currentAnexoEmployee.questions || {}),
                    created_by: window.CURRENT_USER_EMAIL || localStorage.getItem('secullum_username') || 'Sistema',
                    justificativa_secullum: justificativaSecullum,
                    justificativa_folha: null
                };
                
                console.log('📤 Enviando anexo com data:', payload.data);
                
                // Upload pro servidor (Azure Blob + SQL)
                // O servidor farçã UPDATE automaticamente se registro já existir (REG+DATA+EMPRESA_ID)
                const response = await fetch(`${API_BASE_URL}/api/anexos/upload`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    console.log('? Anexo salvo:', result);
                    
                    // BUSCAR a referçãncia correta do FUNCIONÁRIO em allEmployees
                    const dataFormatada = currentAnexoEmployee.rawData?.Data?.split('T')[0] || currentAnexoEmployee.date;
                    const empRef = allEmployees.find(e => 
                        e.reg === currentAnexoEmployee.reg && 
                        (e.rawData?.Data?.split('T')[0] === dataFormatada || e.date === dataFormatada)
                    );
                    
                    if (empRef) {
                        // Atualizar referçãncia com anexo
                        empRef.anexoUrl = result.blobUrl;
                        empRef.motivo = result.motivo || empRef.motivo;
                        empRef.attachments = [result.filename];
                        empRef.id = empRef.id || currentAnexoEmployee.id; // Manter ID
                        
                        // Salvar horários ORIGINAIS antes do OCR (para não reenviar os já batidos)
                        empRef._punchesOriginais = {
                            ent1: empRef.punches.ent1 || '',
                            sai1: empRef.punches.sai1 || '',
                            ent2: empRef.punches.ent2 || '',
                            sai2: empRef.punches.sai2 || '',
                            ent3: empRef.punches.ent3 || '',
                            sai3: empRef.punches.sai3 || '',
                        };
                        
                        // PREENCHER OS CAMPOS NA TABELA
                        empRef.punches.ent1 = currentOCRData.ent1 || empRef.punches.ent1;
                        empRef.punches.sai1 = currentOCRData.sai1 || empRef.punches.sai1;
                        empRef.punches.ent2 = currentOCRData.ent2 || empRef.punches.ent2;
                        empRef.punches.sai2 = currentOCRData.sai2 || empRef.punches.sai2;
                        empRef.punches.ent3 = currentOCRData.ent3 || empRef.punches.ent3;
                        empRef.punches.sai3 = currentOCRData.sai3 || empRef.punches.sai3;
                        
                        // não marcar como pendingOCR (vamos enviar direto)
                        empRef.ocrData = currentOCRData;
                        
                        console.log('✅ Campos preenchidos na tabela');
                        console.log('   Ent1:', empRef.punches.ent1, 'Sai1:', empRef.punches.sai1);
                        console.log('   Ent2:', empRef.punches.ent2, 'Sai2:', empRef.punches.sai2);
                        console.log('   Ent3:', empRef.punches.ent3, 'Sai3:', empRef.punches.sai3);
                        
                        // Re-renderizar tabela
                        renderTable();
                        
                        // FECHAR MODAL PRIMEIRO
                        fecharModalAnexo();
                        
                        // 📝 ENVIAR AUTOMATICAMENTE PARA SECULLUM (SEM CHECKBOX)
                        console.log('📤 Enviando automaticamente para Secullum...');
                        showLoading('Enviando para Secullum...');
                        
                        try {
                            await enviarParaSecullum(empRef, true); // true = autoEnvio sem popup
                            
                            hideLoading();
                            
                            // Montar string de Horários enviados (usar empRef.punches que ã garantido)
                            const horariosStr = [
                                empRef.punches?.ent1, 
                                empRef.punches?.sai1, 
                                empRef.punches?.ent2, 
                                empRef.punches?.sai2, 
                                empRef.punches?.ent3, 
                                empRef.punches?.sai3
                            ].filter(h => h).join(', ');
                            
                            showAlert(
                                'Sucesso!',
                                `? Anexo salvo e Horários enviados para Secullum!\n\n` +
                                `ℹ Arquivo: ${result.filename}\n` +
                                `ℹ Motivo: ${result.motivo || 'não detectado'}\n` +
                                `? Horários: ${horariosStr}`,
                                'success'
                            );
                            
                        } catch (err) {
                            hideLoading();
                            console.error('? Erro ao enviar para Secullum:', err);
                            showAlert('Erro', `Anexo salvo mas erro ao enviar para Secullum:\n${err.message}`, 'error');
                        }
                    } else {
                        throw new Error('FUNCIONÁRIO não encontrado em allEmployees');
                    }
                } else {
                    throw new Error(result.error || 'Erro desconhecido');
                }
                
            } catch (err) {
                console.error('? Erro ao enviar anexo:', err);
                showAlert('Erro', `Erro ao enviar anexo: ${err.message}`, 'error');
            } finally {
                // ? Sempre resetar botãoo (sucesso ou erro)
                btn.disabled = false;
                btn.textContent = 'Confirmar Anexo';
            }
        }
        
        // Enviar Horários OCR para Secullum (quando Usuário clica no checkbox verde)
        async function enviarParaSecullum(empRef, autoEnvio = false) {
            console.log(`ℹ Enviando Horários para Secullum: REG=${empRef.reg}, Data=${empRef.date}`);
            
            if (!empRef) {
                showAlert('Erro', 'Funcionário não encontrado!', 'error');
                return;
            }
            
            // Envio direto sem confirmação (autoEnvio sempre)
            
            showLoading('Enviando para Secullum...');
            
            try {
                let sucessos = 0;
                let erros = 0;
                let periodoEncerrado = false;
                
                // Se há inversões/movimentações pendentes, usar endpoint de TROCA
                if (empRef.pendingSwap || empRef.movedPunches) {
                    console.log('🔄 Enviando TROCA de horários para Secullum...');
                    
                    let numeroFolha = empRef.rawData?.Funcionario?.NumeroFolha || empRef.NumeroFolha;
                    
                    // Fallback: buscar NumeroFolha de outro registro do mesmo funcionário
                    if (!numeroFolha) {
                        const outroRegistro = allEmployees.find(e => e.reg === empRef.reg && e.rawData?.Funcionario?.NumeroFolha);
                        if (outroRegistro) {
                            numeroFolha = outroRegistro.rawData.Funcionario.NumeroFolha;
                            console.log(`ℹ NumeroFolha obtido de outro registro do mesmo funcionário`);
                        }
                    }
                    
                    if (!numeroFolha) {
                        throw new Error('NumeroFolha não encontrado!');
                    }
                    
                    // Pegar informações da troca (última movimentação)
                    const trocas = empRef.movedPunches || empRef.swappedPunches || [];
                    
                    if (trocas.length === 0) {
                        console.warn('⚠️ Nenhuma troca registrada, pulando envio');
                        hideLoading();
                        return;
                    }
                    
                    // Enviar cada troca individualmente
                    for (const troca of trocas) {
                        try {
                            // Mapear nome interno (ent1, sai1) para nome da API (Entrada1, Saida1)
                            const mapColuna = (punch) => {
                                const map = {
                                    'ent1': 'Entrada1', 'sai1': 'Saida1',
                                    'ent2': 'Entrada2', 'sai2': 'Saida2',
                                    'ent3': 'Entrada3', 'sai3': 'Saida3',
                                    'ent4': 'Entrada4', 'sai4': 'Saida4',
                                    'ent5': 'Entrada5', 'sai5': 'Saida5'
                                };
                                return map[punch] || punch;
                            };
                            
                            const colunaOrigem = mapColuna(troca.from || troca.punch1);
                            const colunaDestino = mapColuna(troca.to || troca.punch2);
                            
                            const payload = {
                                NumeroFolha: numeroFolha,
                                Data: empRef.rawData?.Data || empRef.date,
                                ColunaOrigem: colunaOrigem,
                                ColunaDestino: colunaDestino
                            };
                            
                            console.log(`🔄 Trocando ${colunaOrigem} ↔ ${colunaDestino}`);
                            console.log('📦 Payload:', payload);
                            
                            const apiResponse = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Troca`, {
                                method: 'POST',
                                headers: { 
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${API_CONFIG.token}`,
                                    'secullumidbancoselecionado': empRef.empresaId || empRef.companyId
                                },
                                body: JSON.stringify(payload)
                            });
                            
                            if (apiResponse.ok) {
                                sucessos++;
                                console.log(`✅ Troca realizada: ${colunaOrigem} ↔ ${colunaDestino}`);
                            } else {
                                erros++;
                                const errorText = await apiResponse.text();
                                console.error(`❌ Erro ao trocar: ${apiResponse.status} - ${errorText}`);
                            }
                            
                        } catch (err) {
                            erros++;
                            console.error(`❌ Erro ao enviar troca:`, err);
                        }
                    }
                    
                    // Limpar flags
                    empRef.swappedPunches = [];
                    empRef.pendingSwap = false;
                    
                } else {
                    // Envio normal (OCR)
                    console.log('🔍 Verificando Horários para envio...');
                    console.log('   empRef.ent1:', empRef.ent1);
                    console.log('   empRef.punches.ent1:', empRef.punches?.ent1);
                    console.log('   empRef.sai1:', empRef.sai1);
                    console.log('   empRef.punches.sai1:', empRef.punches?.sai1);
                    
                    const horariosParaEnviar = [
                        { coluna: 'Entrada1', hora: empRef.punches?.ent1 || empRef.ent1, slot: 'ent1', grupo: 1 },
                        { coluna: 'Saida1', hora: empRef.punches?.sai1 || empRef.sai1, slot: 'sai1', grupo: 1 },
                        { coluna: 'Entrada2', hora: empRef.punches?.ent2 || empRef.ent2, slot: 'ent2', grupo: 2 },
                        { coluna: 'Saida2', hora: empRef.punches?.sai2 || empRef.sai2, slot: 'sai2', grupo: 2 },
                        { coluna: 'Entrada3', hora: empRef.punches?.ent3 || empRef.ent3, slot: 'ent3', grupo: 3 },
                        { coluna: 'Saida3', hora: empRef.punches?.sai3 || empRef.sai3, slot: 'sai3', grupo: 3 }
                    ].filter(item => item.hora)
                     .filter(item => {
                        // Filtrar horários que JÁ ESTAVAM batidos antes do OCR (não reenviar)
                        const originais = empRef._punchesOriginais;
                        if (originais && originais[item.slot] && originais[item.slot] === item.hora) {
                            console.log(`   ⏭ Pulando ${item.coluna} (${item.hora}) - já batido no Secullum`);
                            return false;
                        }
                        return true;
                    });
                    
                    let funcionarioId = empRef.rawData?.FuncionarioId || empRef.dadosCompletos?.FuncionarioId;
                    let numeroFolha = empRef.rawData?.Funcionario?.NumeroFolha || empRef.NumeroFolha;
                    
                    // Fallback: buscar FuncionarioId/NumeroFolha de outro registro do mesmo funcionário
                    if (!funcionarioId || !numeroFolha) {
                        const outroRegistro = allEmployees.find(e => e.reg === empRef.reg && e.rawData?.FuncionarioId);
                        if (outroRegistro) {
                            if (!funcionarioId) funcionarioId = outroRegistro.rawData.FuncionarioId;
                            if (!numeroFolha) numeroFolha = outroRegistro.rawData?.Funcionario?.NumeroFolha || outroRegistro.NumeroFolha;
                            console.log(`ℹ FuncionarioId/NumeroFolha obtidos de outro registro do mesmo funcionário`);
                        }
                    }
                    
                    if (!funcionarioId) {
                        throw new Error('FuncionarioId não encontrado!');
                    }
                    
                    if (!numeroFolha) {
                        throw new Error('NumeroFolha não encontrado!');
                    }
                    
                    // 🔍 Detectar se são justificativas de texto ou horários
                    const isHorarioValido = (hora) => /^\d{1,2}:\d{2}$/.test(hora);
                    const justificativasTexto = horariosParaEnviar.filter(item => !isHorarioValido(item.hora));
                    const horariosNormais = horariosParaEnviar.filter(item => isHorarioValido(item.hora));
                    
                    // ⚡ ENVIO DE JUSTIFICATIVAS (FOLGA, FERIADO, etc) - Endpoint /Justificativa
                    if (justificativasTexto.length > 0) {
                        console.log('📋 Enviando justificativas de texto...');
                        
                        // Agrupar justificativas por grupo (Ent1+Sai1 = grupo 1)
                        const gruposProcessados = new Set();
                        
                        for (const item of justificativasTexto) {
                            if (gruposProcessados.has(item.grupo)) continue; // Já processou este grupo
                            
                            try {
                                const payload = {
                                    NumeroFolha: numeroFolha,
                                    Data: empRef.rawData?.Data || empRef.date,
                                    Grupo: item.grupo,
                                    Justificativa: item.hora.toUpperCase() // "FOLGA", "FERIADO", etc
                                };
                                
                                console.log(`📋 Enviando justificativa Grupo ${item.grupo}: ${item.hora}`);
                                
                                const apiResponse = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Justificativa`, {
                                    method: 'POST',
                                    headers: { 
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${API_CONFIG.token}`,
                                        'secullumidbancoselecionado': empRef.empresaId || empRef.companyId
                                    },
                                    body: JSON.stringify(payload)
                                });
                                
                                if (apiResponse.ok) {
                                    console.log(`✅ Justificativa Grupo ${item.grupo} enviada: ${item.hora}`);
                                    sucessos++;
                                    gruposProcessados.add(item.grupo);
                                } else {
                                    const errorText = await apiResponse.text();
                                    console.warn(`⚠️ Erro ao enviar justificativa Grupo ${item.grupo}: ${apiResponse.status} - ${errorText}`);
                                    erros++;
                                }
                                
                                await new Promise(resolve => setTimeout(resolve, 300));
                                
                            } catch (err) {
                                console.error(`❌ Erro ao enviar justificativa Grupo ${item.grupo}:`, err);
                                erros++;
                            }
                        }
                    }
                    
                    // ⚡ ENVIO SEQUENCIAL DE HORÁRIOS NORMAIS (HH:mm) - Endpoint /Manual
                    const results = [];
                    let tentativasRestantes = 3; // Retry até 3 vezes em caso de erro
                    
                    for (let i = 0; i < horariosNormais.length; i++) {
                        const item = horariosNormais[i];
                        let enviado = false;
                        let tentativa = 0;
                        
                        // 📊 Atualizar progresso visual
                        showLoading(`⚡ Enviando ${i + 1}/${horariosNormais.length}: ${item.coluna} (${item.hora})...`);
                        
                        while (!enviado && tentativa < tentativasRestantes) {
                            tentativa++;
                            
                            try {
                                const payload = {
                                    FuncionarioId: funcionarioId,
                                    NumeroFolha: numeroFolha,
                                    Data: empRef.rawData?.Data || empRef.date,
                                    Coluna: item.coluna,
                                    Hora: item.hora,
                                    Motivo: empRef.motivo || 'Justificativa anexada via OCR',
                                    created_by: window.CURRENT_USER_EMAIL || localStorage.getItem('secullum_username') || 'Sistema'
                                };
                                
                                const apiResponse = await fetch(`${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`, {
                                    method: 'POST',
                                    headers: { 
                                        'Content-Type': 'application/json',
                                        'Authorization': `Bearer ${API_CONFIG.token}`,
                                        'secullumidbancoselecionado': empRef.empresaId || empRef.companyId
                                    },
                                    body: JSON.stringify(payload)
                                });
                                
                                if (apiResponse.ok) {
                                    console.log(`✅ ${item.coluna} enviada: ${item.hora}`);
                                    results.push({ success: true, coluna: item.coluna });
                                    enviado = true;
                                } else if (apiResponse.status === 429) {
                                    // 🚨 RATE LIMIT - Aguardar mais tempo
                                    const waitTime = tentativa * 2000; // 2s, 4s, 6s...
                                    console.warn(`⏳ Rate limit detectado (429). Aguardando ${waitTime/1000}s antes de tentar novamente...`);
                                    await new Promise(resolve => setTimeout(resolve, waitTime));
                                    // Não marca como enviado, vai tentar novamente
                                } else {
                                    const errorText = await apiResponse.text();
                                    console.warn(`⚠️ Erro ao enviar ${item.coluna}: ${apiResponse.status} - ${errorText}`);
                                    results.push({ 
                                        success: false, 
                                        coluna: item.coluna, 
                                        error: errorText,
                                        periodoEncerrado: errorText.includes('Período encerrado') || errorText.includes('Período fechado')
                                    });
                                    enviado = true; // Não retenta em outros erros (não é rate limit)
                                }
                                
                            } catch (err) {
                                console.error(`❌ Erro ao enviar ${item.coluna} (tentativa ${tentativa}/${tentativasRestantes}):`, err);
                                
                                if (tentativa >= tentativasRestantes) {
                                    results.push({ success: false, coluna: item.coluna, error: err.message });
                                    enviado = true;
                                } else {
                                    // Aguardar antes de retry
                                    await new Promise(resolve => setTimeout(resolve, 1000 * tentativa));
                                }
                            }
                        }
                        
                        // ⏱️ Delay entre requisições (aumentado para evitar sobrecarga)
                        if (i < horariosNormais.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500)); // 500ms
                        }
                    }
                    
                    sucessos = results.filter(r => r.success).length;
                    erros = results.filter(r => !r.success).length;
                    periodoEncerrado = results.some(r => r.periodoEncerrado);
                    
                    // ✅ INVALIDAÇÃO CIRÚRGICA: Se teve sucesso, recarregar funcionário
                    if (sucessos > 0) {
                        console.log('⚡ Invalidando cache após envio...');
                        await invalidateSingleEmployee(empRef.reg, empRef.date, empRef.empresaId || empRef.companyId);
                    }
                    
                    // Remover flag pendingOCR
                    empRef.pendingOCR = false;
                }
                
                hideLoading();
                
                // Recarregar dados
                await searchPeriod();
                
                let titulo = sucessos > 0 && erros === 0 ? '✅ Envio Concluído' : erros > 0 ? '⚠️ Envio Parcial' : '❌ Erro no Envio';
                let tipo = sucessos > 0 && erros === 0 ? 'success' : erros > 0 ? 'warning' : 'error';
                let mensagem = `✅ ${sucessos} horário(s) enviado(s)\n❌ ${erros} erro(s)`;
                
                if (periodoEncerrado) {
                    mensagem += `\n\n⚠️ ATENÇÃO: Período encerrado!\nEntre em contato com o RH.`;
                    tipo = 'warning';
                }
                
                showAlert(titulo, mensagem, tipo);
                
            } catch (err) {
                hideLoading();
                console.error('? Erro ao enviar para Secullum:', err);
                showAlert('Erro', `Erro: ${err.message}`, 'error');
            }
        }
        
        // Remover anexo - remoção direta sem confirmação
        async function removeAttachment(reg, date) {
            showLoading('Removendo anexo...');
            
            try {
                const employee = allEmployees.find(emp => emp.reg === reg);
                if (!employee) return;
                
                // Buscar ID do anexo no SQL
                const response = await fetch(`${API_BASE_URL}/api/anexos/${reg}/${employee.rawData?.Data || date}`, {
                    headers: getAuthHeaders()
                });
                const anexo = await response.json();
                
                if (!anexo || anexo.error) {
                    throw new Error('Anexo não encontrado no servidor');
                }
                
                // Deletar do servidor
                const deleteResponse = await fetch(`${API_BASE_URL}/api/anexos/${anexo.id}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });
                
                const result = await deleteResponse.json();
                
                if (result.success) {
                    employee.anexoUrl = null;
                    employee.attachments = [];
                    employee.motivo = '';
                    
                    hideLoading();
                    renderTable();
                    showAlert('Sucesso', 'Anexo removido com sucesso!', 'success');
                } else {
                    throw new Error(result.error || 'Erro ao deletar');
                }
                
            } catch (err) {
                hideLoading();
                console.error('? Erro ao remover anexo:', err);
                showAlert('Erro', `Erro ao remover anexo: ${err.message}`, 'error');
            }
        }

        // Remover anexo (verSóo antiga - manter compatibilidade)
        function simulateOCR(filename) {
            return { time: '--:--', reason: 'Arquivo: ' + filename };
        }

        // Gerar formulério para um empregado
        // Gerar slots de Horário SEMPRE com 4 batidas (2 entradas + 2 SAÍdas)
        function generateTimeSlots(punches, questions = {}) {
            let html = '';
            
            // 🔧 CORREÇÃO: Manter ordem EXATA dos slots, mostrando vazios no lugar certo
            const todosSlots = [
                { time: punches.ent1, type: 'ent1', label: 'Entrada 1' },
                { time: punches.sai1, type: 'sai1', label: 'Saída 1' },
                { time: punches.ent2, type: 'ent2', label: 'Entrada 2' },
                { time: punches.sai2, type: 'sai2', label: 'Saída 2' },
                { time: punches.ent3, type: 'ent3', label: 'Entrada 3' },
                { time: punches.sai3, type: 'sai3', label: 'Saída 3' },
                { time: punches.ent4, type: 'ent4', label: 'Entrada 4' },
                { time: punches.sai4, type: 'sai4', label: 'Saída 4' },
                { time: punches.ent5, type: 'ent5', label: 'Entrada 5' },
                { time: punches.sai5, type: 'sai5', label: 'Saída 5' }
            ];
            
            // Encontrar até onde tem batidas (último slot preenchido)
            let ultimoSlotPreenchido = -1;
            for (let i = todosSlots.length - 1; i >= 0; i--) {
                if (todosSlots[i].time && todosSlots[i].time !== '--:--' && todosSlots[i].time !== '') {
                    ultimoSlotPreenchido = i;
                    break;
                }
            }
            
            // Se não tem nenhuma batida, mostrar só 4 slots vazios
            if (ultimoSlotPreenchido === -1) {
                for (let i = 0; i < 4; i++) {
                    html += generateTimeSlot(null, null, null);
                }
                return html;
            }
            
            // Mostrar todos os slots até o último preenchido + garantir mínimo de 4
            const totalSlots = Math.max(ultimoSlotPreenchido + 1, 4);
            
            for (let i = 0; i < totalSlots; i++) {
                const slot = todosSlots[i];
                const time = (slot.time && slot.time !== '--:--' && slot.time !== '') ? slot.time : null;
                const question = questions[slot.type];
                html += generateTimeSlot(time, slot.label, question);
            }
            
            return html;
        }

        function generateForm(emp, index, total) {
            return `
                <div class="form-page">
                    <div class="form-border">
                        <div class="form-header">
                            <div class="form-logo">
                                <img src="larsillogo.png" alt="LARSIL" style="height: 50px; width: auto;">
                                <div class="logo-text">LARSIL</div>
                            </div>
                            <div class="form-title">PONTO MANUAL COMPLEMENTAR AO PONTO ELETRÔNICO</div>
                        </div>
                        
                        <div class="form-orientation">
                            <strong>Orientação:</strong> Preencha somente os Horários que não conseguiu bater e marque a justificativa
                        </div>
                        
                        <div class="form-employee-data">
                            <div class="form-row">
                                <div class="form-field">
                                    <span class="form-field-label">Nome:</span>
                                    <span class="form-field-value" style="font-size: 18px;">${emp.name}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Cidade:</span>
                                    <span class="form-field-value">${emp.city}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Data:</span>
                                    <span class="form-field-value">${emp.date} (${emp.day})</span>
                                </div>
                            </div>
                            <div class="form-row-2">
                                <div class="form-field">
                                    <span class="form-field-label">REG:</span>
                                    <span class="form-field-value">${emp.reg}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">Projeto:</span>
                                    <span class="form-field-value">${emp.projeto || 'N/A'}</span>
                                </div>
                                <div class="form-field">
                                    <span class="form-field-label">ID IMP:</span>
                                    <span class="form-field-value">${index}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="section-header">Horários (preencher somente os que faltaram)</div>
                        
                        <div class="form-times">
                            <div class="times-grid">
                                ${generateTimeSlots(emp.punches, emp.questions || {})}
                            </div>
                        </div>
                        
                        <div class="section-header">JUSTIFICATIVA (marque o motivo)</div>
                        
                        <div class="form-justification">
                            <div class="justification-grid" style="grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Esqueceu de registrar o Ponto</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Falha no App</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Falta</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Folga</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Hora Parada</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Maquina Ponto com defeito</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Registro em duplicidade</label>
                                </div>
                                <div class="checkbox-item">
                                    <input type="radio" name="motivo-${emp.reg}" style="width: 18px; height: 18px; min-width: 18px; min-height: 18px;">
                                    <label>Registro indevido</label>
                                </div>
                            </div>
                        </div>
                        
                        <div class="form-signatures">
                            <div class="signature-box left">
                                <div class="signature-space"></div>
                                <div class="signature-line">
                                    <div class="signature-name">${emp.name}</div>
                                    <div class="signature-label">Assinatura do FUNCIONÁRIO</div>
                                </div>
                            </div>
                            <div class="signature-box right">
                                ${useDigitalSignature ? `
                                    <div class="digital-signature">Fabio Oliveira</div>
                                    <div class="signature-line">
                                        <div class="signature-name">FABIO OLIVEIRA</div>
                                        <div class="signature-label">Assinatura digital do Líder</div>
                                    </div>
                                ` : `
                                    <div class="signature-space"></div>
                                    <div class="signature-line">
                                        <div class="signature-name">${emp.nomeLider || 'Líder não INFORMADO'}</div>
                                        <div class="signature-label">Assinatura do Líder</div>
                                    </div>
                                `}
                            </div>
                        </div>
                    </div>
                    <div class="form-footer">SECULLUM ã 4573.1197</div>
                </div>
            `;
        }

        function generateTimeSlot(time, label = null, question = null) {
            if (time) {
                return `
                    <div class="time-slot" style="position: relative;">
                        ${question ? `
                            <div style="position: absolute; top: -8px; left: 0; right: 0; background: linear-gradient(135deg, #fb923c 0%, #f97316 100%); padding: 4px 6px; border-radius: 6px 6px 0 0; font-size: 9px; font-weight: 600; text-align: left; box-shadow: 0 2px 4px rgba(251, 146, 60, 0.3); color: #1f2937;">
                                <span style="font-weight: 700;">RH:</span> ${question}
                            </div>
                        ` : ''}
                        <div class="time-value present" style="${question ? 'margin-top: 12px;' : ''}">${time}</div>
                        <div class="time-status batido">BATIDO</div>
                        <div style="margin-top: 3px; font-size: 10px; display: flex; align-items: center;">
                            <input type="checkbox" id="anular_${time.replace(':', '')}" style="margin-right: 5px; width: 14px; height: 14px;">
                            <label for="anular_${time.replace(':', '')}" style="margin: 0; font-weight: normal;">ANULAR BATIDA</label>
                        </div>
                    </div>
                `;
            } else {
                return `
                    <div class="time-slot">
                        <div style="font-weight: 900; font-size: 14px; color: #000; margin-bottom: 8px; text-align: center; letter-spacing: 1px;">
                            ${label || 'Horário'}
                        </div>
                        <div class="time-value missing">__:__</div>
                    </div>
                `;
            }
        }

        // Event Listeners
        document.getElementById('btnFilter').addEventListener('click', () => {
            showOnlyInconsistencies = !showOnlyInconsistencies;
            const btn = document.getElementById('btnFilter');
            const text = document.getElementById('filterText');
            
            if (showOnlyInconsistencies) {
                btn.classList.add('active');
                text.textContent = 'Mostrando Só Inconsistências';
            } else {
                btn.classList.remove('active');
                text.textContent = 'Mostrar Só Inconsistências';
            }
            
            renderTable();
        });

        // ==========================================
        // SISTEMA DE PERGUNTAS
        // ==========================================
        let currentQuestionContext = null;

        // 📝 CORREçããO: Salvar perguntas no banco de dados (com merge de dados existentes)
        async function saveQuestionsToDB(employee, dateContext) {
            try {
                let dataFormatted = employee.anexoDate || dateContext;
                if (dataFormatted.includes('/')) {
                    const parts = dataFormatted.split('/');
                    dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                } else if (dataFormatted.includes('T')) {
                    dataFormatted = dataFormatted.split('T')[0];
                }
                
                console.log(`ℹ Salvando perguntas: ${employee.name} (${dataFormatted})`);
                
                // 📝 1. BUSCAR dados existentes primeiro
                let existingData = {};
                try {
                    const fetchResponse = await fetch(
                        `${API_BASE_URL}/api/anexos/${dataFormatted}/${employee.empresaId || employee.rawData?.Empresa || 0}`,
                        { headers: getAuthHeaders() }
                    );
                    
                    if (fetchResponse.ok) {
                        const anexos = await fetchResponse.json();
                        const anexoExistente = anexos.find(a => 
                            a.cpf?.replace(/\D/g, '') === employee.cpf?.replace(/\D/g, '')
                        );
                        if (anexoExistente?.perguntas_rh) {
                            existingData = JSON.parse(anexoExistente.perguntas_rh);
                            console.log(`ℹ Dados existentes:`, existingData);
                        }
                    }
                } catch (err) {
                    console.warn('⚠️ não foi posSóvel buscar dados existentes');
                }
                
                // 📝 2. MESCLAR dados antigos + novos
                const mergedData = {
                    ...existingData,
                    ...employee.questions,
                    ...employee.approved
                };
                
                console.log(`ℹ Dados mesclados a salvar:`, mergedData);
                
                // 📝 3. SALVAR
                // 🏢 Obter nome da empresa da API_CONFIG
                const empresaIdQ = employee.empresaId || employee.rawData?.Empresa || 0;
                const empresaConfigQ = API_CONFIG.companies?.find(c => c.id == empresaIdQ);
                const empresaNomeQ = empresaConfigQ?.name || employee.city || employee.rawData?.['Empresa Nome'] || 'N/A';
                
                const response = await fetch(
                    `${API_BASE_URL}/api/anexos/${employee.cpf}/${dataFormatted}/questions`,
                    {
                        method: 'PUT',
                        headers: getAuthHeaders(),
                        body: JSON.stringify({
                            perguntas_rh: JSON.stringify(mergedData),
                            reg: employee.reg,
                            empresa_id: empresaIdQ,
                            empresa_nome: empresaNomeQ,
                            funcionario_nome: employee.name || 'N/A',
                            created_by: window.CURRENT_USER_EMAIL || localStorage.getItem('secullum_username') || 'Sistema'
                        })
                    }
                );
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                console.log('? Perguntas salvas com sucesso');
                
            } catch (err) {
                console.error('? Erro ao salvar perguntas:', err);
                showAlert('Erro', `não foi posSóvel salvar: ${err.message}`, 'error');
            }
        }

        // Salvar aprovação de Horário trocado no banco
        async function saveApprovalToDB(employee, dateContext, punchType, approvalComment) {
            try {
                // Mesma légica de formatação de data
                let dataFormatted = null;
                
                if (employee.anexoDate) {
                    dataFormatted = employee.anexoDate;
                } else if (dateContext) {
                    if (dateContext.includes('/')) {
                        const parts = dateContext.split('/');
                        dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                    } else {
                        dataFormatted = dateContext.split('T')[0];
                    }
                } else {
                    dataFormatted = employee.rawData?.Data 
                        ? employee.rawData.Data.split('T')[0] 
                        : employee.date.split('T')[0];
                }
                
                console.log(`? Salvando aprovação: ${employee.name} (CPF: ${employee.cpf}, Data: ${dataFormatted}, ${punchType})`);
                
                // 📝 BUSCAR DADOS EXISTENTES DO BANCO PRIMEIRO
                let existingData = {};
                try {
                    const fetchResponse = await fetch(`${API_BASE_URL}/api/anexos/${dataFormatted}/${employee.rawData?.Empresa || 0}`, {
                        headers: getAuthHeaders()
                    });
                    if (fetchResponse.ok) {
                        const anexos = await fetchResponse.json();
                        const anexoExistente = anexos.find(a => 
                            a.cpf?.replace(/\D/g, '') === employee.cpf?.replace(/\D/g, '')
                        );
                        if (anexoExistente && anexoExistente.perguntas_rh) {
                            existingData = JSON.parse(anexoExistente.perguntas_rh);
                            console.log(`ℹ Dados existentes encontrados:`, existingData);
                        }
                    }
                } catch (err) {
                    console.warn(`ℹ não foi posSóvel buscar dados existentes:`, err);
                }
                
                // Mesclar TUDO: dados existentes + questions atuais + nova aprovação
                const approvedKey = `${punchType}_approved`;
                const mergedData = {
                    ...existingData,           // 1. Dados que já estavam no banco
                    ...employee.questions,     // 2. Perguntas atuais do objeto
                    ...employee.approved,      // 3. Aprovações atuais do objeto
                    [approvedKey]: approvalComment,  // 4. Nova aprovação
                    ordem_horarios: true       // 5. ✅ Marcar que horários invertidos foram aprovados
                };
                
                console.log(`ℹ Dados a salvar (mesclados):`, mergedData);
                
                const response = await fetch(`${API_BASE_URL}/api/anexos/${employee.cpf}/${dataFormatted}/questions`, {
                    method: 'PUT',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({
                        perguntas_rh: JSON.stringify(mergedData),
                        reg: employee.reg,
                        empresa_id: employee.rawData?.Empresa || 0,
                        empresa_nome: employee.rawData?.['Empresa Nome'] || 'N/A',
                        funcionario_nome: employee.name || 'N/A'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                console.log(`? Aprovação salva:`, result);
                
                // ✅ RECARREGAR DADOS para atualizar aprovações
                console.log('🔄 Recarregando dados...');
                await carregarDadosCompletos();
                
                showAlert('Sucesso', `Horário ${punchType} aprovado para ${employee.name}!`, 'success');
                
            } catch (err) {
                console.error('? Erro ao salvar aprovação:', err);
                showAlert('Erro', `não foi posSóvel salvar a aprovação: ${err.message}`, 'error');
            }
        }

        function askQuestion(event, reg, date, punchType, name) {
            console.log('🎯 askQuestion CHAMADA:', { reg, date, punchType, name });
            event.stopPropagation(); // Evitar duplo clique na célula
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                console.error('❌ Funcionário não encontrado em askQuestion');
                return;
            }

            console.log('✅ Funcionário encontrado:', employee.name);

            const punchTime = employee.punches[punchType] || '--:--';
            const punchLabel = {
                'ent1': 'Entrada 1',
                'sai1': 'SAÍda 1',
                'ent2': 'Entrada 2',
                'sai2': 'SAÍda 2',
                'ent3': 'Entrada 3',
                'sai3': 'SAÍda 3',
                'ent4': 'Entrada 4',
                'sai4': 'SAÍda 4',
                'ent5': 'Entrada 5',
                'sai5': 'SAÍda 5'
            }[punchType];

            console.log('📝 Preparando modal:', { punchLabel, punchTime });

            // Armazenar contexto
            currentQuestionContext = { reg, date, punchType };

            // Atualizar modal
            const contextEl = document.getElementById('questionContext');
            const inputEl = document.getElementById('questionInput');
            const modalEl = document.getElementById('questionModal');
            
            console.log('🔍 Elementos do modal:', { 
                contextEl: !!contextEl, 
                inputEl: !!inputEl, 
                modalEl: !!modalEl 
            });
            
            if (!modalEl) {
                console.error('❌ Modal questionModal não encontrado no DOM!');
                return;
            }
            
            contextEl.textContent = `${name} - ${punchLabel}: ${punchTime} (${date})`;
            
            // Limpar input anterior
            inputEl.value = employee.questions?.[punchType] || '';

            console.log('🎬 Adicionando classe active ao modal');
            // Mostrar modal
            modalEl.classList.add('active');
            
            console.log('✅ Modal deve estar visível agora. Classes:', modalEl.className);
            
            inputEl.focus();
        }

        // botãoo OK do modal
        document.getElementById('questionOkBtn').addEventListener('click', async () => {
            const question = document.getElementById('questionInput').value.trim();
            
            if (!question) {
                const msgType = currentQuestionContext?.isApproval ? 'motivo da aprovação' : 'pergunta';
                showAlert('Atenãoo', `Digite ${msgType} antes de confirmar!`, 'warning');
                return;
            }

            if (currentQuestionContext) {
                const { reg, date, punchType, isApproval } = currentQuestionContext;
                
                console.log(`ℹ Buscando FUNCIONÁRIO: REG=${reg}, Data=${date}`);
                
                // 📝 Buscar FUNCIONÁRIO pela DATA E REG (não importa se tem anexo ou não)
                // Se tiver anexo, vai salvar. Se não tiver, vai avisar.
                let employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                
                if (!employee) {
                    console.warn(`ℹ FUNCIONÁRIO não encontrado: REG=${reg}, Data=${date}`);
                    showAlert('Erro', 'FUNCIONÁRIO não encontrado para esta data.', 'error');
                    return;
                }
                
                console.log(`? FUNCIONÁRIO encontrado: ${employee.name} - Data: ${employee.date} - Anexo: ${employee.anexoUrl ? 'SIM' : 'não'}`);
                
                if (employee) {
                    if (isApproval) {
                        // ? APROVaçãO DE Horário TROCADO
                        if (!employee.approved) {
                            employee.approved = {};
                        }
                        employee.approved[punchType] = question;
                        console.log(`? Horário aprovado: ${employee.name} - ${punchType} - "${question}"`);
                        
                        // Salvar aprovação no banco (aguardar para atualizar tabela depois)
                        await saveApprovalToDB(employee, date, punchType, question);
                    } else {
                        // ? PERGUNTA NORMAL DO RH
                        if (!employee.questions) {
                            employee.questions = {};
                        }
                        employee.questions[punchType] = question;
                        console.log(`? Pergunta adicionada: ${employee.name} - ${punchType} - "${question}"`);
                        
                        // Salvar pergunta no banco
                        await saveQuestionsToDB(employee, date);
                    }
                    
                    // Fechar modal
                    document.getElementById('questionModal').classList.remove('active');
                    
                    // Atualizar tabela (agora com dados salvos)
                    renderTable();
                }
            }
        });

        // botãoo Cancelar do modal
        document.getElementById('questionCancelBtn').addEventListener('click', () => {
            document.getElementById('questionModal').classList.remove('active');
        });

        // Fechar modal ao clicar fora
        document.getElementById('questionModal').addEventListener('click', (e) => {
            if (e.target.id === 'questionModal') {
                document.getElementById('questionModal').classList.remove('active');
            }
        });

        // 🗑️ DELETAR PERGUNTA DO RH - execução direta
        async function deleteQuestion(event, reg, date, punchType) {
            event.stopPropagation();
            
            showLoading('🗑️ Excluindo pergunta...');
            
            try {
                const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                if (!employee) {
                    throw new Error('Funcionário não encontrado');
                }
                
                // 🔧 NORMALIZAR DATA: Remover timestamp e converter para YYYY-MM-DD
                let dataNormalizada = employee.rawData?.Data || date;
                if (dataNormalizada.includes('T')) {
                    dataNormalizada = dataNormalizada.split('T')[0];
                }
                // Se for formato brasileiro DD/MM/YYYY, converter
                if (dataNormalizada.includes('/')) {
                    const [dia, mes, ano] = dataNormalizada.split('/');
                    dataNormalizada = `${ano}-${mes}-${dia}`;
                }
                
                console.log('🗑️ Excluindo pergunta:', { reg, dataNormalizada, punchType });
                
                // Remover do objeto local
                if (employee.questions && employee.questions[punchType]) {
                    delete employee.questions[punchType];
                }
                
                // Buscar perguntas_rh atual do banco de dados
                let perguntasRH = {};
                const anexoAtual = await fetch(`${API_BASE_URL}/api/anexos/${reg}/${dataNormalizada}`, {
                    headers: getAuthHeaders()
                });
                if (anexoAtual.ok) {
                    const data = await anexoAtual.json();
                    if (data.perguntas_rh) {
                        try {
                            perguntasRH = JSON.parse(data.perguntas_rh);
                        } catch (e) {
                            perguntasRH = {};
                        }
                    }
                }
                
                // Remover a pergunta específica
                delete perguntasRH[punchType];
                
                // Atualizar no banco usando a rota correta: /api/anexos/:cpf/:data/questions
                // 🔧 Usar CPF do funcionário (não REG) e data normalizada
                const cpf = employee.cpf || employee.rawData?.CPF || reg;
                // 🏢 Obter nome da empresa da API_CONFIG
                const empresaIdDel = employee.empresaId || employee.rawData?.EmpresaId || 0;
                const empresaConfigDel = API_CONFIG.companies?.find(c => c.id == empresaIdDel);
                const empresaNomeDel = empresaConfigDel?.name || employee.companyName || employee.rawData?.EmpresaNome || 'N/A';
                
                const updateResponse = await fetch(`${API_BASE_URL}/api/anexos/${cpf}/${dataNormalizada}/questions`, {
                    method: 'PUT',
                    headers: {
                        ...getAuthHeaders(),
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        perguntas_rh: JSON.stringify(perguntasRH),
                        reg: reg,
                        empresa_id: empresaIdDel,
                        empresa_nome: empresaNomeDel,
                        funcionario_nome: employee.name || 'N/A',
                        created_by: window.CURRENT_USER_EMAIL || localStorage.getItem('secullum_username') || 'Sistema'
                    })
                });
                
                if (!updateResponse.ok) {
                    const errorData = await updateResponse.json().catch(() => ({}));
                    throw new Error(errorData.error || 'Erro ao atualizar banco de dados');
                }
                
                hideLoading();
                showAlert('✅ Sucesso', 'Pergunta excluída com sucesso!', 'success');
                renderTable();
                
            } catch (error) {
                hideLoading();
                console.error('❌ Erro ao deletar pergunta:', error);
                showAlert('❌ Erro', `Erro ao excluir pergunta:\n${error.message}`, 'error');
            }
        }

        // ==========================================
        // APROVaçãO DE HorárioS TROCADOS
        // ==========================================
        function approveSwappedTime(event, reg, date, punchType, name) {
            event.stopPropagation();
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) return;

            const punchTime = employee.punches[punchType] || '--:--';
            const punchLabel = {
                'ent1': 'Entrada 1',
                'sai1': 'SAÍda 1',
                'ent2': 'Entrada 2',
                'sai2': 'SAÍda 2',
                'ent3': 'Entrada 3',
                'sai3': 'SAÍda 3',
                'ent4': 'Entrada 4',
                'sai4': 'SAÍda 4',
                'ent5': 'Entrada 5',
                'sai5': 'SAÍda 5'
            }[punchType];

            // Armazenar contexto
            currentQuestionContext = { reg, date, punchType, isApproval: true };

            // Atualizar modal com mensagem de aprovação
            document.getElementById('questionContext').textContent = 
                `✅ APROVAR Horário TROCADO\n${name} - ${punchLabel}: ${punchTime} (${date})`;
            
            // Limpar input
            document.getElementById('questionInput').value = '';
            document.getElementById('questionInput').placeholder = 'Digite o motivo da aprovação (ex: "Troca autorizada com colega")';

            // Mostrar modal
            document.getElementById('questionModal').classList.add('active');
            document.getElementById('questionInput').focus();
        }

        // Variável global para rastrear célula selecionada
        let selectedCell = null;

        // ============================================
        // TAREFA 7: MOVIMENTAÇÃO LIVRE DE HORÁRIOS
        // Sistema de drag-and-drop para mover horários livremente
        // ============================================
        let draggedCell = null;
        let draggedData = null;
        let sendToSecullumTimer = null; // Timer para debounce de 2s

        // Configurar drag-and-drop nas células de horário
        function setupDragAndDrop() {
            document.querySelectorAll('.punch-cell').forEach(cell => {
                // Permitir arrastar se tiver horário
                const reg = cell.dataset.reg;
                const date = cell.dataset.date;
                const punch = cell.dataset.punch;
                const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                
                if (employee && employee.punches[punch] && employee.punches[punch] !== '--:--') {
                    cell.draggable = true;
                    cell.style.cursor = 'grab';
                } else {
                    cell.draggable = false;
                }

                // Evento: COMEÇOU A ARRASTAR
                cell.addEventListener('dragstart', (e) => {
                    const punch = cell.dataset.punch;
                    const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
                    
                    if (!employee || !employee.punches[punch] || employee.punches[punch] === '--:--') {
                        e.preventDefault();
                        return;
                    }

                    draggedCell = cell;
                    draggedData = {
                        reg: cell.dataset.reg,
                        date: cell.dataset.date,
                        punch: cell.dataset.punch,
                        name: cell.dataset.name,
                        time: employee.punches[punch]
                    };

                    cell.style.opacity = '0.5';
                    cell.style.cursor = 'grabbing';
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', punch);
                });

                // Evento: TERMINOU DE ARRASTAR
                cell.addEventListener('dragend', (e) => {
                    if (draggedCell) {
                        draggedCell.style.opacity = '1';
                        draggedCell.style.cursor = 'grab';
                    }
                    draggedCell = null;
                    draggedData = null;
                    
                    // Remover destaque de todas as células
                    document.querySelectorAll('.punch-cell').forEach(c => {
                        c.classList.remove('drag-over');
                    });
                });

                // Evento: PASSOU POR CIMA (arrastrando)
                cell.addEventListener('dragover', (e) => {
                    e.preventDefault(); // Permitir drop
                    
                    // Verificar se é da mesma linha
                    if (draggedData && cell.dataset.reg === draggedData.reg && cell.dataset.date === draggedData.date) {
                        e.dataTransfer.dropEffect = 'move';
                        cell.classList.add('drag-over');
                    }
                });

                // Evento: SAIU DE CIMA
                cell.addEventListener('dragleave', (e) => {
                    cell.classList.remove('drag-over');
                });

                // Evento: SOLTOU (DROP)
                cell.addEventListener('drop', (e) => {
                    e.preventDefault();
                    cell.classList.remove('drag-over');
                    
                    if (!draggedData || !draggedCell) return;
                    
                    // Verificar se é da mesma linha
                    if (cell.dataset.reg !== draggedData.reg || cell.dataset.date !== draggedData.date) {
                        showAlert('Erro', 'Só é possível mover horários na mesma linha (mesmo funcionário/data)', 'warning');
                        return;
                    }

                    // Não fazer nada se soltou na mesma célula
                    if (cell === draggedCell) return;

                    const targetPunch = cell.dataset.punch;
                    const sourcePunch = draggedData.punch;

                    // Executar movimento
                    movePunchToSlot(draggedData.reg, draggedData.date, sourcePunch, targetPunch, draggedData.name);
                });
            });
        }

        // TAREFA 7: Mover horário para outro slot (não trocar, mover)
        function movePunchToSlot(reg, date, sourcePunch, targetPunch, name) {
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'Funcionário não encontrado!', 'error');
                return;
            }

            const sourceTime = employee.punches[sourcePunch] || '--:--';
            const targetTime = employee.punches[targetPunch] || '--:--';

            const punchLabels = {
                'ent1': 'Entrada 1', 'sai1': 'Saída 1',
                'ent2': 'Entrada 2', 'sai2': 'Saída 2',
                'ent3': 'Entrada 3', 'sai3': 'Saída 3',
                'ent4': 'Entrada 4', 'sai4': 'Saída 4',
                'ent5': 'Entrada 5', 'sai5': 'Saída 5'
            };

            const confirmed = true; // Execução direta sem confirmação
            
            console.log(`🔄 Movendo horário: ${punchLabels[sourcePunch]} (${sourceTime}) → ${punchLabels[targetPunch]} (${targetTime})`);

            if (!confirmed) return;

            // MOVER horário (não trocar)
            employee.punches[targetPunch] = sourceTime; // Coloca horário no destino
            employee.punches[sourcePunch] = '--:--';    // Limpa origem

            // Marcar como pendente de envio
            employee.pendingSwap = true;
            
            // Guardar informaçõeses da movimentação
            if (!employee.movedPunches) {
                employee.movedPunches = [];
            }
            employee.movedPunches.push({
                from: sourcePunch,
                to: targetPunch,
                time: sourceTime,
                timestamp: new Date()
            });

            // Atualizar tabela visualmente
            renderTable();

            // DEBOUNCE: Aguardar 2 segundos antes de enviar para Secullum
            if (sendToSecullumTimer) {
                clearTimeout(sendToSecullumTimer);
                console.log('⏱️ Timer cancelado - nova movimentação detectada');
            }

            sendToSecullumTimer = setTimeout(async () => {
                showLoading('🔄 Enviando para Secullum...');
                
                try {
                    await enviarParaSecullum(employee);
                    hideLoading();
                    showAlert('✅ Sucesso', `Horário enviado para Secullum!\n${punchLabels[sourcePunch]} → ${punchLabels[targetPunch]}`, 'success');
                    // Atualizar dados automaticamente
                    await searchPeriod();
                } catch (error) {
                    hideLoading();
                    console.error('❌ Erro ao enviar para Secullum:', error);
                    showAlert('❌ Erro no Envio', `Falha ao enviar para Secullum:\n${error.message}\n\nVerifique a conexão e tente novamente.`, 'error');
                }
                sendToSecullumTimer = null;
            }, 1000); // 1 segundo (otimizado)
        }

        // Mostrar setas de navegação ao clicar na célula (igual Secullum)
        function showSwapMenu(event, cell) {
            event.stopPropagation();
            
            // Remover setas antigas
            document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
            
            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punch = cell.dataset.punch;
            const name = cell.dataset.name;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee || !employee.punches[punch]) return;
            
            // Se já esté selecionada, desselecionar
            if (selectedCell === cell) {
                cell.classList.remove('selected-cell');
                selectedCell = null;
                return;
            }
            
            // Remover seleçãoão anterior
            if (selectedCell) {
                selectedCell.classList.remove('selected-cell');
            }
            
            // Marcar célula como selecionada
            cell.classList.add('selected-cell');
            selectedCell = cell;
            
            // Adicionar seta em TODAS as outras células com Horário da MESMA LINHA
            const rowCells = document.querySelectorAll(`.punch-cell[data-reg="${reg}"][data-date="${date}"]`);
            
            rowCells.forEach(targetCell => {
                const targetPunch = targetCell.dataset.punch;
                
                // Ignorar a própria célula
                if (targetCell === cell) return;
                
                // Verificar se tem Horário
                if (!employee.punches[targetPunch] || employee.punches[targetPunch] === '--:--') return;
                
                // Adicionar seta ãnica no canto
                const arrow = document.createElement('span');
                arrow.className = 'swap-arrow';
                arrow.textContent = '?';
                arrow.title = 'Trocar Horários';
                arrow.onclick = (e) => {
                    e.stopPropagation();
                    document.querySelectorAll('.swap-arrow').forEach(a => a.remove());
                    cell.classList.remove('selected-cell');
                    selectedCell = null;
                    swapPunches(e, reg, date, punch, targetPunch, name);
                };
                
                targetCell.appendChild(arrow);
            });
            
            // Remover setas ao clicar fora
            setTimeout(() => {
                function closeArrows(e) {
                    if (!e.target.closest('.punch-cell') && !e.target.classList.contains('swap-arrow')) {
                        document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
                        if (selectedCell) {
                            selectedCell.classList.remove('selected-cell');
                            selectedCell = null;
                        }
                        document.removeEventListener('click', closeArrows);
                    }
                }
                document.addEventListener('click', closeArrows);
            }, 100);
        }
        
        // Inverter batidas LOCALMENTE (não envia para API imediatamente)
        async function swapPunches(event, reg, date, punch1, punch2, name) {
            event.stopPropagation();
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'FUNCIONÁRIO não encontrado!', 'error');
                return;
            }

            const punch1Label = {
                'ent1': 'Entrada 1', 'sai1': 'SAÍda 1',
                'ent2': 'Entrada 2', 'sai2': 'SAÍda 2',
                'ent3': 'Entrada 3', 'sai3': 'SAÍda 3',
                'ent4': 'Entrada 4', 'sai4': 'SAÍda 4',
                'ent5': 'Entrada 5', 'sai5': 'SAÍda 5'
            }[punch1];

            const punch2Label = {
                'ent1': 'Entrada 1', 'sai1': 'SAÍda 1',
                'ent2': 'Entrada 2', 'sai2': 'SAÍda 2',
                'ent3': 'Entrada 3', 'sai3': 'SAÍda 3',
                'ent4': 'Entrada 4', 'sai4': 'SAÍda 4',
                'ent5': 'Entrada 5', 'sai5': 'SAÍda 5'
            }[punch2];

            const time1 = employee.punches[punch1] || '--:--';
            const time2 = employee.punches[punch2] || '--:--';

            console.log(`🔄 Invertendo horários: ${punch1Label} (${time1}) ↔ ${punch2Label} (${time2})`);

            // Limpar seleção
            document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
            document.querySelectorAll('.selected-cell').forEach(cell => cell.classList.remove('selected-cell'));
            selectedCell = null;

            try {
                // TROCAR OS HorárioS LOCALMENTE
                const tempTime = employee.punches[punch1];
                employee.punches[punch1] = employee.punches[punch2];
                employee.punches[punch2] = tempTime;

                // Marcar como pendente de envio
                employee.pendingSwap = true;
                
                // Guardar informaçõeses da troca
                if (!employee.swappedPunches) {
                    employee.swappedPunches = [];
                }
                employee.swappedPunches.push({
                    punch1,
                    punch2,
                    time1: employee.punches[punch1], // novo valor
                    time2: employee.punches[punch2]  // novo valor
                });

                // Limpar seleçãoão
                document.querySelectorAll('.swap-arrow').forEach(arrow => arrow.remove());
                document.querySelectorAll('.selected-cell').forEach(cell => cell.classList.remove('selected-cell'));
                selectedCell = null;

                // Atualizar tabela visualmente
                renderTable();

                // ENVIAR IMEDIATAMENTE para Secullum
                await enviarParaSecullum(employee);

            } catch (error) {
                console.error('Erro ao inverter batidas:', error);
                showAlert(
                    'Erro ao Inverter',
                    `não foi posSóvel inverter as batidas:\n\n${error.message}`,
                    'error'
                );
            }
        }

        // ==========================================
        // MONITOR DE méQUINAS DE PONTO
        // ==========================================
        function openMachineMonitor() {
            // Abrir monitor.html em nova guia
            window.open('monitor.html', '_blank');
        }

        // PAINEL DE PRESENçãA
        function openPresencePanel() {
            // Abrir presenca.html em nova guia
            window.open('presenca.html', '_blank');
        }

        // ==========================================
        // DASHBOARD DE RELATÓRIOS
        // ==========================================
        function openReportDashboard() {
            // Abrir relatorio.html em nova guia
            window.open('relatorio.html', '_blank');
        }

        function closeMachineMonitor() {
            document.getElementById('machineMonitorModal').classList.remove('active');
        }

        function logout() {
            // Limpar todos os dados do localStorage
            localStorage.clear();
            sessionStorage.clear();
            
            // Redirecionar para login
            window.location.href = '/login.html';
        }

        async function refreshMachineMonitor() {
            try {
                showLoading('Consultando méquinas de todas as empresas...');
                
                // Definir quais bancos consultar
                let bancosParaConsultar = [];
                
                if (API_CONFIG.selectedCompanies.includes('all')) {
                    // Se "TODAS" selecionado, busca de TODAS as empresas
                    bancosParaConsultar = API_CONFIG.companies.map(c => c.id);
                } else {
                    // Senão, busca apenas das empresas selecionadas
                    bancosParaConsultar = API_CONFIG.selectedCompanies;
                }
                
                if (bancosParaConsultar.length === 0) {
                    showAlert('Erro', 'Nenhuma empresa disponível! Faça login primeiro.', 'error');
                    hideLoading();
                    return;
                }
                
                // Buscar méquinas de todas as empresas em paralelo (SEM autenticaçãoO)
                const promises = bancosParaConsultar.map(bancoid => {
                    return fetch(`${API_BASE_URL}/api/machine-monitor?bancoid=${bancoid}`)
                        .then(async r => {
                            if (!r.ok) {
                                console.warn(`ℹ Erro ao consultar banco ${bancoid}: HTTP ${r.status}`);
                                return [];
                            }
                            return r.json();
                        })
                        .catch(err => {
                            console.error(`? Erro ao consultar banco ${bancoid}:`, err);
                            return [];
                        });
                });
                
                const results = await Promise.all(promises);
                const machines = results.flat();
                
                const now = new Date();
                document.getElementById('monitorLastUpdate').textContent = now.toLocaleTimeString('pt-BR');
                
                const content = document.getElementById('machineMonitorContent');
                
                if (machines.length === 0) {
                    content.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;">Nenhuma méquina encontrada</div>';
                    hideLoading();
                    return;
                }
                
                // Ordenar por Última sincronização (mais recente primeiro)
                machines.sort((a, b) => {
                    const dateA = a.lastSync ? new Date(a.lastSync).getTime() : 0;
                    const dateB = b.lastSync ? new Date(b.lastSync).getTime() : 0;
                    return dateB - dateA; // DESC (mais recente primeiro)
                });
                
                // Tabela estilo lista limpa
                let html = `
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 14px 16px; text-align: left; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">? EQUIPAMENTO</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">ℹ Última SINC</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">ℹ QTD BATIDAS</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">ℹ Hçã QUANTO TEMPO</th>
                                    <th style="padding: 14px 16px; text-align: center; font-weight: 700; font-size: 13px; letter-spacing: 0.5px;">ℹ STATUS</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                machines.forEach((machine, index) => {
                    // Verificar se lastSync ã válido
                    let lastSync = null;
                    if (machine.lastSync && 
                        machine.lastSync !== 'Nunca sincronizado' && 
                        machine.lastSync !== 'Erro ao consultar' &&
                        !machine.lastSync.includes('Nunca') &&
                        !machine.lastSync.includes('Erro')) {
                        try {
                            lastSync = new Date(machine.lastSync);
                            // Validar se a data ã válida
                            if (isNaN(lastSync.getTime())) {
                                lastSync = null;
                            }
                        } catch (e) {
                            lastSync = null;
                        }
                    }
                    
                    const diffMinutes = lastSync ? Math.floor((now - lastSync) / 60000) : 99999;
                    
                    let statusColor = '#10b981'; // Verde
                    let statusText = '? ONLINE';
                    let bgRow = index % 2 === 0 ? '#f8fafc' : 'white';
                    
                    if (!lastSync || diffMinutes > 60) {
                        statusColor = '#ef4444'; // Vermelho
                        statusText = '? OFFLINE';
                    } else if (diffMinutes > 30) {
                        statusColor = '#f59e0b'; // Amarelo
                        statusText = 'ℹ ALERTA';
                    }
                    
                    const tempoAtras = lastSync 
                        ? (diffMinutes < 1 ? 'Agora' : diffMinutes < 60 ? `${diffMinutes} min` : `${Math.floor(diffMinutes/60)}h ${diffMinutes%60}min`)
                        : 'Nunca';
                    
                    html += `
                        <tr style="background: ${bgRow}; border-bottom: 1px solid #e2e8f0; transition: all 0.2s;" onmouseover="this.style.background='#f1f5f9'" onmouseout="this.style.background='${bgRow}'">
                            <td style="padding: 14px 16px; font-weight: 600; color: #1e293b; font-size: 14px;">
                                ${machine.name}
                                <div style="font-size: 11px; color: #94a3b8; font-weight: 400; margin-top: 2px;">
                                    ℹ ${machine.id} ã ℹ ${machine.ip || 'N/A'}
                                </div>
                            </td>
                            <td style="padding: 14px 16px; text-align: center; color: #475569; font-size: 13px;">
                                ${lastSync ? lastSync.toLocaleString('pt-BR', {day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit'}) : '<span style="color: #94a3b8;">Sem dados</span>'}
                            </td>
                            <td style="padding: 14px 16px; text-align: center;">
                                <span style="background: ${machine.totalBatidas > 0 ? '#10b98120' : '#ef444420'}; color: ${machine.totalBatidas > 0 ? '#10b981' : '#ef4444'}; padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: 700;">
                                    ${machine.totalBatidas || 0} ${machine.lastSyncCount > 0 ? `(${machine.lastSyncCount} na Última)` : ''}
                                </span>
                            </td>
                            <td style="padding: 14px 16px; text-align: center; color: ${statusColor}; font-weight: 700; font-size: 14px;">
                                ${tempoAtras}
                            </td>
                            <td style="padding: 14px 16px; text-align: center;">
                                <span style="background: ${statusColor}; color: white; padding: 6px 14px; border-radius: 20px; font-size: 11px; font-weight: 700; white-space: nowrap; display: inline-block;">
                                    ${statusText}
                                </span>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                content.innerHTML = html;
                
                hideLoading();
            } catch (err) {
                console.error('? Erro ao buscar méquinas:', err);
                showAlert('Erro', 'não foi posSóvel consultar as méquinas: ' + err.message, 'error');
                hideLoading();
            }
        }

        function exportMachineMonitor() {
            showAlert('Info', 'Use a captura de tela do Windows (Win + Shift + S) para tirar um print do monitor!', 'info');
        }

        // Fechar modal ao clicar fora
        document.getElementById('machineMonitorModal').addEventListener('click', (e) => {
            if (e.target.id === 'machineMonitorModal') {
                closeMachineMonitor();
            }
        });

        // ==========================================
        // DELETAR PONTO (CRUD)
        // ==========================================
        async function deletePunch(event, reg, date, punchType, columnName) {
            event.stopPropagation(); // não abrir Edição
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'FUNCIONÁRIO não encontrado', 'error');
                return;
            }
            
            const currentTime = employee.punches[punchType];
            if (!currentTime || currentTime === '--:--') {
                showAlert('Info', 'não hçã ponto para apagar neste Horário', 'info');
                return;
            }
            
            // Execução direta sem confirmação
            console.log(`🗑️ Apagando ponto: ${employee.name} - ${columnName}: ${currentTime}`);
            
            try {
                showLoading('Apagando ponto...');
                
                // Converter data para formato ISO
                let dataFormatted = date;
                if (date.includes('/')) {
                    const parts = date.split('/');
                    dataFormatted = `${parts[2]}-${parts[1].padStart(2, '0')}-${parts[0].padStart(2, '0')}`;
                }
                if (dataFormatted.includes('T')) {
                    dataFormatted = dataFormatted.split('T')[0];
                }
                
                console.log(`? Apagando ${columnName}:`, {
                    NumeroFolha: reg,
                    Data: dataFormatted + 'T00:00:00',
                    Coluna: columnName,
                    Hora: '', // Vazio = DELETE
                    Motivo: 'ExcluSóo via sistema'
                });
                
                // Enviar para API Secullum (Hora vazia = DELETE)
                const response = await fetch('https://pontowebintegracaoexterna.secullum.com.br/IntegracaoExterna/CartaoPonto/Manual', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Token': secullumToken
                    },
                    body: JSON.stringify({
                        NumeroFolha: reg,
                        Data: dataFormatted + 'T00:00:00',
                        Coluna: columnName,
                        Hora: null, // NULL = DELETE na API Secullum
                        Motivo: 'ExcluSóo via sistema'
                    })
                });
                
                console.log(`ℹ Status da resposta: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`? Erro:`, errorText);
                    throw new Error(`Erro ${response.status}: ${errorText}`);
                }
                
                const result = await response.json();
                console.log(`? Ponto apagado com sucesso:`, result);
                
                // Atualizar na meméria
                employee.punches[punchType] = null;
                
                // Atualizar visualmente
                renderTable();
                
                hideLoading();
                showAlert('Sucesso', `Ponto ${columnName} apagado com sucesso!`, 'success');
                
            } catch (err) {
                console.error('? Erro ao apagar ponto:', err);
                hideLoading();
                showAlert('Erro', `não foi posSóvel apagar o ponto: ${err.message}`, 'error');
            }
        }

        // ==========================================
        // Edição INLINE (Estilo Excel)
        // ==========================================
        let currentEditingCell = null;

        function startInlineEdit(cell) {
            // Se já esté editando outra célula, cancela
            if (currentEditingCell && currentEditingCell !== cell) {
                cancelInlineEdit(currentEditingCell);
            }

            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punchType = cell.dataset.punch; // ent1, sai1, ent2, etc
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) return;

            // Valor atual
            const currentValue = employee.punches[punchType] || '';

            // Marcar célula como editando
            cell.classList.add('editing');
            currentEditingCell = cell;

            // Criar input
            const input = document.createElement('input');
            input.type = 'time';
            input.className = 'inline-input';
            input.value = currentValue;
            
            // Limpar célula e adicionar input
            cell.innerHTML = '';
            cell.appendChild(input);
            input.focus();
            input.select();

            // Flag para evitar méltiplas chamadas
            let saving = false;

            // funçãoo para salvar (evita duplicação)
            const save = () => {
                if (!saving) {
                    saving = true;
                    input.removeEventListener('blur', save);
                    saveInlineEdit(cell, reg, date, punchType, input.value);
                }
            };

            // Eventos do input
            input.addEventListener('blur', save);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    save();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    saving = true; // Prevenir blur
                    input.removeEventListener('blur', save);
                    cancelInlineEdit(cell);
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    saving = true; // Prevenir blur
                    input.removeEventListener('blur', save);
                    saveInlineEdit(cell, reg, date, punchType, input.value);
                    // Mover para próxima célula editável
                    const nextCell = e.shiftKey ? getPreviousEditableCell(cell) : getNextEditableCell(cell);
                    if (nextCell) {
                        setTimeout(() => startInlineEdit(nextCell), 100);
                    }
                }
            });
        }

        function getNextEditableCell(currentCell) {
            const row = currentCell.parentElement;
            const cells = Array.from(row.querySelectorAll('.editable-cell'));
            const currentIndex = cells.indexOf(currentCell);
            
            if (currentIndex < cells.length - 1) {
                return cells[currentIndex + 1];
            } else {
                // Prçãxima linha
                const nextRow = row.nextElementSibling;
                if (nextRow) {
                    return nextRow.querySelector('.editable-cell');
                }
            }
            return null;
        }

        function getPreviousEditableCell(currentCell) {
            const row = currentCell.parentElement;
            const cells = Array.from(row.querySelectorAll('.editable-cell'));
            const currentIndex = cells.indexOf(currentCell);
            
            if (currentIndex > 0) {
                return cells[currentIndex - 1];
            } else {
                // Linha anterior
                const prevRow = row.previousElementSibling;
                if (prevRow) {
                    const prevCells = prevRow.querySelectorAll('.editable-cell');
                    return prevCells[prevCells.length - 1];
                }
            }
            return null;
        }

        async function saveInlineEdit(cell, reg, date, punchType, newValue) {
            if (!currentEditingCell) return;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                cancelInlineEdit(cell);
                return;
            }

            // Se o valor não mudou, apenas cancela
            const oldValue = employee.punches[punchType] || '';
            if (newValue === oldValue) {
                cancelInlineEdit(cell);
                return;
            }

            // Mostrar feedback visual
            cell.classList.add('saving-cell');
            cell.classList.remove('editing');
            
            // Limpar completamente a cçãlula antes de adicionar novo conteçãdo
            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            
            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'punch-time present';
            loadingSpan.style.fontSize = '13px';
            loadingSpan.textContent = newValue || '--:--';
            cell.appendChild(loadingSpan);

            try {
                // Mapear tipo de punch para nome da coluna
                const colunaMap = {
                    'ent1': 'Entrada1',
                    'sai1': 'Saida1',
                    'ent2': 'Entrada2',
                    'sai2': 'Saida2',
                    'ent3': 'Entrada3',
                    'sai3': 'Saida3',
                    'ent4': 'Entrada4',
                    'sai4': 'Saida4',
                    'ent5': 'Entrada5',
                    'sai5': 'Saida5'
                };

                // Buscar dados completos do FUNCIONÁRIO (igual no modal)
                const funcionarioId = employee.rawData?.FuncionarioId || employee.dadosCompletos?.FuncionarioId;
                const data = employee.rawData?.Data || employee.dadosCompletos?.Data || employee.date;
                
                if (!funcionarioId) {
                    throw new Error('ID do FUNCIONÁRIO não encontrado! Recarregue os dados.');
                }

                const payload = {
                    NumeroFolha: reg,
                    Data: data, // Usar data original da API (já vem formatada)
                    Coluna: colunaMap[punchType],
                    Hora: newValue,
                    Motivo: 'Edição inline via sistema'
                };

                console.log(`ℹ Salvando ${colunaMap[punchType]}: ${newValue}`, payload);

                const endpoint = `${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`;

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${API_CONFIG.token}`,
                        'Content-Type': 'application/json',
                        'secullumidbancoselecionado': employee.empresaId || employee.companyId
                    },
                    body: JSON.stringify(payload)
                });

                console.log(`ℹ Status da resposta: ${response.status}`);

                if (response.ok) {
                    // ✅ INVALIDAÇÃO CIRÚRGICA: Recarregar apenas este funcionário
                    console.log('⚡ Invalidando cache do funcionário...');
                    await invalidateSingleEmployee(reg, date, employee.empresaId || employee.companyId);
                    
                    // Tenta ler como JSON, mas aceita resposta vazia
                    const responseText = await response.text();
                    console.log(`ℹ Resposta texto: "${responseText}"`);
                    
                    let result = null;
                    if (responseText && responseText.trim() !== '') {
                        try {
                            result = JSON.parse(responseText);
                        } catch (e) {
                            console.warn('ℹ Resposta não ã JSON válido, mas status ã OK');
                        }
                    }
                    
                    console.log(`? ${colunaMap[punchType]} registrada com sucesso!`, result || '(sem retorno JSON)');
                    
                    // Atualizar valor local
                    employee.punches[punchType] = newValue;
                    
                    // Re-renderizar cçãlula com sucesso
                    cell.classList.remove('saving-cell');
                    
                    // Limpar completamente antes de adicionar
                    while (cell.firstChild) {
                        cell.removeChild(cell.firstChild);
                    }
                    
                    const editIcon = document.createElement('span');
                    editIcon.className = 'edit-icon';
                    editIcon.textContent = '';
                    
                    const timeSpan = document.createElement('span');
                    timeSpan.className = `punch-time ${newValue ? 'present' : 'missing'}`;
                    timeSpan.style.fontSize = '13px';
                    timeSpan.textContent = newValue || '--:--';
                    
                    cell.appendChild(editIcon);
                    cell.appendChild(timeSpan);
                    
                    // Atualizar status de inconsisténcia (sem recarregar tudo)
                    updateEmployeeStatus(employee);
                    
                    // VERIFICAR SE FICOU COM ORDEM INCORRETA OU BATIDAS ãMPARES
                    const batidas = [
                        employee.punches.ent1, employee.punches.sai1,
                        employee.punches.ent2, employee.punches.sai2,
                        employee.punches.ent3, employee.punches.sai3,
                        employee.punches.ent4, employee.punches.sai4,
                        employee.punches.ent5, employee.punches.sai5
                    ].filter(h => h && h !== '--:--');
                    
                    const totalBatidas = batidas.length;
                    
                    // Verificar ordem cronológica
                    const timeToMinutes = (time) => {
                        if (!time) return 0;
                        const [h, m] = time.split(':').map(Number);
                        return h * 60 + m;
                    };
                    
                    let ordemIncorreta = false;
                    const horariosOrdenados = [
                        employee.punches.ent1, employee.punches.sai1,
                        employee.punches.ent2, employee.punches.sai2,
                        employee.punches.ent3, employee.punches.sai3,
                        employee.punches.ent4, employee.punches.sai4,
                        employee.punches.ent5, employee.punches.sai5
                    ].filter(h => h && h !== '--:--');
                    
                    for (let i = 1; i < horariosOrdenados.length; i++) {
                        const anterior = timeToMinutes(horariosOrdenados[i - 1]);
                        const atual = timeToMinutes(horariosOrdenados[i]);
                        
                        if (atual <= anterior) {
                            ordemIncorreta = true;
                            break;
                        }
                    }
                    
                    // AVISOS - usando showAlert
                    if (ordemIncorreta) {
                        showAlert('Atenção', `Ordem cronológica incorreta! Horários: ${horariosOrdenados.join(' → ')}`, 'warning');
                    } else if (totalBatidas !== 4) {
                        showAlert('Atenção', `${totalBatidas} batidas registradas (esperado: 4)`, 'warning');
                    }
                    
                } else {
                    const errorText = await response.text();
                    console.error('? Erro:', errorText);
                    showAlert('Erro', `Erro ao salvar: ${errorText}`, 'error');
                    cancelInlineEdit(cell);
                }
            } catch (error) {
                console.error('? Erro na requisiçãão:', error);
                showAlert('Erro', 'Erro ao salvar alteração. Verifique o console.', 'error');
                cancelInlineEdit(cell);
            }

            currentEditingCell = null;
        }

        function cancelInlineEdit(cell) {
            if (!cell) return;
            
            const reg = cell.dataset.reg;
            const date = cell.dataset.date;
            const punchType = cell.dataset.punch;
            
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            const currentValue = employee ? (employee.punches[punchType] || '') : '';

            cell.classList.remove('editing', 'saving-cell');
            
            // Limpar completamente antes de adicionar (evita erro de DOM)
            while (cell.firstChild) {
                cell.removeChild(cell.firstChild);
            }
            
            const editIcon = document.createElement('span');
            editIcon.className = 'edit-icon';
            editIcon.textContent = '';
            
            const timeSpan = document.createElement('span');
            timeSpan.className = `punch-time ${currentValue ? 'present' : 'missing'}`;
            timeSpan.style.fontSize = '13px';
            timeSpan.textContent = currentValue || '--:--';
            
            cell.appendChild(editIcon);
            cell.appendChild(timeSpan);
            
            currentEditingCell = null;
        }

        // funçãoo auxiliar para atualizar status de um FUNCIONÁRIO
        function updateEmployeeStatus(employee) {
            const p = employee.punches;
            
            // Coletar todas as batidas válidas
            const batidas = [
                p.ent1, p.sai1,
                p.ent2, p.sai2,
                p.ent3, p.sai3,
                p.ent4, p.sai4,
                p.ent5, p.sai5
            ].filter(h => h && h !== '--:--');
            
            const totalBatidas = batidas.length;
            
            // funçãoo para converter HH:MM em minutos
            const timeToMinutes = (time) => {
                if (!time) return 0;
                const [h, m] = time.split(':').map(Number);
                return h * 60 + m;
            };
            
            // VALIDAR ORDEM cronológica
            let ordemIncorreta = false;
            const horariosOrdenados = [
                { nome: 'Entrada 1', hora: p.ent1 },
                { nome: 'SAÍda 1', hora: p.sai1 },
                { nome: 'Entrada 2', hora: p.ent2 },
                { nome: 'SAÍda 2', hora: p.sai2 },
                { nome: 'Entrada 3', hora: p.ent3 },
                { nome: 'SAÍda 3', hora: p.sai3 },
                { nome: 'Entrada 4', hora: p.ent4 },
                { nome: 'SAÍda 4', hora: p.sai4 },
                { nome: 'Entrada 5', hora: p.ent5 },
                { nome: 'SAÍda 5', hora: p.sai5 }
            ].filter(h => h.hora && h.hora !== '--:--');
            
            for (let i = 1; i < horariosOrdenados.length; i++) {
                const anterior = timeToMinutes(horariosOrdenados[i - 1].hora);
                const atual = timeToMinutes(horariosOrdenados[i].hora);
                
                if (atual <= anterior) {
                    ordemIncorreta = true;
                    console.log(`ℹ ORDEM INCORRETA: ${employee.name} - ${horariosOrdenados[i - 1].nome} (${horariosOrdenados[i - 1].hora}) >= ${horariosOrdenados[i].nome} (${horariosOrdenados[i].hora})`);
                    break;
                }
            }
            
            // Verificar se tem motivo especial
            const motivosEspeciais = ['FALTA', 'FÉRIAS', 'AFASTAMENTO INSS', 'LICENÇA MATERNIDADE'];
            const temMotivoEspecial = motivosEspeciais.includes(employee.motivo);
            
            // Marca inconsisténcia se:
            // 1. não tem exatamente 4 batidas
            // 2. OU Horários em ordem incorreta
            // 3. E não tem motivo especial
            const batidaIncorreta = totalBatidas !== 4 || ordemIncorreta;
            
            if (batidaIncorreta && !temMotivoEspecial) {
                employee.hasInconsistency = true;
            } else {
                employee.hasInconsistency = false;
            }
            
            // Re-renderizar apenas a linha deste FUNCIONÁRIO
            renderTable();
        }

        // ==========================================
        // Edição DE BATIDAS
        // ==========================================
        let currentEditEmployee = null;

        function openEditModal(reg, date) {
            const employee = allEmployees.find(emp => emp.reg === reg && emp.date === date);
            if (!employee) {
                showAlert('Erro', 'Funcionário não encontrado!', 'error');
                return;
            }

            currentEditEmployee = employee;

            // Preencher informaçõeses do FUNCIONÁRIO
            document.getElementById('editEmployeeName').textContent = employee.name;
            document.getElementById('editEmployeeReg').textContent = employee.reg;
            document.getElementById('editEmployeeDate').textContent = date;

            // Preencher Horários atuais (convertendo HH:MM para HH:MM formato do input)
            const setTimeValue = (id, value) => {
                const input = document.getElementById(id);
                if (value && value !== '--:--') {
                    // Se já esté no formato HH:MM, usa direto
                    input.value = value.length === 4 ? `0${value}` : value; // Adiciona zero se for H:MM
                } else {
                    input.value = '';
                }
            };

            setTimeValue('editEnt1', employee.punches.ent1);
            setTimeValue('editSai1', employee.punches.sai1);
            setTimeValue('editEnt2', employee.punches.ent2);
            setTimeValue('editSai2', employee.punches.sai2);
            setTimeValue('editEnt3', employee.punches.ent3);
            setTimeValue('editSai3', employee.punches.sai3);
            setTimeValue('editEnt4', employee.punches.ent4);
            setTimeValue('editSai4', employee.punches.sai4);
            setTimeValue('editEnt5', employee.punches.ent5);
            setTimeValue('editSai5', employee.punches.sai5);

            // Mostrar modal
            document.getElementById('editModal').style.display = 'flex';
        }

        function closeEditModal() {
            document.getElementById('editModal').style.display = 'none';
            currentEditEmployee = null;
        }

        async function confirmSaveEdit() {
            if (!currentEditEmployee) return;

            // Coletar valores editados
            const getTimeValue = (id) => {
                const value = document.getElementById(id).value;
                return value ? value : null;
            };

            const updatedPunches = {
                ent1: getTimeValue('editEnt1'),
                sai1: getTimeValue('editSai1'),
                ent2: getTimeValue('editEnt2'),
                sai2: getTimeValue('editSai2'),
                ent3: getTimeValue('editEnt3'),
                sai3: getTimeValue('editSai3'),
                ent4: getTimeValue('editEnt4'),
                sai4: getTimeValue('editSai4'),
                ent5: getTimeValue('editEnt5'),
                sai5: getTimeValue('editSai5')
            };

            console.log('📊 Dados a serem enviados:', updatedPunches);
            console.log('👤 FUNCIONÁRIO:', currentEditEmployee);

            // Envio direto sem confirmação
            console.log(`ℹ️ Enviando alterações para ${currentEditEmployee.name}...`);

            try {
                // Buscar o ID do FUNCIONÁRIO na API (necesSório para o endpoint)
                const funcionarioId = currentEditEmployee.rawData?.FuncionarioId || currentEditEmployee.dadosCompletos?.FuncionarioId;
                const data = currentEditEmployee.rawData?.Data || currentEditEmployee.dadosCompletos?.Data || currentEditEmployee.data;
                
                if (!funcionarioId) {
                    throw new Error('ID do FUNCIONÁRIO não encontrado! Recarregue os dados.');
                }

                console.log(`ℹ Iniciando atualizaçãoo de batidas...`);
                console.log(`ℹ FuncionarioId: ${funcionarioId}`);
                console.log(`ℹ Data: ${data}`);

                // Endpoint da Secullum para incluir batida manual
                const endpoint = `${API_CONFIG.baseURL}/IntegracaoExterna/CartaoPonto/Manual`;
                
                let sucessos = 0;
                let erros = 0;

                // Enviar cada batida individualmente
                const batidas = [
                    { tipo: 'E', hora: updatedPunches.ent1, label: 'Entrada 1', coluna: 'Entrada1' },
                    { tipo: 'S', hora: updatedPunches.sai1, label: 'SAÍda 1', coluna: 'Saida1' },
                    { tipo: 'E', hora: updatedPunches.ent2, label: 'Entrada 2', coluna: 'Entrada2' },
                    { tipo: 'S', hora: updatedPunches.sai2, label: 'SAÍda 2', coluna: 'Saida2' },
                    { tipo: 'E', hora: updatedPunches.ent3, label: 'Entrada 3', coluna: 'Entrada3' },
                    { tipo: 'S', hora: updatedPunches.sai3, label: 'SAÍda 3', coluna: 'Saida3' },
                    { tipo: 'E', hora: updatedPunches.ent4, label: 'Entrada 4', coluna: 'Entrada4' },
                    { tipo: 'S', hora: updatedPunches.sai4, label: 'SAÍda 4', coluna: 'Saida4' },
                    { tipo: 'E', hora: updatedPunches.ent5, label: 'Entrada 5', coluna: 'Entrada5' },
                    { tipo: 'S', hora: updatedPunches.sai5, label: 'SAÍda 5', coluna: 'Saida5' }
                ];

                for (const batida of batidas) {
                    if (!batida.hora) continue; // Pula se não tiver Horário

                    const payload = {
                        NumeroFolha: currentEditEmployee.reg,
                        Data: data,
                        Coluna: batida.coluna, // "Entrada1", "Saida1", etc (TEXTO, não nçãmero!)
                        Hora: batida.hora,
                        Motivo: 'IncluSóo manual via sistema'
                    };

                    console.log(`ℹ Enviando ${batida.label}: ${batida.hora}`, payload);

                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${API_CONFIG.token}`,
                                'Content-Type': 'application/json',
                                'secullumidbancoselecionado': currentEditEmployee.empresaId || API_CONFIG.companies[0]?.id
                            },
                            body: JSON.stringify(payload)
                        });

                        console.log(`ℹ Status da resposta: ${response.status}`);

                        if (response.ok) {
                            // Tenta ler como JSON, mas aceita resposta vazia
                            const responseText = await response.text();
                            console.log(`ℹ Resposta texto: "${responseText}"`);
                            
                            let result = null;
                            if (responseText && responseText.trim() !== '') {
                                try {
                                    result = JSON.parse(responseText);
                                } catch (e) {
                                    console.warn('ℹ Resposta não ã JSON válido, mas status ã OK');
                                }
                            }
                            
                            console.log(`? ${batida.label} registrada com sucesso!`, result || '(sem retorno JSON)');
                            sucessos++;
                        } else {
                            const errorText = await response.text();
                            console.error(`? Erro ao registrar ${batida.label}: ${response.status} - ${errorText}`);
                            erros++;
                        }
                    } catch (fetchError) {
                        console.error(`? Erro de rede ao enviar ${batida.label}:`, fetchError);
                        erros++;
                    }

                    // Delay entre requisiçãães para evitar sobrecarga
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                if (erros === 0) {
                    showAlert('Sucesso', `Todas as batidas foram atualizadas! ${sucessos} horários registrados.`, 'success');
                } else {
                    showAlert('Atenção', `Atualização parcial: ${sucessos} com sucesso, ${erros} erros`, 'warning');
                }

                closeEditModal();

                // Recarregar dados
                console.log('🔄 Recarregando dados...');
                await searchPeriod();

            } catch (error) {
                console.error('? Erro ao atualizar batidas:', error);
                showAlert('Erro', `Erro ao atualizar batidas: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // EVENT LISTENERS
        // ==========================================
        
        // 📝 CORREçããO: Event listeners duplicados REMOVIDOS
        // Agora usa event delegation configurado na inicialização (linha ~2395)
        
        // Checkbox "Selecionar Todos"
        document.getElementById('selectAll').addEventListener('change', (e) => {
            const displayedEmployees = showOnlyInconsistencies 
                ? allEmployees.filter(emp => emp.hasInconsistency)
                : allEmployees;
            
            if (e.target.checked) {
                // ? SELECIONAR usando ID único (REG + DATA)
                selectedEmployees = displayedEmployees.map(emp => `${emp.reg}_${emp.date}`);
            } else {
                selectedEmployees = [];
            }
            
            // ? não CHAMAR renderTable()! Atualizar diretamente os checkboxes
            document.querySelectorAll('.employee-checkbox').forEach(cb => {
                const uniqueId = cb.dataset.id;
                if (displayedEmployees.some(emp => `${emp.reg}_${emp.date}` === uniqueId)) {
                    cb.checked = e.target.checked;
                    const row = cb.closest('tr');
                    if (row) {
                        if (e.target.checked) {
                            row.classList.add('selected');
                        } else {
                            row.classList.remove('selected');
                        }
                    }
                }
            });
            
            updateSelectionCounter();
        });

        // funçãoo compartilhada de geração de PDF
        async function generatePDFs() {
            // ✅ VERIFICAR SE HÁ SELEÇÃO
            if (selectedEmployees.length === 0) {
                showAlert('Atenção', 'Selecione pelo menos um colaborador usando os checkboxes!', 'warning');
                return;
            }
            
            // ✅ GERAR APENAS OS SELECIONADOS
            const displayedEmployees = showOnlyInconsistencies 
                ? allEmployees.filter(emp => emp.hasInconsistency)
                : allEmployees;
            
            // ✅ FILTRAR usando ID único (REG + DATA)
            const toGenerate = displayedEmployees.filter(emp => {
                const uniqueId = `${emp.reg}_${emp.date}`;
                return selectedEmployees.includes(uniqueId);
            });
            
            if (toGenerate.length === 0) {
                showAlert('Atenção', 'Nenhum colaborador selecionado encontrado!', 'warning');
                return;
            }
            
            // 🔄 MOSTRAR LOADING
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'pdfLoadingOverlay';
            loadingOverlay.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.7);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 99999;
                ">
                    <div style="
                        background: white;
                        padding: 40px 60px;
                        border-radius: 12px;
                        text-align: center;
                        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
                    ">
                        <div style="
                            width: 50px;
                            height: 50px;
                            border: 4px solid #e0e0e0;
                            border-top: 4px solid #1a73e8;
                            border-radius: 50%;
                            animation: spin 1s linear infinite;
                            margin: 0 auto 20px;
                        "></div>
                        <div style="font-size: 18px; font-weight: 600; color: #333;">
                            Gerando PDF...
                        </div>
                        <div style="font-size: 14px; color: #666; margin-top: 8px;">
                            ${toGenerate.length} formulário(s) sendo processado(s)
                        </div>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
            document.body.appendChild(loadingOverlay);
            
            // Helper para remover loading
            const hideLoading = () => {
                const overlay = document.getElementById('pdfLoadingOverlay');
                if (overlay) overlay.remove();
            };
            
            try {
                // 🚀 Preparar dados para envio em BATCH (uma única requisição)
                const registros = toGenerate.map(emp => ({
                    cpf: emp.cpf,
                    reg: emp.reg,
                    data: emp.date,
                    empresa_id: emp.empresaId || emp.companyId || 0,
                    nome: emp.name || '',
                    motivo: emp.motivo || ''
                }));
                
                // 📦 Enviar todos de uma vez
                const response = await fetch(`${API_BASE_URL}/api/justificativa/salvar-batch`, {
                    method: 'POST',
                    headers: getAuthHeaders(),
                    body: JSON.stringify({ registros })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.details || `HTTP ${response.status}`);
                }
                
                const { resultados, nomesExistentes, novos, existentes } = await response.json();
                
                // Atribuir IDs aos funcionários
                for (const resultado of resultados) {
                    const emp = toGenerate.find(e => e.reg === resultado.reg && e.date.includes(resultado.data.split('T')[0].split('-').reverse().join('/')));
                    if (emp && resultado.id) {
                        emp.id = resultado.id;
                    }
                }
                
                // ⚠️ Aviso rápido se há reimpressões (não bloqueia)
                if (existentes > 0 && nomesExistentes && nomesExistentes.length > 0) {
                    const nomes = nomesExistentes.join(', ');
                    showToast(`⚠️ Reimpressão: ${nomes}`, 'warning', 4000);
                }
                
                // Esconder loading antes de mostrar preview
                hideLoading();
                
                // Gerar PDFs usando emp.id do banco
                const pdfPages = document.getElementById('pdfPages');
                pdfPages.innerHTML = toGenerate.map((emp) => generateForm(emp, emp.id || '?', toGenerate.length)).join('');
                
                // Atualizar contador
                document.getElementById('pdfCount').textContent = `${toGenerate.length} formulário(s) – 1 por página A4 Paisagem`;
                
                // Mostrar preview
                document.getElementById('mainInterface').classList.add('hidden');
                document.getElementById('pdfPreview').classList.add('active');
                
                // Recarregar dados para atualizar a tabela com os novos IDs
                await reloadData();
                
            } catch (err) {
                hideLoading(); // Esconder loading em caso de erro
                console.error('❌ Erro ao gerar PDFs:', err);
                showAlert('Erro', `Erro ao salvar justificativas: ${err.message}`, 'error');
            }
        }
        
        // botãoo "GERAR PDF" no topo direito
        document.getElementById('btnGenerateTopRight').addEventListener('click', generatePDFs);

        document.getElementById('btnClosePDF').addEventListener('click', () => {
            document.getElementById('pdfPreview').classList.remove('active');
            document.getElementById('mainInterface').classList.remove('hidden');
        });

        // Event Listeners API - Removido botãoo manual, conecta automaticamente

        // botãoo de buscar Período
        document.getElementById('btnSearchDates').addEventListener('click', async () => {
            if (isAPIConnected) {
                await searchPeriod();
            } else {
                showAlert('Atenção', 'Primeiro conecte à API!', 'warning');
            }
        });

        // Campo de busca por nome - atualiza em tempo real (COM DEBOUNCE para performance)
        document.getElementById('searchName')?.addEventListener('input', debouncedRenderTable);
        
        // Filtro de Líder (atualizar em tempo real COM DEBOUNCE)
        document.getElementById('searchLider')?.addEventListener('input', debouncedRenderTable);

        // botãoo limpar filtro
        document.getElementById('btnClearFilter')?.addEventListener('click', () => {
            document.getElementById('searchName').value = '';
            document.getElementById('searchLider').value = '';
            document.getElementById('searchProject').value = '';
            document.getElementById('searchDepartamento').value = '';
            currentPage = 1; // Reset para primeira página
            renderTable();
        });
        
        // Filtro de projeto (atualizar em tempo real COM DEBOUNCE)
        document.getElementById('searchProject')?.addEventListener('input', debouncedRenderTable);
        
        // Filtro de departamento (atualizar em tempo real COM DEBOUNCE)
        document.getElementById('searchDepartamento')?.addEventListener('input', debouncedRenderTable);

        // ==========================================
        // 📝 botãoo DE TESTE - ANEXO OCR
        // ==========================================
        document.getElementById('btnTesteAnexo').addEventListener('click', () => {
            document.getElementById('inputTesteAnexo').click();
        });

        document.getElementById('inputTesteAnexo').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            console.clear();
            console.log('🧪 TESTE DE ANEXO E OCR INICIADO ');
            console.log('📁 Arquivo selecionado:', file.name, `(${(file.size / 1024).toFixed(2)} KB)`);

            try {
                // Converter para base64
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const imageBase64 = event.target.result;
                    
                    console.log('📊 Tamanho base64:', imageBase64.length, 'caracteres');

                    // Chamar funçãoo de OCR
                    console.log('');
                    console.log('');
                    console.log('☁️ INICIANDO AZURE COMPUTER VISION OCR');
                    console.log('');
                    
                    const resultado = await extrairDadosComGoogleVision(imageBase64);
                    
                    console.log('');
                    console.log('');
                    console.log('📊 RESULTADO FINAL DO OCR');
                    console.log('');
                    console.log('🆔 ID detectado:', resultado.id || 'não DETECTADO');
                    console.log('📋 Motivo:', resultado.motivo || 'não DETECTADO');
                    console.log('? Horários extraçãdos:');
                    console.log('   Ent1:', resultado.ent1 || 'vazio');
                    console.log('   Sai1:', resultado.sai1 || 'vazio');
                    console.log('   Ent2:', resultado.ent2 || 'vazio');
                    console.log('   Sai2:', resultado.sai2 || 'vazio');
                    console.log('   Ent3:', resultado.ent3 || 'vazio');
                    console.log('   Sai3:', resultado.sai3 || 'vazio');
                    console.log('🎯 Confiança:');
                    console.log('   ID:', resultado.confidence?.id || 0, '%');
                    console.log('   Motivo:', resultado.confidence?.motivo || 0, '%');
                    console.log('   Ent1:', resultado.confidence?.ent1 || 0, '%');
                    console.log('   Sai1:', resultado.confidence?.sai1 || 0, '%');
                    console.log('   Ent2:', resultado.confidence?.ent2 || 0, '%');
                    console.log('   Sai2:', resultado.confidence?.sai2 || 0, '%');
                    console.log('');
                    console.log('');
                    
                    // Mostrar popup com resultado
                    const horariosStr = [
                        resultado.ent1 ? `Ent1: ${resultado.ent1}` : null,
                        resultado.sai1 ? `Sai1: ${resultado.sai1}` : null,
                        resultado.ent2 ? `Ent2: ${resultado.ent2}` : null,
                        resultado.sai2 ? `Sai2: ${resultado.sai2}` : null,
                        resultado.ent3 ? `Ent3: ${resultado.ent3}` : null,
                        resultado.sai3 ? `Sai3: ${resultado.sai3}` : null
                    ].filter(h => h).join(', ');
                    
                    showAlert('Resultado OCR', `ID: ${resultado.id || 'Não detectado'} | Motivo: ${resultado.motivo || 'Padrão'} | Horários: ${horariosStr || 'Nenhum'}`, 'success');
                };
                reader.readAsDataURL(file);

            } catch (err) {
                console.error('? Erro no teste:', err);
                showAlert('Erro', `Erro no teste: ${err.message}`, 'error');
            }

            // Limpar input para permitir retestar o mesmo arquivo
            e.target.value = '';
        });

        // Inicializar
        renderTable();
        
        // Definir datas padrão: HOJE em ambos os campos
        (function setDefaultDates() {
            const today = new Date();
            
            // Formatar para YYYY-MM-DD (formato aceito pelo input type="date")
            const formatDate = (date) => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };
            
            document.getElementById('dateStart').value = formatDate(today);
            document.getElementById('dateEnd').value = formatDate(today);
            
            console.log(`ℹ Datas padrão configuradas: ${formatDate(today)} (hoje)`);
        })();
    </script>
    
    <!-- Modal de Upload de Anexo -->
    <div id="modalAnexo" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(10px); z-index: 10000; justify-content: center; align-items: center; overflow-y: auto;">
        <div style="background: rgba(30, 41, 59, 0.95); backdrop-filter: blur(20px); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 16px; padding: 24px 32px; max-width: 900px; width: 90%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.7); position: relative; margin: 20px auto;">
            <button onclick="fecharModalAnexo()" style="position: absolute; top: 16px; right: 16px; background: none; border: none; font-size: 32px; cursor: pointer; color: #94a3b8; padding: 0; width: 40px; height: 40px; line-height: 1;"></button>
            
            <h2 style="font-size: 24px; font-weight: bold; background: linear-gradient(135deg, #60a5fa, #a78bfa); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; margin: 0 0 8px 0;">ℹ Anexar Justificativa</h2>
            <p style="color: #94a3b8; margin: 0 0 24px 0; font-size: 14px;" id="modalAnexoInfo">REG: 000 | Data: 00/00/0000</p>
            
            <div id="dropZone" style="border: 3px dashed #3b82f6; border-radius: 12px; padding: 32px 24px; text-align: center; background: rgba(59, 130, 246, 0.1); cursor: pointer; transition: all 0.3s; margin-bottom: 16px;">
                <div style="font-size: 40px; margin-bottom: 12px;"></div>
                <h3 style="font-size: 16px; font-weight: 600; color: #e2e8f0; margin: 0 0 6px 0;">Cole o print aqui (Ctrl+V)</h3>
                <p style="color: #94a3b8; margin: 0; font-size: 13px;">Ou clique para selecionar arquivo</p>
                <input type="file" id="fileInput" accept="image/*" style="display: none;">
            </div>
            
            <div id="previewArea" style="display: none; margin-bottom: 16px;">
                <img id="previewImage" style="max-width: 100%; max-height: 300px; width: auto; height: auto; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); display: block; margin: 0 auto;">
            </div>
            
            <div id="ocrStatus" style="display: none; padding: 16px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.1); border-radius: 8px; margin-bottom: 16px;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div class="spinner" style="border: 3px solid rgba(148, 163, 184, 0.2); border-top: 3px solid #3b82f6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite;"></div>
                    <span id="ocrStatusText" style="color: #e2e8f0;">Processando OCR...</span>
                </div>
            </div>
            
            <div id="ocrResult" style="display: none; padding: 16px; background: rgba(16, 185, 129, 0.15); border: 2px solid rgba(16, 185, 129, 0.4); border-radius: 8px; margin-bottom: 16px;">
                <h4 style="margin: 0 0 12px 0; color: #6ee7b7; font-size: 16px; font-weight: 600;">? Dados Detectados:</h4>
                <div id="ocrResultContent" style="color: #a7f3d0; font-size: 14px; line-height: 1.8;"></div>
            </div>
            
            <div style="display: flex; gap: 12px;">
                <button onclick="fecharModalAnexo()" style="flex: 1; padding: 12px 24px; background: rgba(107, 114, 128, 0.8); color: white; border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">Cancelar</button>
                <button id="btnConfirmarAnexo" onclick="confirmarAnexo()" style="flex: 1; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6, #8b5cf6); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; display: none;">Confirmar Anexo</button>
            </div>
        </div>
    </div>
    
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #dropZone:hover {
            border-color: #2563eb;
            background: rgba(59, 130, 246, 0.15);
            transform: scale(1.02);
        }
        
        #dropZone.dragover {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.15);
            transform: scale(1.05);
        }
        
        /* Hover effects para dropdown de justificativa */
        #selectJustificativaSecullum:hover {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }
        
        #selectJustificativaSecullum:focus {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.15);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
        }
    </style>
</body>
</html>
